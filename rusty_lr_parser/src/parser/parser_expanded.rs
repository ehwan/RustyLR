// This file was generated by rustylr 0.3.1
//
// Input file: ../rusty_lr_parser/src/parser/parser.rs
// Output file: parser_expanded.rs
// ================================User Codes Begin================================
use crate::error::ParseError;
use crate::parser::args::GrammarArgs;
use crate::parser::args::PatternArgs;
use crate::parser::args::ReduceTypeArgs;
use crate::parser::args::RuleDefArgs;
use crate::parser::args::RuleLineArgs;
use crate::parser::lexer::Lexed;
use crate::terminalset::TerminalSet;
use crate::terminalset::TerminalSetItem;
use proc_macro2::Group;
use proc_macro2::Ident;
use proc_macro2::Span;
use proc_macro2::TokenStream;
use quote::ToTokens;
use rusty_lr_core::ReduceType;
use std::boxed::Box;
// =================================User Codes End=================================
/*
====================================Grammar=====================================
0: Action -> bracegroup
1: Action ->
2: EofDef -> eofdef RustCode semicolon
3: ErrorDef -> errortype RustCode semicolon
4: Grammar -> Grammar Rule
5: Grammar -> Rule
6: Grammar -> Grammar TokenDef
7: Grammar -> TokenDef
8: Grammar -> Grammar StartDef
9: Grammar -> StartDef
10: Grammar -> Grammar EofDef
11: Grammar -> EofDef
12: Grammar -> Grammar TokenTypeDef
13: Grammar -> TokenTypeDef
14: Grammar -> Grammar UserDataDef
15: Grammar -> UserDataDef
16: Grammar -> Grammar ReduceDef
17: Grammar -> ReduceDef
18: Grammar -> Grammar ErrorDef
19: Grammar -> ErrorDef
20: Grammar -> Grammar ModulePrefixDef
21: Grammar -> ModulePrefixDef
22: ModulePrefixDef -> moduleprefix RustCode semicolon
23: Pattern -> ident
24: Pattern -> Pattern plus
25: Pattern -> Pattern star
26: Pattern -> Pattern question
27: Pattern -> TerminalSet
28: ReduceDef -> ReduceType ident semicolon
29: ReduceDef -> ReduceType TerminalSet semicolon
30: ReduceType -> left
31: ReduceType -> right
32: Rule -> ident RuleType colon RuleLines semicolon
33: RuleLine -> _RustyLRGenerated0 Action
34: RuleLines -> RuleLines pipe RuleLine
35: RuleLines -> RuleLine
36: RuleType -> parengroup
37: RuleType ->
38: RustCode -> _RustyLRGenerated4
39: StartDef -> start ident semicolon
40: TerminalSet -> lbracket _RustyLRGenerated2 _RustyLRGenerated3 rbracket
41: TerminalSetItem -> ident
42: TerminalSetItem -> ident minus ident
43: TokenDef -> token ident RustCode semicolon
44: TokenMapped -> Pattern
45: TokenMapped -> ident equal Pattern
46: TokenTypeDef -> tokentype RustCode semicolon
47: UserDataDef -> userdata RustCode semicolon
48: _RustyLRGenerated0 -> _RustyLRGenerated1
49: _RustyLRGenerated0 ->
50: _RustyLRGenerated1 -> TokenMapped
51: _RustyLRGenerated1 -> _RustyLRGenerated1 TokenMapped
52: _RustyLRGenerated2 -> caret
53: _RustyLRGenerated2 ->
54: _RustyLRGenerated3 -> TerminalSetItem
55: _RustyLRGenerated3 -> _RustyLRGenerated3 TerminalSetItem
56: _RustyLRGenerated4 -> _RustyLRGenerated5
57: _RustyLRGenerated4 -> _RustyLRGenerated4 _RustyLRGenerated5
58: _RustyLRGenerated5 -> bracegroup
59: _RustyLRGenerated5 -> bracketgroup
60: _RustyLRGenerated5 -> caret
61: _RustyLRGenerated5 -> colon
62: _RustyLRGenerated5 -> equal
63: _RustyLRGenerated5 -> ident
64: _RustyLRGenerated5 -> literal
65: _RustyLRGenerated5 -> minus
66: _RustyLRGenerated5 -> nonegroup
67: _RustyLRGenerated5 -> otherpunct
68: _RustyLRGenerated5 -> parengroup
69: _RustyLRGenerated5 -> percent
70: _RustyLRGenerated5 -> pipe
71: _RustyLRGenerated5 -> plus
72: _RustyLRGenerated5 -> question
73: _RustyLRGenerated5 -> star
74: Augmented -> Grammar eof


*/
// =============================Generated Codes Begin==============================
#[doc = r" An enum that represents non-terminal symbols"]
#[allow(non_camel_case_types)]
#[derive(
    Debug,
    Clone,
    Copy,
    std :: hash :: Hash,
    std :: cmp :: PartialEq,
    std :: cmp :: Eq,
    std :: cmp :: PartialOrd,
    std :: cmp :: Ord,
)]
pub enum GrammarNonTerminals {
    Action,
    EofDef,
    ErrorDef,
    Grammar,
    ModulePrefixDef,
    Pattern,
    ReduceDef,
    ReduceType,
    Rule,
    RuleLine,
    RuleLines,
    RuleType,
    RustCode,
    StartDef,
    TerminalSet,
    TerminalSetItem,
    TokenDef,
    TokenMapped,
    TokenTypeDef,
    UserDataDef,
    _RustyLRGenerated0,
    _RustyLRGenerated1,
    _RustyLRGenerated2,
    _RustyLRGenerated3,
    _RustyLRGenerated4,
    _RustyLRGenerated5,
    Augmented,
}
impl std::fmt::Display for GrammarNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GrammarNonTerminals::Action => write!(f, "Action"),
            GrammarNonTerminals::EofDef => write!(f, "EofDef"),
            GrammarNonTerminals::ErrorDef => write!(f, "ErrorDef"),
            GrammarNonTerminals::Grammar => write!(f, "Grammar"),
            GrammarNonTerminals::ModulePrefixDef => write!(f, "ModulePrefixDef"),
            GrammarNonTerminals::Pattern => write!(f, "Pattern"),
            GrammarNonTerminals::ReduceDef => write!(f, "ReduceDef"),
            GrammarNonTerminals::ReduceType => write!(f, "ReduceType"),
            GrammarNonTerminals::Rule => write!(f, "Rule"),
            GrammarNonTerminals::RuleLine => write!(f, "RuleLine"),
            GrammarNonTerminals::RuleLines => write!(f, "RuleLines"),
            GrammarNonTerminals::RuleType => write!(f, "RuleType"),
            GrammarNonTerminals::RustCode => write!(f, "RustCode"),
            GrammarNonTerminals::StartDef => write!(f, "StartDef"),
            GrammarNonTerminals::TerminalSet => write!(f, "TerminalSet"),
            GrammarNonTerminals::TerminalSetItem => write!(f, "TerminalSetItem"),
            GrammarNonTerminals::TokenDef => write!(f, "TokenDef"),
            GrammarNonTerminals::TokenMapped => write!(f, "TokenMapped"),
            GrammarNonTerminals::TokenTypeDef => write!(f, "TokenTypeDef"),
            GrammarNonTerminals::UserDataDef => write!(f, "UserDataDef"),
            GrammarNonTerminals::_RustyLRGenerated0 => write!(f, "_RustyLRGenerated0"),
            GrammarNonTerminals::_RustyLRGenerated1 => write!(f, "_RustyLRGenerated1"),
            GrammarNonTerminals::_RustyLRGenerated2 => write!(f, "_RustyLRGenerated2"),
            GrammarNonTerminals::_RustyLRGenerated3 => write!(f, "_RustyLRGenerated3"),
            GrammarNonTerminals::_RustyLRGenerated4 => write!(f, "_RustyLRGenerated4"),
            GrammarNonTerminals::_RustyLRGenerated5 => write!(f, "_RustyLRGenerated5"),
            GrammarNonTerminals::Augmented => write!(f, "Augmented"),
        }
    }
}
#[doc = r" struct that holds internal parser data, for reduce action and state transition"]
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
pub struct GrammarContext {
    #[doc = r" state stack, user must not modify this"]
    pub state_stack: Vec<usize>,
    __rustylr_generated_terminal_stack: Vec<Lexed>,
    _rustylr_generated_Action_stack: Vec<(Option<Group>)>,
    _rustylr_generated_EofDef_stack: Vec<((Span, TokenStream))>,
    _rustylr_generated_ErrorDef_stack: Vec<((Span, TokenStream))>,
    _rustylr_generated_Grammar_stack: Vec<(GrammarArgs)>,
    _rustylr_generated_ModulePrefixDef_stack: Vec<((Span, TokenStream))>,
    _rustylr_generated_Pattern_stack: Vec<(PatternArgs)>,
    _rustylr_generated_ReduceDef_stack: Vec<((ReduceTypeArgs, ReduceType))>,
    _rustylr_generated_ReduceType_stack: Vec<(ReduceType)>,
    _rustylr_generated_Rule_stack: Vec<(RuleDefArgs)>,
    _rustylr_generated_RuleLine_stack: Vec<(RuleLineArgs)>,
    _rustylr_generated_RuleLines_stack: Vec<(Vec<RuleLineArgs>)>,
    _rustylr_generated_RuleType_stack: Vec<(Option<Group>)>,
    _rustylr_generated_RustCode_stack: Vec<(TokenStream)>,
    _rustylr_generated_StartDef_stack: Vec<(Ident)>,
    _rustylr_generated_TerminalSet_stack: Vec<(TerminalSet)>,
    _rustylr_generated_TerminalSetItem_stack: Vec<(TerminalSetItem)>,
    _rustylr_generated_TokenDef_stack: Vec<((Ident, TokenStream))>,
    _rustylr_generated_TokenMapped_stack: Vec<((Option<Ident>, PatternArgs))>,
    _rustylr_generated_TokenTypeDef_stack: Vec<((Span, TokenStream))>,
    _rustylr_generated_UserDataDef_stack: Vec<((Span, TokenStream))>,
    _rustylr_generated__RustyLRGenerated0_stack: Vec<Vec<((Option<Ident>, PatternArgs))>>,
    _rustylr_generated__RustyLRGenerated1_stack: Vec<Vec<((Option<Ident>, PatternArgs))>>,
    _rustylr_generated__RustyLRGenerated2_stack: Vec<Option<Lexed>>,
    _rustylr_generated__RustyLRGenerated3_stack: Vec<Vec<(TerminalSetItem)>>,
    _rustylr_generated__RustyLRGenerated4_stack: Vec<Vec<Lexed>>,
    _rustylr_generated__RustyLRGenerated5_stack: Vec<Lexed>,
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
impl GrammarContext {
    pub fn new() -> Self {
        Self {
            state_stack: vec![0],
            __rustylr_generated_terminal_stack: Vec::new(),
            _rustylr_generated_Action_stack: Vec::new(),
            _rustylr_generated_EofDef_stack: Vec::new(),
            _rustylr_generated_ErrorDef_stack: Vec::new(),
            _rustylr_generated_Grammar_stack: Vec::new(),
            _rustylr_generated_ModulePrefixDef_stack: Vec::new(),
            _rustylr_generated_Pattern_stack: Vec::new(),
            _rustylr_generated_ReduceDef_stack: Vec::new(),
            _rustylr_generated_ReduceType_stack: Vec::new(),
            _rustylr_generated_Rule_stack: Vec::new(),
            _rustylr_generated_RuleLine_stack: Vec::new(),
            _rustylr_generated_RuleLines_stack: Vec::new(),
            _rustylr_generated_RuleType_stack: Vec::new(),
            _rustylr_generated_RustCode_stack: Vec::new(),
            _rustylr_generated_StartDef_stack: Vec::new(),
            _rustylr_generated_TerminalSet_stack: Vec::new(),
            _rustylr_generated_TerminalSetItem_stack: Vec::new(),
            _rustylr_generated_TokenDef_stack: Vec::new(),
            _rustylr_generated_TokenMapped_stack: Vec::new(),
            _rustylr_generated_TokenTypeDef_stack: Vec::new(),
            _rustylr_generated_UserDataDef_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated0_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated1_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated2_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated3_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated4_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated5_stack: Vec::new(),
        }
    }
    fn reduce_Action_0(&mut self) -> Result<(), ParseError> {
        let mut bracegroup = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_Action_stack.push({
            if let Lexed::BraceGroup(group) = bracegroup {
                group
            } else {
                unreachable!("Action0");
            }
        });
        Ok(())
    }
    fn reduce_Action_1(&mut self) -> Result<(), ParseError> {
        self._rustylr_generated_Action_stack.push({ None });
        Ok(())
    }
    fn reduce_EofDef_0(&mut self) -> Result<(), ParseError> {
        let mut semicolon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut RustCode = self
            ._rustylr_generated_RustCode_stack
            .pop()
            .expect("Something wrong! RustCode stack is empty");
        let mut eofdef = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_EofDef_stack
            .push({ (eofdef.span().expect("EofDef"), RustCode) });
        Ok(())
    }
    fn reduce_ErrorDef_0(&mut self) -> Result<(), ParseError> {
        let mut semicolon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut RustCode = self
            ._rustylr_generated_RustCode_stack
            .pop()
            .expect("Something wrong! RustCode stack is empty");
        let mut errortype = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_ErrorDef_stack
            .push({ (errortype.span().expect("ErrorDef"), RustCode) });
        Ok(())
    }
    fn reduce_Grammar_0(&mut self) -> Result<(), ParseError> {
        let mut Rule = self
            ._rustylr_generated_Rule_stack
            .pop()
            .expect("Something wrong! Rule stack is empty");
        let mut Grammar = self
            ._rustylr_generated_Grammar_stack
            .pop()
            .expect("Something wrong! Grammar stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            Grammar.rules.push(Rule);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_1(&mut self) -> Result<(), ParseError> {
        let mut Rule = self
            ._rustylr_generated_Rule_stack
            .pop()
            .expect("Something wrong! Rule stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.rules.push(Rule);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_2(&mut self) -> Result<(), ParseError> {
        let mut TokenDef = self
            ._rustylr_generated_TokenDef_stack
            .pop()
            .expect("Something wrong! TokenDef stack is empty");
        let mut Grammar = self
            ._rustylr_generated_Grammar_stack
            .pop()
            .expect("Something wrong! Grammar stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            Grammar.terminals.push(TokenDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_3(&mut self) -> Result<(), ParseError> {
        let mut TokenDef = self
            ._rustylr_generated_TokenDef_stack
            .pop()
            .expect("Something wrong! TokenDef stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.terminals.push(TokenDef);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_4(&mut self) -> Result<(), ParseError> {
        let mut StartDef = self
            ._rustylr_generated_StartDef_stack
            .pop()
            .expect("Something wrong! StartDef stack is empty");
        let mut Grammar = self
            ._rustylr_generated_Grammar_stack
            .pop()
            .expect("Something wrong! Grammar stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            if let Some(old) = Grammar.start_rule_name {
                return Err(ParseError::MultipleStartDefinition(
                    StartDef.span(),
                    old,
                    StartDef,
                ));
            }
            Grammar.start_rule_name = Some(StartDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_5(&mut self) -> Result<(), ParseError> {
        let mut StartDef = self
            ._rustylr_generated_StartDef_stack
            .pop()
            .expect("Something wrong! StartDef stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.start_rule_name = Some(StartDef);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_6(&mut self) -> Result<(), ParseError> {
        let mut EofDef = self
            ._rustylr_generated_EofDef_stack
            .pop()
            .expect("Something wrong! EofDef stack is empty");
        let mut Grammar = self
            ._rustylr_generated_Grammar_stack
            .pop()
            .expect("Something wrong! Grammar stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let (span, eof) = EofDef;
            if let Some(old) = Grammar.eof {
                return Err(ParseError::MultipleEofDefinition(span, old, eof));
            }
            Grammar.eof = Some(eof);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_7(&mut self) -> Result<(), ParseError> {
        let mut EofDef = self
            ._rustylr_generated_EofDef_stack
            .pop()
            .expect("Something wrong! EofDef stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            let (span, eof) = EofDef;
            g.eof = Some(eof);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_8(&mut self) -> Result<(), ParseError> {
        let mut TokenTypeDef = self
            ._rustylr_generated_TokenTypeDef_stack
            .pop()
            .expect("Something wrong! TokenTypeDef stack is empty");
        let mut Grammar = self
            ._rustylr_generated_Grammar_stack
            .pop()
            .expect("Something wrong! Grammar stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let (span, token_type) = TokenTypeDef;
            if let Some(old) = Grammar.token_typename {
                return Err(ParseError::MultipleTokenTypeDefinition(
                    span, old, token_type,
                ));
            }
            Grammar.token_typename = Some(token_type);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_9(&mut self) -> Result<(), ParseError> {
        let mut TokenTypeDef = self
            ._rustylr_generated_TokenTypeDef_stack
            .pop()
            .expect("Something wrong! TokenTypeDef stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            let (span, token_type) = TokenTypeDef;
            g.token_typename = Some(token_type);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_10(&mut self) -> Result<(), ParseError> {
        let mut UserDataDef = self
            ._rustylr_generated_UserDataDef_stack
            .pop()
            .expect("Something wrong! UserDataDef stack is empty");
        let mut Grammar = self
            ._rustylr_generated_Grammar_stack
            .pop()
            .expect("Something wrong! Grammar stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let (span, user_data) = UserDataDef;
            if let Some(old) = Grammar.userdata_typename {
                return Err(ParseError::MultipleUserDataDefinition(span, old, user_data));
            }
            Grammar.userdata_typename = Some(user_data);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_11(&mut self) -> Result<(), ParseError> {
        let mut UserDataDef = self
            ._rustylr_generated_UserDataDef_stack
            .pop()
            .expect("Something wrong! UserDataDef stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            let (span, user_data) = UserDataDef;
            g.userdata_typename = Some(user_data);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_12(&mut self) -> Result<(), ParseError> {
        let mut ReduceDef = self
            ._rustylr_generated_ReduceDef_stack
            .pop()
            .expect("Something wrong! ReduceDef stack is empty");
        let mut Grammar = self
            ._rustylr_generated_Grammar_stack
            .pop()
            .expect("Something wrong! Grammar stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            Grammar.reduce_types.push(ReduceDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_13(&mut self) -> Result<(), ParseError> {
        let mut ReduceDef = self
            ._rustylr_generated_ReduceDef_stack
            .pop()
            .expect("Something wrong! ReduceDef stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.reduce_types.push(ReduceDef);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_14(&mut self) -> Result<(), ParseError> {
        let mut ErrorDef = self
            ._rustylr_generated_ErrorDef_stack
            .pop()
            .expect("Something wrong! ErrorDef stack is empty");
        let mut Grammar = self
            ._rustylr_generated_Grammar_stack
            .pop()
            .expect("Something wrong! Grammar stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let (span, error) = ErrorDef;
            if let Some(old) = Grammar.error_typename {
                return Err(ParseError::MultipleErrorDefinition(span, old, error));
            }
            Grammar.error_typename = Some(error);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_15(&mut self) -> Result<(), ParseError> {
        let mut ErrorDef = self
            ._rustylr_generated_ErrorDef_stack
            .pop()
            .expect("Something wrong! ErrorDef stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            let (span, error) = ErrorDef;
            g.error_typename = Some(error);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_16(&mut self) -> Result<(), ParseError> {
        let mut ModulePrefixDef = self
            ._rustylr_generated_ModulePrefixDef_stack
            .pop()
            .expect("Something wrong! ModulePrefixDef stack is empty");
        let mut Grammar = self
            ._rustylr_generated_Grammar_stack
            .pop()
            .expect("Something wrong! Grammar stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let (span, module_prefix) = ModulePrefixDef;
            Grammar.module_prefix = Some(module_prefix);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_17(&mut self) -> Result<(), ParseError> {
        let mut ModulePrefixDef = self
            ._rustylr_generated_ModulePrefixDef_stack
            .pop()
            .expect("Something wrong! ModulePrefixDef stack is empty");
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            let (span, module_prefix) = ModulePrefixDef;
            g.module_prefix = Some(module_prefix);
            g
        });
        Ok(())
    }
    fn reduce_ModulePrefixDef_0(&mut self) -> Result<(), ParseError> {
        let mut semicolon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut RustCode = self
            ._rustylr_generated_RustCode_stack
            .pop()
            .expect("Something wrong! RustCode stack is empty");
        let mut moduleprefix = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_ModulePrefixDef_stack
            .push({ (moduleprefix.span().expect("ModulePrefixDef"), RustCode) });
        Ok(())
    }
    fn reduce_Pattern_0(&mut self) -> Result<(), ParseError> {
        let mut ident = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_Pattern_stack.push({
            if let Lexed::Ident(ident) = ident {
                PatternArgs::Ident(ident.expect("Pattern-Ident"))
            } else {
                unreachable!("Pattern-Ident");
            }
        });
        Ok(())
    }
    fn reduce_Pattern_1(&mut self) -> Result<(), ParseError> {
        let mut plus = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut Pattern = self
            ._rustylr_generated_Pattern_stack
            .pop()
            .expect("Something wrong! Pattern stack is empty");
        self._rustylr_generated_Pattern_stack
            .push({ PatternArgs::Plus(Box::new(Pattern)) });
        Ok(())
    }
    fn reduce_Pattern_2(&mut self) -> Result<(), ParseError> {
        let mut star = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut Pattern = self
            ._rustylr_generated_Pattern_stack
            .pop()
            .expect("Something wrong! Pattern stack is empty");
        self._rustylr_generated_Pattern_stack
            .push({ PatternArgs::Star(Box::new(Pattern)) });
        Ok(())
    }
    fn reduce_Pattern_3(&mut self) -> Result<(), ParseError> {
        let mut question = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut Pattern = self
            ._rustylr_generated_Pattern_stack
            .pop()
            .expect("Something wrong! Pattern stack is empty");
        self._rustylr_generated_Pattern_stack
            .push({ PatternArgs::Question(Box::new(Pattern)) });
        Ok(())
    }
    fn reduce_Pattern_4(&mut self) -> Result<(), ParseError> {
        let mut TerminalSet = self
            ._rustylr_generated_TerminalSet_stack
            .pop()
            .expect("Something wrong! TerminalSet stack is empty");
        self._rustylr_generated_Pattern_stack
            .push({ PatternArgs::TerminalSet(TerminalSet) });
        Ok(())
    }
    fn reduce_ReduceDef_0(&mut self) -> Result<(), ParseError> {
        let mut semicolon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut ident = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut reducetype = self
            ._rustylr_generated_ReduceType_stack
            .pop()
            .expect("Something wrong! ReduceType stack is empty");
        self._rustylr_generated_ReduceDef_stack.push({
            if let Lexed::Ident(ident) = ident {
                (
                    ReduceTypeArgs::Ident(ident.expect("ReduceDef-Ident")),
                    reducetype,
                )
            } else {
                unreachable!("ReduceDef-Ident (Left)");
            }
        });
        Ok(())
    }
    fn reduce_ReduceDef_1(&mut self) -> Result<(), ParseError> {
        let mut semicolon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut TerminalSet = self
            ._rustylr_generated_TerminalSet_stack
            .pop()
            .expect("Something wrong! TerminalSet stack is empty");
        let mut reducetype = self
            ._rustylr_generated_ReduceType_stack
            .pop()
            .expect("Something wrong! ReduceType stack is empty");
        self._rustylr_generated_ReduceDef_stack
            .push({ (ReduceTypeArgs::TerminalSet(TerminalSet), reducetype) });
        Ok(())
    }
    fn reduce_ReduceType_0(&mut self) -> Result<(), ParseError> {
        let mut left = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_ReduceType_stack
            .push({ ReduceType::Left });
        Ok(())
    }
    fn reduce_ReduceType_1(&mut self) -> Result<(), ParseError> {
        let mut right = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_ReduceType_stack
            .push({ ReduceType::Right });
        Ok(())
    }
    fn reduce_Rule_0(&mut self) -> Result<(), ParseError> {
        let mut semicolon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut RuleLines = self
            ._rustylr_generated_RuleLines_stack
            .pop()
            .expect("Something wrong! RuleLines stack is empty");
        let mut colon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut RuleType = self
            ._rustylr_generated_RuleType_stack
            .pop()
            .expect("Something wrong! RuleType stack is empty");
        let mut ident = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_Rule_stack.push({
            let ident = if let Lexed::Ident(ident) = ident {
                ident.expect("Rule-Ident")
            } else {
                unreachable!("Rule-Ident");
            };
            RuleDefArgs {
                name: ident,
                typename: RuleType.map(|t| t.to_token_stream()),
                rule_lines: RuleLines,
            }
        });
        Ok(())
    }
    fn reduce_RuleLine_0(&mut self) -> Result<(), ParseError> {
        let mut Action = self
            ._rustylr_generated_Action_stack
            .pop()
            .expect("Something wrong! Action stack is empty");
        let mut TokenMapped = self
            ._rustylr_generated__RustyLRGenerated0_stack
            .pop()
            .expect("Something wrong! _RustyLRGenerated0 stack is empty");
        self._rustylr_generated_RuleLine_stack.push({
            RuleLineArgs {
                tokens: TokenMapped,
                reduce_action: Action.map(|action| action.to_token_stream()),
            }
        });
        Ok(())
    }
    fn reduce_RuleLines_0(&mut self) -> Result<(), ParseError> {
        let mut RuleLine = self
            ._rustylr_generated_RuleLine_stack
            .pop()
            .expect("Something wrong! RuleLine stack is empty");
        let mut pipe = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut RuleLines = self
            ._rustylr_generated_RuleLines_stack
            .pop()
            .expect("Something wrong! RuleLines stack is empty");
        self._rustylr_generated_RuleLines_stack.push({
            RuleLines.push(RuleLine);
            RuleLines
        });
        Ok(())
    }
    fn reduce_RuleLines_1(&mut self) -> Result<(), ParseError> {
        let mut RuleLine = self
            ._rustylr_generated_RuleLine_stack
            .pop()
            .expect("Something wrong! RuleLine stack is empty");
        self._rustylr_generated_RuleLines_stack
            .push({ vec![RuleLine] });
        Ok(())
    }
    fn reduce_RuleType_0(&mut self) -> Result<(), ParseError> {
        let mut parengroup = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_RuleType_stack.push({
            if let Lexed::ParenGroup(group) = parengroup {
                group
            } else {
                unreachable!("RuleType - Group");
            }
        });
        Ok(())
    }
    fn reduce_RuleType_1(&mut self) -> Result<(), ParseError> {
        self._rustylr_generated_RuleType_stack.push({ None });
        Ok(())
    }
    fn reduce_RustCode_0(&mut self) -> Result<(), ParseError> {
        let mut t = self
            ._rustylr_generated__RustyLRGenerated4_stack
            .pop()
            .expect("Something wrong! _RustyLRGenerated4 stack is empty");
        self._rustylr_generated_RustCode_stack.push({
            let mut tokens = TokenStream::new();
            for token in t.into_iter() {
                tokens.extend(token.stream());
            }
            tokens
        });
        Ok(())
    }
    fn reduce_StartDef_0(&mut self) -> Result<(), ParseError> {
        let mut semicolon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut ident = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut start = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_StartDef_stack.push({
            if let Lexed::Ident(ident) = ident {
                ident.expect("StartDef")
            } else {
                unreachable!("StartDef-Ident");
            }
        });
        Ok(())
    }
    fn reduce_TerminalSet_0(&mut self) -> Result<(), ParseError> {
        let mut rbracket = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut TerminalSetItem = self
            ._rustylr_generated__RustyLRGenerated3_stack
            .pop()
            .expect("Something wrong! _RustyLRGenerated3 stack is empty");
        let mut caret = self
            ._rustylr_generated__RustyLRGenerated2_stack
            .pop()
            .expect("Something wrong! _RustyLRGenerated2 stack is empty");
        let mut lbracket = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_TerminalSet_stack.push({
            TerminalSet {
                negate: caret.is_some(),
                items: TerminalSetItem,
            }
        });
        Ok(())
    }
    fn reduce_TerminalSetItem_0(&mut self) -> Result<(), ParseError> {
        let mut ident = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_TerminalSetItem_stack.push({
            let ident = if let Lexed::Ident(ident) = ident {
                ident.expect("TerminalSetItem-Range0")
            } else {
                unreachable!("TerminalSetItem-Range1");
            };
            TerminalSetItem::Terminal(ident)
        });
        Ok(())
    }
    fn reduce_TerminalSetItem_1(&mut self) -> Result<(), ParseError> {
        let mut last = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut minus = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut first = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_TerminalSetItem_stack.push({
            let first = if let Lexed::Ident(first) = first {
                first.expect("TerminalSetItem-Range0")
            } else {
                unreachable!("TerminalSetItem-Range1");
            };
            let last = if let Lexed::Ident(last) = last {
                last.expect("TerminalSetItem-Range2")
            } else {
                unreachable!("TerminalSetItem-Range3");
            };
            TerminalSetItem::Range(first, last)
        });
        Ok(())
    }
    fn reduce_TokenDef_0(&mut self) -> Result<(), ParseError> {
        let mut semicolon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut RustCode = self
            ._rustylr_generated_RustCode_stack
            .pop()
            .expect("Something wrong! RustCode stack is empty");
        let mut ident = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut token = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_TokenDef_stack.push({
            if let Lexed::Ident(ident) = ident {
                (ident.expect("TokenDef"), RustCode)
            } else {
                unreachable!("TokenDef-Ident");
            }
        });
        Ok(())
    }
    fn reduce_TokenMapped_0(&mut self) -> Result<(), ParseError> {
        let mut Pattern = self
            ._rustylr_generated_Pattern_stack
            .pop()
            .expect("Something wrong! Pattern stack is empty");
        self._rustylr_generated_TokenMapped_stack
            .push({ (None, Pattern) });
        Ok(())
    }
    fn reduce_TokenMapped_1(&mut self) -> Result<(), ParseError> {
        let mut Pattern = self
            ._rustylr_generated_Pattern_stack
            .pop()
            .expect("Something wrong! Pattern stack is empty");
        let mut equal = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut ident = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_TokenMapped_stack.push({
            if let Lexed::Ident(ident) = ident {
                (ident, Pattern)
            } else {
                unreachable!("Token-Ident");
            }
        });
        Ok(())
    }
    fn reduce_TokenTypeDef_0(&mut self) -> Result<(), ParseError> {
        let mut semicolon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut RustCode = self
            ._rustylr_generated_RustCode_stack
            .pop()
            .expect("Something wrong! RustCode stack is empty");
        let mut tokentype = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_TokenTypeDef_stack
            .push({ (tokentype.span().expect("TokenTypedef"), RustCode) });
        Ok(())
    }
    fn reduce_UserDataDef_0(&mut self) -> Result<(), ParseError> {
        let mut semicolon = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        let mut RustCode = self
            ._rustylr_generated_RustCode_stack
            .pop()
            .expect("Something wrong! RustCode stack is empty");
        let mut userdata = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated_UserDataDef_stack
            .push({ (userdata.span().expect("UserDataDef"), RustCode) });
        Ok(())
    }
    fn reduce__RustyLRGenerated0_0(&mut self) -> Result<(), ParseError> {
        let mut Ap = self
            ._rustylr_generated__RustyLRGenerated1_stack
            .pop()
            .expect("Something wrong! _RustyLRGenerated1 stack is empty");
        self._rustylr_generated__RustyLRGenerated0_stack
            .push({ Ap });
        Ok(())
    }
    fn reduce__RustyLRGenerated0_1(&mut self) -> Result<(), ParseError> {
        self._rustylr_generated__RustyLRGenerated0_stack
            .push({ vec![] });
        Ok(())
    }
    fn reduce__RustyLRGenerated1_0(&mut self) -> Result<(), ParseError> {
        let mut A = self
            ._rustylr_generated_TokenMapped_stack
            .pop()
            .expect("Something wrong! TokenMapped stack is empty");
        self._rustylr_generated__RustyLRGenerated1_stack
            .push({ vec![A] });
        Ok(())
    }
    fn reduce__RustyLRGenerated1_1(&mut self) -> Result<(), ParseError> {
        let mut A = self
            ._rustylr_generated_TokenMapped_stack
            .pop()
            .expect("Something wrong! TokenMapped stack is empty");
        let mut Ap = self
            ._rustylr_generated__RustyLRGenerated1_stack
            .pop()
            .expect("Something wrong! _RustyLRGenerated1 stack is empty");
        self._rustylr_generated__RustyLRGenerated1_stack.push({
            Ap.push(A);
            Ap
        });
        Ok(())
    }
    fn reduce__RustyLRGenerated2_0(&mut self) -> Result<(), ParseError> {
        let mut A = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated2_stack
            .push({ Some(A) });
        Ok(())
    }
    fn reduce__RustyLRGenerated2_1(&mut self) -> Result<(), ParseError> {
        self._rustylr_generated__RustyLRGenerated2_stack
            .push({ None });
        Ok(())
    }
    fn reduce__RustyLRGenerated3_0(&mut self) -> Result<(), ParseError> {
        let mut A = self
            ._rustylr_generated_TerminalSetItem_stack
            .pop()
            .expect("Something wrong! TerminalSetItem stack is empty");
        self._rustylr_generated__RustyLRGenerated3_stack
            .push({ vec![A] });
        Ok(())
    }
    fn reduce__RustyLRGenerated3_1(&mut self) -> Result<(), ParseError> {
        let mut A = self
            ._rustylr_generated_TerminalSetItem_stack
            .pop()
            .expect("Something wrong! TerminalSetItem stack is empty");
        let mut Ap = self
            ._rustylr_generated__RustyLRGenerated3_stack
            .pop()
            .expect("Something wrong! _RustyLRGenerated3 stack is empty");
        self._rustylr_generated__RustyLRGenerated3_stack.push({
            Ap.push(A);
            Ap
        });
        Ok(())
    }
    fn reduce__RustyLRGenerated4_0(&mut self) -> Result<(), ParseError> {
        let mut A = self
            ._rustylr_generated__RustyLRGenerated5_stack
            .pop()
            .expect("Something wrong! _RustyLRGenerated5 stack is empty");
        self._rustylr_generated__RustyLRGenerated4_stack
            .push({ vec![A] });
        Ok(())
    }
    fn reduce__RustyLRGenerated4_1(&mut self) -> Result<(), ParseError> {
        let mut A = self
            ._rustylr_generated__RustyLRGenerated5_stack
            .pop()
            .expect("Something wrong! _RustyLRGenerated5 stack is empty");
        let mut Ap = self
            ._rustylr_generated__RustyLRGenerated4_stack
            .pop()
            .expect("Something wrong! _RustyLRGenerated4 stack is empty");
        self._rustylr_generated__RustyLRGenerated4_stack.push({
            Ap.push(A);
            Ap
        });
        Ok(())
    }
    fn reduce__RustyLRGenerated5_0(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_1(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_2(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_3(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_4(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_5(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_6(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_7(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_8(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_9(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_10(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_11(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_12(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_13(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_14(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_15(&mut self) -> Result<(), ParseError> {
        let mut term = self
            .__rustylr_generated_terminal_stack
            .pop()
            .expect("Something wrong! term_stack is empty");
        self._rustylr_generated__RustyLRGenerated5_stack.push(term);
        Ok(())
    }
    #[doc = r" reduce items in stack, this function is called automatically by parser"]
    pub fn reduce(
        &mut self,
        rulelen: usize,
        rustylr_macro_generated_ruleid__: usize,
    ) -> Result<(), ParseError> {
        match rustylr_macro_generated_ruleid__ {
            0usize => {
                self.reduce_Action_0()?;
            }
            1usize => {
                self.reduce_Action_1()?;
            }
            2usize => {
                self.reduce_EofDef_0()?;
            }
            3usize => {
                self.reduce_ErrorDef_0()?;
            }
            4usize => {
                self.reduce_Grammar_0()?;
            }
            5usize => {
                self.reduce_Grammar_1()?;
            }
            6usize => {
                self.reduce_Grammar_2()?;
            }
            7usize => {
                self.reduce_Grammar_3()?;
            }
            8usize => {
                self.reduce_Grammar_4()?;
            }
            9usize => {
                self.reduce_Grammar_5()?;
            }
            10usize => {
                self.reduce_Grammar_6()?;
            }
            11usize => {
                self.reduce_Grammar_7()?;
            }
            12usize => {
                self.reduce_Grammar_8()?;
            }
            13usize => {
                self.reduce_Grammar_9()?;
            }
            14usize => {
                self.reduce_Grammar_10()?;
            }
            15usize => {
                self.reduce_Grammar_11()?;
            }
            16usize => {
                self.reduce_Grammar_12()?;
            }
            17usize => {
                self.reduce_Grammar_13()?;
            }
            18usize => {
                self.reduce_Grammar_14()?;
            }
            19usize => {
                self.reduce_Grammar_15()?;
            }
            20usize => {
                self.reduce_Grammar_16()?;
            }
            21usize => {
                self.reduce_Grammar_17()?;
            }
            22usize => {
                self.reduce_ModulePrefixDef_0()?;
            }
            23usize => {
                self.reduce_Pattern_0()?;
            }
            24usize => {
                self.reduce_Pattern_1()?;
            }
            25usize => {
                self.reduce_Pattern_2()?;
            }
            26usize => {
                self.reduce_Pattern_3()?;
            }
            27usize => {
                self.reduce_Pattern_4()?;
            }
            28usize => {
                self.reduce_ReduceDef_0()?;
            }
            29usize => {
                self.reduce_ReduceDef_1()?;
            }
            30usize => {
                self.reduce_ReduceType_0()?;
            }
            31usize => {
                self.reduce_ReduceType_1()?;
            }
            32usize => {
                self.reduce_Rule_0()?;
            }
            33usize => {
                self.reduce_RuleLine_0()?;
            }
            34usize => {
                self.reduce_RuleLines_0()?;
            }
            35usize => {
                self.reduce_RuleLines_1()?;
            }
            36usize => {
                self.reduce_RuleType_0()?;
            }
            37usize => {
                self.reduce_RuleType_1()?;
            }
            38usize => {
                self.reduce_RustCode_0()?;
            }
            39usize => {
                self.reduce_StartDef_0()?;
            }
            40usize => {
                self.reduce_TerminalSet_0()?;
            }
            41usize => {
                self.reduce_TerminalSetItem_0()?;
            }
            42usize => {
                self.reduce_TerminalSetItem_1()?;
            }
            43usize => {
                self.reduce_TokenDef_0()?;
            }
            44usize => {
                self.reduce_TokenMapped_0()?;
            }
            45usize => {
                self.reduce_TokenMapped_1()?;
            }
            46usize => {
                self.reduce_TokenTypeDef_0()?;
            }
            47usize => {
                self.reduce_UserDataDef_0()?;
            }
            48usize => {
                self.reduce__RustyLRGenerated0_0()?;
            }
            49usize => {
                self.reduce__RustyLRGenerated0_1()?;
            }
            50usize => {
                self.reduce__RustyLRGenerated1_0()?;
            }
            51usize => {
                self.reduce__RustyLRGenerated1_1()?;
            }
            52usize => {
                self.reduce__RustyLRGenerated2_0()?;
            }
            53usize => {
                self.reduce__RustyLRGenerated2_1()?;
            }
            54usize => {
                self.reduce__RustyLRGenerated3_0()?;
            }
            55usize => {
                self.reduce__RustyLRGenerated3_1()?;
            }
            56usize => {
                self.reduce__RustyLRGenerated4_0()?;
            }
            57usize => {
                self.reduce__RustyLRGenerated4_1()?;
            }
            58usize => {
                self.reduce__RustyLRGenerated5_0()?;
            }
            59usize => {
                self.reduce__RustyLRGenerated5_1()?;
            }
            60usize => {
                self.reduce__RustyLRGenerated5_2()?;
            }
            61usize => {
                self.reduce__RustyLRGenerated5_3()?;
            }
            62usize => {
                self.reduce__RustyLRGenerated5_4()?;
            }
            63usize => {
                self.reduce__RustyLRGenerated5_5()?;
            }
            64usize => {
                self.reduce__RustyLRGenerated5_6()?;
            }
            65usize => {
                self.reduce__RustyLRGenerated5_7()?;
            }
            66usize => {
                self.reduce__RustyLRGenerated5_8()?;
            }
            67usize => {
                self.reduce__RustyLRGenerated5_9()?;
            }
            68usize => {
                self.reduce__RustyLRGenerated5_10()?;
            }
            69usize => {
                self.reduce__RustyLRGenerated5_11()?;
            }
            70usize => {
                self.reduce__RustyLRGenerated5_12()?;
            }
            71usize => {
                self.reduce__RustyLRGenerated5_13()?;
            }
            72usize => {
                self.reduce__RustyLRGenerated5_14()?;
            }
            73usize => {
                self.reduce__RustyLRGenerated5_15()?;
            }
            _ => {
                unreachable!("Invalid Rule: {}", rustylr_macro_generated_ruleid__);
            }
        }
        Ok(())
    }
    #[doc = r" pop value from start rule"]
    pub fn accept(&mut self) -> (GrammarArgs) {
        self._rustylr_generated_Grammar_stack
            .pop()
            .expect("Something wrong! start_rule_stack is empty")
    }
    #[doc = r" push terminal symbol to stack, this function is called automatically by parser"]
    pub fn push(&mut self, term: Lexed) {
        self.__rustylr_generated_terminal_stack.push(term);
    }
}
#[doc = r" struct that holds parser data, DFA tables"]
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
pub struct GrammarParser {
    #[doc = r" production rules"]
    pub rules: Vec<::rusty_lr_core::ProductionRule<Lexed, GrammarNonTerminals>>,
    #[doc = r" states"]
    pub states: Vec<::rusty_lr_core::State<Lexed, GrammarNonTerminals>>,
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
impl GrammarParser {
    pub fn new() -> Self {
        let rules = vec![
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Action,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::BraceGroup(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Action,
                rule: vec![],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::EofDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::EofDef(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::ErrorDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::ErrorType(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Rule),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Rule)],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TokenDef),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::TokenDef,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::StartDef),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::StartDef,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::EofDef),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::EofDef)],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TokenTypeDef),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::TokenTypeDef,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::UserDataDef),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::UserDataDef,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::ReduceDef),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::ReduceDef,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::ErrorDef),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::ErrorDef,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::ModulePrefixDef),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::ModulePrefixDef,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::ModulePrefixDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::ModulePrefix(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Ident(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
                    ::rusty_lr_core::Token::Term(Lexed::Plus(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
                    ::rusty_lr_core::Token::Term(Lexed::Star(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
                    ::rusty_lr_core::Token::Term(Lexed::Question(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::TerminalSet,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::ReduceDef,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::ReduceType),
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::ReduceDef,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::ReduceType),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TerminalSet),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::ReduceType,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Left(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::ReduceType,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Right(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Rule,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleType),
                    ::rusty_lr_core::Token::Term(Lexed::Colon(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleLines),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::RuleLine,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated0),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Action),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::RuleLines,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleLines),
                    ::rusty_lr_core::Token::Term(Lexed::Pipe(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleLine),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::RuleLines,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::RuleLine,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::RuleType,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::ParenGroup(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::RuleType,
                rule: vec![],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::RustCode,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::_RustyLRGenerated4,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::StartDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::Start(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::TerminalSet,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::LBracket(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated2),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated3),
                    ::rusty_lr_core::Token::Term(Lexed::RBracket(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::TerminalSetItem,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Ident(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::TerminalSetItem,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Minus(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::TokenDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::Token(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::TokenMapped,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::Pattern,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::TokenMapped,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Equal(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::TokenTypeDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::TokenType(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::UserDataDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::UserData(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated0,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::_RustyLRGenerated1,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated0,
                rule: vec![],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated1,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::TokenMapped,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated1,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated1),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TokenMapped),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated2,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Caret(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated2,
                rule: vec![],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated3,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::TerminalSetItem,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated3,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated3),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TerminalSetItem),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated4,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::_RustyLRGenerated5,
                )],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated4,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated4),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated5),
                ],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::BraceGroup(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::BracketGroup(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Caret(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Colon(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Equal(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Ident(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Literal(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Minus(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::NoneGroup(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::OtherPunct(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::ParenGroup(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Percent(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Pipe(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Plus(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Question(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Star(None))],
            },
            ::rusty_lr_core::ProductionRule {
                name: GrammarNonTerminals::Augmented,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::Term(Lexed::Eof),
                ],
            },
        ];
        let _rustylr_generated_terminals_0 = vec![
            Lexed::BraceGroup(None),
            Lexed::BracketGroup(None),
            Lexed::Caret(None),
            Lexed::Colon(None),
            Lexed::Equal(None),
            Lexed::Ident(None),
            Lexed::Literal(None),
            Lexed::Minus(None),
            Lexed::NoneGroup(None),
            Lexed::OtherPunct(None),
            Lexed::ParenGroup(None),
            Lexed::Percent(None),
            Lexed::Pipe(None),
            Lexed::Plus(None),
            Lexed::Question(None),
            Lexed::Semicolon(None),
            Lexed::Star(None),
        ];
        let _rustylr_generated_terminals_1 = vec![
            Lexed::Eof,
            Lexed::EofDef(None),
            Lexed::ErrorType(None),
            Lexed::Ident(None),
            Lexed::Left(None),
            Lexed::ModulePrefix(None),
            Lexed::Right(None),
            Lexed::Start(None),
            Lexed::Token(None),
            Lexed::TokenType(None),
            Lexed::UserData(None),
        ];
        let _rustylr_generated_terminals_2 = vec![Lexed::Semicolon(None)];
        let _rustylr_generated_terminals_3 = vec![Lexed::Colon(None)];
        let _rustylr_generated_terminals_4 = vec![
            Lexed::BraceGroup(None),
            Lexed::Pipe(None),
            Lexed::Semicolon(None),
        ];
        let _rustylr_generated_terminals_5 = vec![
            Lexed::BraceGroup(None),
            Lexed::Ident(None),
            Lexed::LBracket(None),
            Lexed::Pipe(None),
            Lexed::Plus(None),
            Lexed::Question(None),
            Lexed::Semicolon(None),
            Lexed::Star(None),
        ];
        let _rustylr_generated_terminals_6 = vec![Lexed::Ident(None)];
        let _rustylr_generated_terminals_7 = vec![Lexed::Ident(None), Lexed::RBracket(None)];
        let _rustylr_generated_terminals_8 = vec![
            Lexed::BraceGroup(None),
            Lexed::Ident(None),
            Lexed::LBracket(None),
            Lexed::Pipe(None),
            Lexed::Semicolon(None),
        ];
        let _rustylr_generated_terminals_9 = vec![Lexed::Pipe(None), Lexed::Semicolon(None)];
        let _rustylr_generated_terminals_10 = vec![Lexed::Ident(None), Lexed::LBracket(None)];
        let pair_to_rule = |(rule, shifted): (usize, usize)| -> (
            ::rusty_lr_core::ShiftedRuleRef,
            std::collections::BTreeSet<Lexed>,
        ) {
            (
                ::rusty_lr_core::ShiftedRuleRef { rule, shifted },
                Default::default(),
            )
        };
        let mut states = Vec::with_capacity(107usize);
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(10usize);
            shift_goto_map_term.insert(Lexed::EofDef(None), 1usize);
            shift_goto_map_term.insert(Lexed::ErrorType(None), 23usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 26usize);
            shift_goto_map_term.insert(Lexed::Left(None), 60usize);
            shift_goto_map_term.insert(Lexed::ModulePrefix(None), 61usize);
            shift_goto_map_term.insert(Lexed::Right(None), 64usize);
            shift_goto_map_term.insert(Lexed::Start(None), 65usize);
            shift_goto_map_term.insert(Lexed::Token(None), 68usize);
            shift_goto_map_term.insert(Lexed::TokenType(None), 72usize);
            shift_goto_map_term.insert(Lexed::UserData(None), 75usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(11usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::EofDef, 78usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ErrorDef, 79usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Grammar, 80usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ModulePrefixDef, 100usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ReduceDef, 101usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ReduceType, 86usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Rule, 102usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::StartDef, 103usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenDef, 104usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenTypeDef, 105usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::UserDataDef, 106usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (2usize, 0usize),
                (3usize, 0usize),
                (4usize, 0usize),
                (5usize, 0usize),
                (6usize, 0usize),
                (7usize, 0usize),
                (8usize, 0usize),
                (9usize, 0usize),
                (10usize, 0usize),
                (11usize, 0usize),
                (12usize, 0usize),
                (13usize, 0usize),
                (14usize, 0usize),
                (15usize, 0usize),
                (16usize, 0usize),
                (17usize, 0usize),
                (18usize, 0usize),
                (19usize, 0usize),
                (20usize, 0usize),
                (21usize, 0usize),
                (22usize, 0usize),
                (28usize, 0usize),
                (29usize, 0usize),
                (30usize, 0usize),
                (31usize, 0usize),
                (32usize, 0usize),
                (39usize, 0usize),
                (43usize, 0usize),
                (46usize, 0usize),
                (47usize, 0usize),
                (74usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(16usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 7usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 8usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 9usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 10usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 11usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 12usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 13usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 14usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 15usize);
            shift_goto_map_term.insert(Lexed::Question(None), 16usize);
            shift_goto_map_term.insert(Lexed::Star(None), 17usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 18usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated4, 20usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 22usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (2usize, 1usize),
                (38usize, 0usize),
                (56usize, 0usize),
                (57usize, 0usize),
                (58usize, 0usize),
                (59usize, 0usize),
                (60usize, 0usize),
                (61usize, 0usize),
                (62usize, 0usize),
                (63usize, 0usize),
                (64usize, 0usize),
                (65usize, 0usize),
                (66usize, 0usize),
                (67usize, 0usize),
                (68usize, 0usize),
                (69usize, 0usize),
                (70usize, 0usize),
                (71usize, 0usize),
                (72usize, 0usize),
                (73usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 58usize);
            }
            let rule_shifted_pairs = vec![(58usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 59usize);
            }
            let rule_shifted_pairs = vec![(59usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 60usize);
            }
            let rule_shifted_pairs = vec![(60usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 61usize);
            }
            let rule_shifted_pairs = vec![(61usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 62usize);
            }
            let rule_shifted_pairs = vec![(62usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 63usize);
            }
            let rule_shifted_pairs = vec![(63usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 64usize);
            }
            let rule_shifted_pairs = vec![(64usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 65usize);
            }
            let rule_shifted_pairs = vec![(65usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 66usize);
            }
            let rule_shifted_pairs = vec![(66usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 67usize);
            }
            let rule_shifted_pairs = vec![(67usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 68usize);
            }
            let rule_shifted_pairs = vec![(68usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 69usize);
            }
            let rule_shifted_pairs = vec![(69usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 70usize);
            }
            let rule_shifted_pairs = vec![(70usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 71usize);
            }
            let rule_shifted_pairs = vec![(71usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 72usize);
            }
            let rule_shifted_pairs = vec![(72usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 73usize);
            }
            let rule_shifted_pairs = vec![(73usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 19usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(2usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 2usize);
            }
            let rule_shifted_pairs = vec![(2usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(16usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 7usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 8usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 9usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 10usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 11usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 12usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 13usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 14usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 15usize);
            shift_goto_map_term.insert(Lexed::Question(None), 16usize);
            shift_goto_map_term.insert(Lexed::Star(None), 17usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 21usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_2.iter() {
                reduce_map.insert(term.clone(), 38usize);
            }
            let rule_shifted_pairs = vec![
                (38usize, 1usize),
                (57usize, 1usize),
                (58usize, 0usize),
                (59usize, 0usize),
                (60usize, 0usize),
                (61usize, 0usize),
                (62usize, 0usize),
                (63usize, 0usize),
                (64usize, 0usize),
                (65usize, 0usize),
                (66usize, 0usize),
                (67usize, 0usize),
                (68usize, 0usize),
                (69usize, 0usize),
                (70usize, 0usize),
                (71usize, 0usize),
                (72usize, 0usize),
                (73usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 57usize);
            }
            let rule_shifted_pairs = vec![(57usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(17usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 56usize);
            }
            let rule_shifted_pairs = vec![(56usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(16usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 7usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 8usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 9usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 10usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 11usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 12usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 13usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 14usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 15usize);
            shift_goto_map_term.insert(Lexed::Question(None), 16usize);
            shift_goto_map_term.insert(Lexed::Star(None), 17usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 24usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated4, 20usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 22usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (3usize, 1usize),
                (38usize, 0usize),
                (56usize, 0usize),
                (57usize, 0usize),
                (58usize, 0usize),
                (59usize, 0usize),
                (60usize, 0usize),
                (61usize, 0usize),
                (62usize, 0usize),
                (63usize, 0usize),
                (64usize, 0usize),
                (65usize, 0usize),
                (66usize, 0usize),
                (67usize, 0usize),
                (68usize, 0usize),
                (69usize, 0usize),
                (70usize, 0usize),
                (71usize, 0usize),
                (72usize, 0usize),
                (73usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 25usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(3usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 3usize);
            }
            let rule_shifted_pairs = vec![(3usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 27usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RuleType, 28usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_3.iter() {
                reduce_map.insert(term.clone(), 37usize);
            }
            let rule_shifted_pairs = vec![(32usize, 1usize), (36usize, 0usize), (37usize, 0usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_3.iter() {
                reduce_map.insert(term.clone(), 36usize);
            }
            let rule_shifted_pairs = vec![(36usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 29usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(32usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 30usize);
            shift_goto_map_term.insert(Lexed::LBracket(None), 33usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(7usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Pattern, 48usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RuleLine, 49usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RuleLines, 50usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSet, 47usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenMapped, 53usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated0, 54usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated1, 57usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(3usize);
            for term in _rustylr_generated_terminals_4.iter() {
                reduce_map.insert(term.clone(), 49usize);
            }
            let rule_shifted_pairs = vec![
                (23usize, 0usize),
                (24usize, 0usize),
                (25usize, 0usize),
                (26usize, 0usize),
                (27usize, 0usize),
                (32usize, 3usize),
                (33usize, 0usize),
                (34usize, 0usize),
                (35usize, 0usize),
                (40usize, 0usize),
                (44usize, 0usize),
                (45usize, 0usize),
                (48usize, 0usize),
                (49usize, 0usize),
                (50usize, 0usize),
                (51usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 31usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(8usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 23usize);
            }
            let rule_shifted_pairs = vec![(23usize, 1usize), (45usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 32usize);
            shift_goto_map_term.insert(Lexed::LBracket(None), 33usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(2usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Pattern, 43usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSet, 47usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (23usize, 0usize),
                (24usize, 0usize),
                (25usize, 0usize),
                (26usize, 0usize),
                (27usize, 0usize),
                (40usize, 0usize),
                (45usize, 2usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(8usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 23usize);
            }
            let rule_shifted_pairs = vec![(23usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 34usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated2, 35usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_6.iter() {
                reduce_map.insert(term.clone(), 53usize);
            }
            let rule_shifted_pairs = vec![(40usize, 1usize), (52usize, 0usize), (53usize, 0usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_6.iter() {
                reduce_map.insert(term.clone(), 52usize);
            }
            let rule_shifted_pairs = vec![(52usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 36usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(2usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSetItem, 39usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated3, 40usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (40usize, 2usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (54usize, 0usize),
                (55usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 37usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_7.iter() {
                reduce_map.insert(term.clone(), 41usize);
            }
            let rule_shifted_pairs = vec![(41usize, 1usize), (42usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 38usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(42usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_7.iter() {
                reduce_map.insert(term.clone(), 42usize);
            }
            let rule_shifted_pairs = vec![(42usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_7.iter() {
                reduce_map.insert(term.clone(), 54usize);
            }
            let rule_shifted_pairs = vec![(54usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 36usize);
            shift_goto_map_term.insert(Lexed::RBracket(None), 41usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSetItem, 42usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (40usize, 3usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (55usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(8usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 40usize);
            }
            let rule_shifted_pairs = vec![(40usize, 4usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_7.iter() {
                reduce_map.insert(term.clone(), 55usize);
            }
            let rule_shifted_pairs = vec![(55usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(3usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 44usize);
            shift_goto_map_term.insert(Lexed::Question(None), 45usize);
            shift_goto_map_term.insert(Lexed::Star(None), 46usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(5usize);
            for term in _rustylr_generated_terminals_8.iter() {
                reduce_map.insert(term.clone(), 45usize);
            }
            let rule_shifted_pairs = vec![
                (24usize, 1usize),
                (25usize, 1usize),
                (26usize, 1usize),
                (45usize, 3usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(8usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 24usize);
            }
            let rule_shifted_pairs = vec![(24usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(8usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 26usize);
            }
            let rule_shifted_pairs = vec![(26usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(8usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 25usize);
            }
            let rule_shifted_pairs = vec![(25usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(8usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 27usize);
            }
            let rule_shifted_pairs = vec![(27usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(3usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 44usize);
            shift_goto_map_term.insert(Lexed::Question(None), 45usize);
            shift_goto_map_term.insert(Lexed::Star(None), 46usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(5usize);
            for term in _rustylr_generated_terminals_8.iter() {
                reduce_map.insert(term.clone(), 44usize);
            }
            let rule_shifted_pairs = vec![
                (24usize, 1usize),
                (25usize, 1usize),
                (26usize, 1usize),
                (44usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_9.iter() {
                reduce_map.insert(term.clone(), 35usize);
            }
            let rule_shifted_pairs = vec![(35usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 51usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 59usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(32usize, 4usize), (34usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 30usize);
            shift_goto_map_term.insert(Lexed::LBracket(None), 33usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(6usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Pattern, 48usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RuleLine, 52usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSet, 47usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenMapped, 53usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated0, 54usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated1, 57usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(3usize);
            for term in _rustylr_generated_terminals_4.iter() {
                reduce_map.insert(term.clone(), 49usize);
            }
            let rule_shifted_pairs = vec![
                (23usize, 0usize),
                (24usize, 0usize),
                (25usize, 0usize),
                (26usize, 0usize),
                (27usize, 0usize),
                (33usize, 0usize),
                (34usize, 2usize),
                (40usize, 0usize),
                (44usize, 0usize),
                (45usize, 0usize),
                (48usize, 0usize),
                (49usize, 0usize),
                (50usize, 0usize),
                (51usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_9.iter() {
                reduce_map.insert(term.clone(), 34usize);
            }
            let rule_shifted_pairs = vec![(34usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(5usize);
            for term in _rustylr_generated_terminals_8.iter() {
                reduce_map.insert(term.clone(), 50usize);
            }
            let rule_shifted_pairs = vec![(50usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 55usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Action, 56usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_9.iter() {
                reduce_map.insert(term.clone(), 1usize);
            }
            let rule_shifted_pairs = vec![(0usize, 0usize), (1usize, 0usize), (33usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_9.iter() {
                reduce_map.insert(term.clone(), 0usize);
            }
            let rule_shifted_pairs = vec![(0usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_9.iter() {
                reduce_map.insert(term.clone(), 33usize);
            }
            let rule_shifted_pairs = vec![(33usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 30usize);
            shift_goto_map_term.insert(Lexed::LBracket(None), 33usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Pattern, 48usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSet, 47usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenMapped, 58usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(3usize);
            for term in _rustylr_generated_terminals_4.iter() {
                reduce_map.insert(term.clone(), 48usize);
            }
            let rule_shifted_pairs = vec![
                (23usize, 0usize),
                (24usize, 0usize),
                (25usize, 0usize),
                (26usize, 0usize),
                (27usize, 0usize),
                (40usize, 0usize),
                (44usize, 0usize),
                (45usize, 0usize),
                (48usize, 1usize),
                (51usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(5usize);
            for term in _rustylr_generated_terminals_8.iter() {
                reduce_map.insert(term.clone(), 51usize);
            }
            let rule_shifted_pairs = vec![(51usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 32usize);
            }
            let rule_shifted_pairs = vec![(32usize, 5usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_10.iter() {
                reduce_map.insert(term.clone(), 30usize);
            }
            let rule_shifted_pairs = vec![(30usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(16usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 7usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 8usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 9usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 10usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 11usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 12usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 13usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 14usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 15usize);
            shift_goto_map_term.insert(Lexed::Question(None), 16usize);
            shift_goto_map_term.insert(Lexed::Star(None), 17usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 62usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated4, 20usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 22usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (22usize, 1usize),
                (38usize, 0usize),
                (56usize, 0usize),
                (57usize, 0usize),
                (58usize, 0usize),
                (59usize, 0usize),
                (60usize, 0usize),
                (61usize, 0usize),
                (62usize, 0usize),
                (63usize, 0usize),
                (64usize, 0usize),
                (65usize, 0usize),
                (66usize, 0usize),
                (67usize, 0usize),
                (68usize, 0usize),
                (69usize, 0usize),
                (70usize, 0usize),
                (71usize, 0usize),
                (72usize, 0usize),
                (73usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 63usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(22usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 22usize);
            }
            let rule_shifted_pairs = vec![(22usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_10.iter() {
                reduce_map.insert(term.clone(), 31usize);
            }
            let rule_shifted_pairs = vec![(31usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 66usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(39usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 67usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(39usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 39usize);
            }
            let rule_shifted_pairs = vec![(39usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 69usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(43usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(16usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 7usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 8usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 9usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 10usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 11usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 12usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 13usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 14usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 15usize);
            shift_goto_map_term.insert(Lexed::Question(None), 16usize);
            shift_goto_map_term.insert(Lexed::Star(None), 17usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 70usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated4, 20usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 22usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (38usize, 0usize),
                (43usize, 2usize),
                (56usize, 0usize),
                (57usize, 0usize),
                (58usize, 0usize),
                (59usize, 0usize),
                (60usize, 0usize),
                (61usize, 0usize),
                (62usize, 0usize),
                (63usize, 0usize),
                (64usize, 0usize),
                (65usize, 0usize),
                (66usize, 0usize),
                (67usize, 0usize),
                (68usize, 0usize),
                (69usize, 0usize),
                (70usize, 0usize),
                (71usize, 0usize),
                (72usize, 0usize),
                (73usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 71usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(43usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 43usize);
            }
            let rule_shifted_pairs = vec![(43usize, 4usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(16usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 7usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 8usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 9usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 10usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 11usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 12usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 13usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 14usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 15usize);
            shift_goto_map_term.insert(Lexed::Question(None), 16usize);
            shift_goto_map_term.insert(Lexed::Star(None), 17usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 73usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated4, 20usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 22usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (38usize, 0usize),
                (46usize, 1usize),
                (56usize, 0usize),
                (57usize, 0usize),
                (58usize, 0usize),
                (59usize, 0usize),
                (60usize, 0usize),
                (61usize, 0usize),
                (62usize, 0usize),
                (63usize, 0usize),
                (64usize, 0usize),
                (65usize, 0usize),
                (66usize, 0usize),
                (67usize, 0usize),
                (68usize, 0usize),
                (69usize, 0usize),
                (70usize, 0usize),
                (71usize, 0usize),
                (72usize, 0usize),
                (73usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 74usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(46usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 46usize);
            }
            let rule_shifted_pairs = vec![(46usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(16usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 7usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 8usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 9usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 10usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 11usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 12usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 13usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 14usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 15usize);
            shift_goto_map_term.insert(Lexed::Question(None), 16usize);
            shift_goto_map_term.insert(Lexed::Star(None), 17usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 76usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated4, 20usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 22usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (38usize, 0usize),
                (47usize, 1usize),
                (56usize, 0usize),
                (57usize, 0usize),
                (58usize, 0usize),
                (59usize, 0usize),
                (60usize, 0usize),
                (61usize, 0usize),
                (62usize, 0usize),
                (63usize, 0usize),
                (64usize, 0usize),
                (65usize, 0usize),
                (66usize, 0usize),
                (67usize, 0usize),
                (68usize, 0usize),
                (69usize, 0usize),
                (70usize, 0usize),
                (71usize, 0usize),
                (72usize, 0usize),
                (73usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 77usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(47usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 47usize);
            }
            let rule_shifted_pairs = vec![(47usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 11usize);
            }
            let rule_shifted_pairs = vec![(11usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 19usize);
            }
            let rule_shifted_pairs = vec![(19usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(11usize);
            shift_goto_map_term.insert(Lexed::Eof, 81usize);
            shift_goto_map_term.insert(Lexed::EofDef(None), 1usize);
            shift_goto_map_term.insert(Lexed::ErrorType(None), 23usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 26usize);
            shift_goto_map_term.insert(Lexed::Left(None), 60usize);
            shift_goto_map_term.insert(Lexed::ModulePrefix(None), 61usize);
            shift_goto_map_term.insert(Lexed::Right(None), 64usize);
            shift_goto_map_term.insert(Lexed::Start(None), 65usize);
            shift_goto_map_term.insert(Lexed::Token(None), 68usize);
            shift_goto_map_term.insert(Lexed::TokenType(None), 72usize);
            shift_goto_map_term.insert(Lexed::UserData(None), 75usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(10usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::EofDef, 82usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ErrorDef, 83usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ModulePrefixDef, 84usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ReduceDef, 85usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ReduceType, 86usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Rule, 95usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::StartDef, 96usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenDef, 97usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenTypeDef, 98usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::UserDataDef, 99usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (2usize, 0usize),
                (3usize, 0usize),
                (4usize, 1usize),
                (6usize, 1usize),
                (8usize, 1usize),
                (10usize, 1usize),
                (12usize, 1usize),
                (14usize, 1usize),
                (16usize, 1usize),
                (18usize, 1usize),
                (20usize, 1usize),
                (22usize, 0usize),
                (28usize, 0usize),
                (29usize, 0usize),
                (30usize, 0usize),
                (31usize, 0usize),
                (32usize, 0usize),
                (39usize, 0usize),
                (43usize, 0usize),
                (46usize, 0usize),
                (47usize, 0usize),
                (74usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(74usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 10usize);
            }
            let rule_shifted_pairs = vec![(10usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 18usize);
            }
            let rule_shifted_pairs = vec![(18usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 20usize);
            }
            let rule_shifted_pairs = vec![(20usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 16usize);
            }
            let rule_shifted_pairs = vec![(16usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 87usize);
            shift_goto_map_term.insert(Lexed::LBracket(None), 89usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSet, 93usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(28usize, 1usize), (29usize, 1usize), (40usize, 0usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 88usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(28usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 28usize);
            }
            let rule_shifted_pairs = vec![(28usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 34usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated2, 90usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_6.iter() {
                reduce_map.insert(term.clone(), 53usize);
            }
            let rule_shifted_pairs = vec![(40usize, 1usize), (52usize, 0usize), (53usize, 0usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 36usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(2usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSetItem, 39usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated3, 91usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (40usize, 2usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (54usize, 0usize),
                (55usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 36usize);
            shift_goto_map_term.insert(Lexed::RBracket(None), 92usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSetItem, 42usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (40usize, 3usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (55usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_2.iter() {
                reduce_map.insert(term.clone(), 40usize);
            }
            let rule_shifted_pairs = vec![(40usize, 4usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 94usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(29usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 29usize);
            }
            let rule_shifted_pairs = vec![(29usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 4usize);
            }
            let rule_shifted_pairs = vec![(4usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 8usize);
            }
            let rule_shifted_pairs = vec![(8usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 6usize);
            }
            let rule_shifted_pairs = vec![(6usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 12usize);
            }
            let rule_shifted_pairs = vec![(12usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 14usize);
            }
            let rule_shifted_pairs = vec![(14usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 21usize);
            }
            let rule_shifted_pairs = vec![(21usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 17usize);
            }
            let rule_shifted_pairs = vec![(17usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 5usize);
            }
            let rule_shifted_pairs = vec![(5usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 9usize);
            }
            let rule_shifted_pairs = vec![(9usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 7usize);
            }
            let rule_shifted_pairs = vec![(7usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 13usize);
            }
            let rule_shifted_pairs = vec![(13usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 15usize);
            }
            let rule_shifted_pairs = vec![(15usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = ::rusty_lr_core::State {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        Self { rules, states }
    }
    #[doc = r" give lookahead token to parser, and check if there is any reduce action"]
    fn lookahead<'a, C: ::rusty_lr_core::Callback<Lexed, GrammarNonTerminals>>(
        &'a self,
        context: &mut GrammarContext,
        callback: &mut C,
        term: &Lexed,
    ) -> Result<(), ::rusty_lr_core::ParseError<'a, Lexed, GrammarNonTerminals, C::Error, ParseError>>
    {
        let state = &self.states[*context
            .state_stack
            .last()
            .expect("Something wrong! state_stack is empty")];
        if let Some(reduce_rule) = state.reduce(term) {
            let rule = &self.rules[reduce_rule];
            if context.state_stack.len() < rule.rule.len() {
                panic!(
                    "State stack not enough for reduce: {:?}",
                    context.state_stack
                );
            }
            context
                .state_stack
                .truncate(context.state_stack.len() - rule.rule.len());
            context
                .reduce(self.rules[reduce_rule].rule.len(), reduce_rule)
                .map_err(::rusty_lr_core::ParseError::ReduceAction)?;
            callback
                .reduce(&self.rules, &self.states, &context.state_stack, reduce_rule)
                .map_err(::rusty_lr_core::ParseError::Callback)?;
            self.feed_nonterm(context, callback, &rule.name)?;
            self.lookahead(context, callback, term)?;
        }
        Ok(())
    }
    #[doc = r" feed one terminal to parser, and update state stack"]
    pub fn feed<'a>(
        &'a self,
        context: &mut GrammarContext,
        term: Lexed,
    ) -> Result<(), ::rusty_lr_core::ParseError<'a, Lexed, GrammarNonTerminals, u8, ParseError>>
    {
        self.feed_callback(context, &mut ::rusty_lr_core::DefaultCallback {}, term)
    }
    #[doc = r" feed one terminal to parser, and update state stack"]
    pub fn feed_callback<'a, C: ::rusty_lr_core::Callback<Lexed, GrammarNonTerminals>>(
        &'a self,
        context: &mut GrammarContext,
        callback: &mut C,
        term: Lexed,
    ) -> Result<(), ::rusty_lr_core::ParseError<'a, Lexed, GrammarNonTerminals, C::Error, ParseError>>
    {
        self.lookahead(context, callback, &term)?;
        let state = &self.states[*context
            .state_stack
            .last()
            .expect("Something wrong! state_stack is empty")];
        if let Some(next_state_id) = state.shift_goto_term(&term) {
            context.state_stack.push(next_state_id);
            callback
                .shift_and_goto(&self.rules, &self.states, &context.state_stack, &term)
                .map_err(::rusty_lr_core::ParseError::Callback)?;
            context.push(term);
            Ok(())
        } else {
            Err(::rusty_lr_core::ParseError::InvalidTerminal(
                term,
                &self.rules,
                &self.states,
                context.state_stack.clone(),
            ))
        }
    }
    #[doc = r" feed one non-terminal to parser, and update state stack"]
    fn feed_nonterm<'a, C: ::rusty_lr_core::Callback<Lexed, GrammarNonTerminals>>(
        &'a self,
        context: &mut GrammarContext,
        callback: &mut C,
        nonterm: &'a GrammarNonTerminals,
    ) -> Result<(), ::rusty_lr_core::ParseError<'a, Lexed, GrammarNonTerminals, C::Error, ParseError>>
    {
        let state = &self.states[*context
            .state_stack
            .last()
            .expect("Something wrong! state_stack is empty")];
        if let Some(next_state_id) = state.shift_goto_nonterm(nonterm) {
            context.state_stack.push(next_state_id);
            callback
                .shift_and_goto_nonterm(&self.rules, &self.states, &context.state_stack, nonterm)
                .map_err(::rusty_lr_core::ParseError::Callback)?;
            Ok(())
        } else {
            Err(::rusty_lr_core::ParseError::InvalidNonTerminal(
                nonterm,
                &self.rules,
                &self.states,
                context.state_stack.clone(),
            ))
        }
    }
    pub fn begin(&self) -> GrammarContext {
        GrammarContext::new()
    }
}
// ==============================Generated Codes End===============================
