
// This file was generated by rustylr 1.25.0
// This generated code is targeting rusty_lr version 3.32.0.
// There might be a build error if the version is not matched.
//
// ================================User Codes Begin================================
use crate::parser::args::PatternArgs;
use crate::parser::args::GrammarArgs;
use crate::parser::args::RuleDefArgs;
use crate::parser::args::RuleLineArgs;
use crate::parser::args::IdentOrLiteral;
use crate::parser::args::PrecDPrecArgs;
use crate::parser::args::RecoveredError;
use crate::parser::lexer::Lexed;
use crate::parser::span_pair::SpanPair;
use crate::terminalset::TerminalSet;
use crate::terminalset::TerminalSetItem;
use proc_macro2::Group;
use proc_macro2::Ident;
use proc_macro2::Span;
use proc_macro2::TokenStream;
use quote::ToTokens;
use quote::format_ident;
use std::boxed::Box;
use rusty_lr_core::rule::ReduceType;

// =================================User Codes End=================================
/*
====================================Grammar=====================================

# of terminal classes: 42
# of states: 177

0: Rule -> ident RuleType colon RuleLines semicolon
1: RuleType -> parengroup
2: RuleType -> 
3: RuleLines -> RuleLines pipe RuleLine
4: RuleLines -> RuleLine
5: RuleLine -> TokenMapped* PrecDef* Action
6: PrecDef -> percent prec IdentOrLiteral
7: PrecDef -> percent prec error
8: PrecDef -> percent dprec literal
9: PrecDef -> percent dprec error
10: PrecDef -> percent error
11: TokenMapped -> Pattern
12: TokenMapped -> ident equal Pattern
13: TerminalSetItem -> ident
14: TerminalSetItem -> ident minus ident
15: TerminalSetItem -> ident minus error
16: TerminalSetItem -> literal
17: TerminalSetItem -> literal minus literal
18: TerminalSetItem -> literal minus error
19: TerminalSet -> lbracket caret? TerminalSetItem* rbracket
20: TerminalSet -> dot
21: Pattern -> ident
22: Pattern -> Pattern plus
23: Pattern -> Pattern star
24: Pattern -> Pattern question
25: Pattern -> Pattern exclamation
26: Pattern -> TerminalSet
27: Pattern -> Pattern slash Pattern
28: Pattern -> lparen $sep(Pattern*, pipe, +) rparen
29: Pattern -> lparen error rparen
30: Pattern -> literal
31: Pattern -> Pattern minus Pattern
32: Pattern -> dollar ident lparen Pattern comma Pattern comma? rparen
33: Pattern -> dollar ident lparen Pattern comma Pattern comma plus rparen
34: Pattern -> dollar ident lparen Pattern comma Pattern comma star rparen
35: Pattern -> dollar ident lparen Pattern comma Pattern error rparen
36: Pattern -> dollar ident lparen Pattern comma Pattern comma error rparen
37: Action -> bracegroup
38: Action -> 
39: IdentOrLiteral -> ident
40: IdentOrLiteral -> literal
41: Directive -> percent token ident [^semicolon]+ semicolon
42: Directive -> percent token ident semicolon
43: Directive -> percent token error semicolon
44: Directive -> percent start ident semicolon
45: Directive -> percent start error semicolon
46: Directive -> percent tokentype [^semicolon]+ semicolon
47: Directive -> percent tokentype semicolon
48: Directive -> percent userdata [^semicolon]+ semicolon
49: Directive -> percent userdata semicolon
50: Directive -> percent left IdentOrLiteral+ semicolon
51: Directive -> percent left error semicolon
52: Directive -> percent right IdentOrLiteral+ semicolon
53: Directive -> percent right error semicolon
54: Directive -> percent precedence IdentOrLiteral+ semicolon
55: Directive -> percent precedence error semicolon
56: Directive -> percent errortype [^semicolon]+ semicolon
57: Directive -> percent errortype semicolon
58: Directive -> percent moduleprefix [^semicolon]+ semicolon
59: Directive -> percent moduleprefix semicolon
60: Directive -> percent glr semicolon
61: Directive -> percent glr error semicolon
62: Directive -> percent lalr semicolon
63: Directive -> percent lalr error semicolon
64: Directive -> percent nooptim semicolon
65: Directive -> percent nooptim error semicolon
66: Directive -> percent dense semicolon
67: Directive -> percent dense error semicolon
68: Directive -> percent trace ident* semicolon
69: Directive -> percent trace error semicolon
70: Directive -> percent filter [^semicolon]+ semicolon
71: Directive -> percent filter semicolon
72: Directive -> percent location [^semicolon]+ semicolon
73: Directive -> percent location semicolon
74: Directive -> percent error semicolon
75: GrammarLine -> Rule
76: GrammarLine -> Directive
77: Grammar -> GrammarLine+
78: TokenMapped+ -> TokenMapped
79: TokenMapped+ -> TokenMapped+ TokenMapped
80: TokenMapped* -> TokenMapped+
81: TokenMapped* -> 
82: PrecDef+ -> PrecDef
83: PrecDef+ -> PrecDef+ PrecDef
84: PrecDef* -> PrecDef+
85: PrecDef* -> 
86: caret? -> caret
87: caret? -> 
88: TerminalSetItem+ -> TerminalSetItem
89: TerminalSetItem+ -> TerminalSetItem+ TerminalSetItem
90: TerminalSetItem* -> TerminalSetItem+
91: TerminalSetItem* -> 
92: Pattern+ -> Pattern
93: Pattern+ -> Pattern+ Pattern
94: Pattern* -> Pattern+
95: Pattern* -> 
96: $sep(Pattern*, pipe, +) -> Pattern*
97: $sep(Pattern*, pipe, +) -> $sep(Pattern*, pipe, +) pipe Pattern*
98: comma? -> comma
99: comma? -> 
100: [^semicolon] -> ident
101: [^semicolon] -> colon
102: [^semicolon] -> pipe
103: [^semicolon] -> percent
104: [^semicolon] -> equal
105: [^semicolon] -> plus
106: [^semicolon] -> star
107: [^semicolon] -> question
108: [^semicolon] -> caret
109: [^semicolon] -> minus
110: [^semicolon] -> exclamation
111: [^semicolon] -> slash
112: [^semicolon] -> dot
113: [^semicolon] -> dollar
114: [^semicolon] -> comma
115: [^semicolon] -> literal
116: [^semicolon] -> parengroup
117: [^semicolon] -> bracegroup
118: [^semicolon] -> lparen
119: [^semicolon] -> rparen
120: [^semicolon] -> lbracket
121: [^semicolon] -> rbracket
122: [^semicolon] -> left
123: [^semicolon] -> right
124: [^semicolon] -> token
125: [^semicolon] -> start
126: [^semicolon] -> tokentype
127: [^semicolon] -> userdata
128: [^semicolon] -> errortype
129: [^semicolon] -> moduleprefix
130: [^semicolon] -> lalr
131: [^semicolon] -> glr
132: [^semicolon] -> prec
133: [^semicolon] -> precedence
134: [^semicolon] -> nooptim
135: [^semicolon] -> dense
136: [^semicolon] -> trace
137: [^semicolon] -> dprec
138: [^semicolon] -> filter
139: [^semicolon] -> location
140: [^semicolon] -> <Others>
141: [^semicolon]+ -> [^semicolon]
142: [^semicolon]+ -> [^semicolon]+ [^semicolon]
143: IdentOrLiteral+ -> IdentOrLiteral
144: IdentOrLiteral+ -> IdentOrLiteral+ IdentOrLiteral
145: ident+ -> ident
146: ident+ -> ident+ ident
147: ident* -> ident+
148: ident* -> 
149: GrammarLine+ -> GrammarLine
150: GrammarLine+ -> GrammarLine GrammarLine+
151: Augmented -> Grammar eof

*/
// =============================Generated Codes Begin==============================
/// type alias for `Context`
#[allow(non_camel_case_types, dead_code)]
pub type GrammarContext = ::rusty_lr_core::parser::deterministic::Context<
    GrammarDataStack,
    u8,
>;
/// type alias for CFG production rule
#[allow(non_camel_case_types, dead_code)]
pub type GrammarRule = ::rusty_lr_core::rule::ProductionRule<
    &'static str,
    GrammarNonTerminals,
>;
/// type alias for DFA state
#[allow(non_camel_case_types, dead_code)]
pub type GrammarState = ::rusty_lr_core::parser::state::SparseState<
    u8,
    GrammarNonTerminals,
    usize,
    u8,
>;
/// type alias for `ParseError`
#[allow(non_camel_case_types, dead_code)]
pub type GrammarParseError = ::rusty_lr_core::parser::deterministic::ParseError<
    GrammarDataStack,
>;
/// An enum that represents non-terminal symbols
#[allow(non_camel_case_types, dead_code)]
#[derive(
    Clone,
    Copy,
    std::hash::Hash,
    std::cmp::PartialEq,
    std::cmp::Eq,
    std::cmp::PartialOrd,
    std::cmp::Ord
)]
pub enum GrammarNonTerminals {
    Rule,
    RuleType,
    RuleLines,
    RuleLine,
    PrecDef,
    TokenMapped,
    TerminalSetItem,
    TerminalSet,
    Pattern,
    Action,
    IdentOrLiteral,
    Directive,
    GrammarLine,
    Grammar,
    _TokenMappedPlus15,
    _TokenMappedStar16,
    _PrecDefPlus17,
    _PrecDefStar18,
    _caretQuestion19,
    _TerminalSetItemPlus20,
    _TerminalSetItemStar21,
    _PatternPlus22,
    _PatternStar23,
    __PatternStar23SepPlus24,
    _commaQuestion25,
    _TermSet26,
    __TermSet26Plus27,
    _IdentOrLiteralPlus28,
    _identPlus29,
    _identStar30,
    _GrammarLinePlus31,
    Augmented,
}
impl std::fmt::Display for GrammarNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr_core::nonterminal::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl std::fmt::Debug for GrammarNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr_core::nonterminal::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl ::rusty_lr_core::nonterminal::NonTerminal for GrammarNonTerminals {
    fn as_str(&self) -> &'static str {
        match self {
            GrammarNonTerminals::Rule => "Rule",
            GrammarNonTerminals::RuleType => "RuleType",
            GrammarNonTerminals::RuleLines => "RuleLines",
            GrammarNonTerminals::RuleLine => "RuleLine",
            GrammarNonTerminals::PrecDef => "PrecDef",
            GrammarNonTerminals::TokenMapped => "TokenMapped",
            GrammarNonTerminals::TerminalSetItem => "TerminalSetItem",
            GrammarNonTerminals::TerminalSet => "TerminalSet",
            GrammarNonTerminals::Pattern => "Pattern",
            GrammarNonTerminals::Action => "Action",
            GrammarNonTerminals::IdentOrLiteral => "IdentOrLiteral",
            GrammarNonTerminals::Directive => "Directive",
            GrammarNonTerminals::GrammarLine => "GrammarLine",
            GrammarNonTerminals::Grammar => "Grammar",
            GrammarNonTerminals::_TokenMappedPlus15 => "TokenMapped+",
            GrammarNonTerminals::_TokenMappedStar16 => "TokenMapped*",
            GrammarNonTerminals::_PrecDefPlus17 => "PrecDef+",
            GrammarNonTerminals::_PrecDefStar18 => "PrecDef*",
            GrammarNonTerminals::_caretQuestion19 => "caret?",
            GrammarNonTerminals::_TerminalSetItemPlus20 => "TerminalSetItem+",
            GrammarNonTerminals::_TerminalSetItemStar21 => "TerminalSetItem*",
            GrammarNonTerminals::_PatternPlus22 => "Pattern+",
            GrammarNonTerminals::_PatternStar23 => "Pattern*",
            GrammarNonTerminals::__PatternStar23SepPlus24 => "$sep(Pattern*, pipe, +)",
            GrammarNonTerminals::_commaQuestion25 => "comma?",
            GrammarNonTerminals::_TermSet26 => "[^semicolon]",
            GrammarNonTerminals::__TermSet26Plus27 => "[^semicolon]+",
            GrammarNonTerminals::_IdentOrLiteralPlus28 => "IdentOrLiteral+",
            GrammarNonTerminals::_identPlus29 => "ident+",
            GrammarNonTerminals::_identStar30 => "ident*",
            GrammarNonTerminals::_GrammarLinePlus31 => "GrammarLine+",
            GrammarNonTerminals::Augmented => "Augmented",
        }
    }
    fn is_trace(&self) -> bool {
        match self {
            GrammarNonTerminals::Rule => false,
            GrammarNonTerminals::RuleType => false,
            GrammarNonTerminals::RuleLines => false,
            GrammarNonTerminals::RuleLine => false,
            GrammarNonTerminals::PrecDef => false,
            GrammarNonTerminals::TokenMapped => false,
            GrammarNonTerminals::TerminalSetItem => false,
            GrammarNonTerminals::TerminalSet => false,
            GrammarNonTerminals::Pattern => false,
            GrammarNonTerminals::Action => false,
            GrammarNonTerminals::IdentOrLiteral => false,
            GrammarNonTerminals::Directive => false,
            GrammarNonTerminals::GrammarLine => false,
            GrammarNonTerminals::Grammar => false,
            GrammarNonTerminals::_TokenMappedPlus15 => false,
            GrammarNonTerminals::_TokenMappedStar16 => false,
            GrammarNonTerminals::_PrecDefPlus17 => false,
            GrammarNonTerminals::_PrecDefStar18 => false,
            GrammarNonTerminals::_caretQuestion19 => false,
            GrammarNonTerminals::_TerminalSetItemPlus20 => false,
            GrammarNonTerminals::_TerminalSetItemStar21 => false,
            GrammarNonTerminals::_PatternPlus22 => false,
            GrammarNonTerminals::_PatternStar23 => false,
            GrammarNonTerminals::__PatternStar23SepPlus24 => false,
            GrammarNonTerminals::_commaQuestion25 => false,
            GrammarNonTerminals::_TermSet26 => false,
            GrammarNonTerminals::__TermSet26Plus27 => false,
            GrammarNonTerminals::_IdentOrLiteralPlus28 => false,
            GrammarNonTerminals::_identPlus29 => false,
            GrammarNonTerminals::_identStar30 => false,
            GrammarNonTerminals::_GrammarLinePlus31 => false,
            GrammarNonTerminals::Augmented => false,
        }
    }
    fn nonterm_type(&self) -> Option<::rusty_lr_core::nonterminal::NonTerminalType> {
        match self {
            GrammarNonTerminals::Rule => None,
            GrammarNonTerminals::RuleType => None,
            GrammarNonTerminals::RuleLines => None,
            GrammarNonTerminals::RuleLine => None,
            GrammarNonTerminals::PrecDef => None,
            GrammarNonTerminals::TokenMapped => None,
            GrammarNonTerminals::TerminalSetItem => None,
            GrammarNonTerminals::TerminalSet => None,
            GrammarNonTerminals::Pattern => None,
            GrammarNonTerminals::Action => None,
            GrammarNonTerminals::IdentOrLiteral => None,
            GrammarNonTerminals::Directive => None,
            GrammarNonTerminals::GrammarLine => None,
            GrammarNonTerminals::Grammar => None,
            GrammarNonTerminals::_TokenMappedPlus15 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::PlusLeft)
            }
            GrammarNonTerminals::_TokenMappedStar16 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::Star)
            }
            GrammarNonTerminals::_PrecDefPlus17 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::PlusLeft)
            }
            GrammarNonTerminals::_PrecDefStar18 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::Star)
            }
            GrammarNonTerminals::_caretQuestion19 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::Optional)
            }
            GrammarNonTerminals::_TerminalSetItemPlus20 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::PlusLeft)
            }
            GrammarNonTerminals::_TerminalSetItemStar21 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::Star)
            }
            GrammarNonTerminals::_PatternPlus22 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::PlusLeft)
            }
            GrammarNonTerminals::_PatternStar23 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::Star)
            }
            GrammarNonTerminals::__PatternStar23SepPlus24 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::PlusLeft)
            }
            GrammarNonTerminals::_commaQuestion25 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::Optional)
            }
            GrammarNonTerminals::_TermSet26 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::TerminalSet)
            }
            GrammarNonTerminals::__TermSet26Plus27 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::PlusLeft)
            }
            GrammarNonTerminals::_IdentOrLiteralPlus28 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::PlusLeft)
            }
            GrammarNonTerminals::_identPlus29 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::PlusLeft)
            }
            GrammarNonTerminals::_identStar30 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::Star)
            }
            GrammarNonTerminals::_GrammarLinePlus31 => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::PlusRight)
            }
            GrammarNonTerminals::Augmented => {
                Some(::rusty_lr_core::nonterminal::NonTerminalType::Augmented)
            }
        }
    }
    fn to_usize(&self) -> usize {
        *self as usize
    }
}
/// tag for token that represents which stack a token is using
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum GrammarTags {
    __terminals,
    __stack2,
    __stack3,
    __stack4,
    __stack5,
    __stack6,
    __stack7,
    __stack8,
    __stack9,
    __stack10,
    __stack11,
    __stack12,
    __stack13,
    __stack14,
    __stack15,
    __stack16,
    __stack17,
    __stack18,
    __stack19,
    Empty,
}
/// enum for each non-terminal and terminal symbol, that actually hold data
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
pub struct GrammarDataStack {
    pub __tags: Vec<GrammarTags>,
    __terminals: Vec<Lexed>,
    __stack2: Vec<RuleDefArgs>,
    __stack3: Vec<Option<Group>>,
    __stack4: Vec<Vec<RuleLineArgs>>,
    __stack5: Vec<RuleLineArgs>,
    __stack6: Vec<PrecDPrecArgs>,
    __stack7: Vec<(Option<Ident>, PatternArgs)>,
    __stack8: Vec<TerminalSetItem>,
    __stack9: Vec<TerminalSet>,
    __stack10: Vec<PatternArgs>,
    __stack11: Vec<IdentOrLiteral>,
    __stack12: Vec<Vec<(Option<Ident>, PatternArgs)>>,
    __stack13: Vec<Vec<PrecDPrecArgs>>,
    __stack14: Vec<Option<Lexed>>,
    __stack15: Vec<Vec<TerminalSetItem>>,
    __stack16: Vec<Vec<PatternArgs>>,
    __stack17: Vec<Vec<Vec<PatternArgs>>>,
    __stack18: Vec<Vec<Lexed>>,
    __stack19: Vec<Vec<IdentOrLiteral>>,
}
impl Default for GrammarDataStack {
    fn default() -> Self {
        Self {
            __tags: Vec::new(),
            __terminals: Vec::new(),
            __stack2: Vec::new(),
            __stack3: Vec::new(),
            __stack4: Vec::new(),
            __stack5: Vec::new(),
            __stack6: Vec::new(),
            __stack7: Vec::new(),
            __stack8: Vec::new(),
            __stack9: Vec::new(),
            __stack10: Vec::new(),
            __stack11: Vec::new(),
            __stack12: Vec::new(),
            __stack13: Vec::new(),
            __stack14: Vec::new(),
            __stack15: Vec::new(),
            __stack16: Vec::new(),
            __stack17: Vec::new(),
            __stack18: Vec::new(),
            __stack19: Vec::new(),
        }
    }
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut,
    dead_code
)]
impl GrammarDataStack {
    fn custom_reduce_action_0(
        mut t: Vec<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<TokenStream, ::rusty_lr_core::DefaultReduceActionError> {
        Ok({
            let mut tokens = TokenStream::new();
            for token in t.into_iter() {
                token.append_to_stream(&mut tokens);
            }
            tokens
        })
    }
    ///Rule -> ident RuleType colon RuleLines semicolon
    #[inline]
    fn reduce_Rule_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
        __data_stack.__tags.push(GrammarTags::__stack2);
        let mut RuleType = __data_stack.__stack3.pop().unwrap();
        let mut RuleLines = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let mut __rustylr_location_colon = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            let Lexed::Ident(ident) = ident else {
                unreachable!("Rule-Ident");
            };
            let span = __rustylr_location_colon.span();
            if let Some(fisrt) = RuleLines.first_mut() {
                fisrt.separator_span = span;
            }
            RuleDefArgs {
                name: ident,
                typename: RuleType.map(|t| t.stream()),
                rule_lines: RuleLines,
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///RuleType -> parengroup
    #[inline]
    fn reduce_RuleType_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack3);
        let mut parengroup = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::ParenGroup(group) = parengroup else {
                unreachable!("RuleType - Group");
            };
            Some(group)
        };
        __data_stack.__stack3.push(__res);
        Ok(true)
    }
    ///RuleType ->
    #[inline]
    fn reduce_RuleType_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(GrammarTags::__stack3);
        let __res = { None };
        __data_stack.__stack3.push(__res);
        Ok(true)
    }
    ///RuleLines -> RuleLines pipe RuleLine
    #[inline]
    fn reduce_RuleLines_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack5)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__stack4)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut RuleLines = __data_stack.__stack4.pop().unwrap();
        let mut RuleLine = __data_stack.__stack5.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_pipe = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            RuleLine.separator_span = __rustylr_location_pipe.span();
            RuleLines.push(RuleLine);
            RuleLines
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///RuleLines -> RuleLine
    #[inline]
    fn reduce_RuleLines_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack5)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack4);
        let mut RuleLine = __data_stack.__stack5.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![RuleLine] };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///RuleLine -> TokenMapped* PrecDef* Action
    #[inline]
    fn reduce_RuleLine_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack13)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__stack12)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack5);
        let mut TokenMapped = __data_stack.__stack12.pop().unwrap();
        let mut PrecDef = __data_stack.__stack13.pop().unwrap();
        let mut Action = __data_stack.__stack3.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            RuleLineArgs {
                tokens: TokenMapped,
                reduce_action: Action.map(|action| action.to_token_stream()),
                separator_span: Span::call_site(),
                precs: PrecDef,
                prec: None,
                dprec: None,
            }
        };
        __data_stack.__stack5.push(__res);
        Ok(true)
    }
    ///PrecDef -> percent prec IdentOrLiteral
    #[inline]
    fn reduce_PrecDef_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack11)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack6);
        let mut IdentOrLiteral = __data_stack.__stack11.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { PrecDPrecArgs::Prec(IdentOrLiteral) };
        __data_stack.__stack6.push(__res);
        Ok(true)
    }
    ///PrecDef -> percent prec error
    #[inline]
    fn reduce_PrecDef_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack6);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected <ident> to token or <literal>".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#operator-precedence"
                        .to_string(),
                    span: __rustylr_location_error,
                });
            PrecDPrecArgs::None
        };
        __data_stack.__stack6.push(__res);
        Ok(true)
    }
    ///PrecDef -> percent dprec literal
    #[inline]
    fn reduce_PrecDef_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack6);
        let mut literal = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let Lexed::Literal(literal) = literal else {
                unreachable!("PrecDPrecArgs-DPrec");
            };
            PrecDPrecArgs::DPrec(literal)
        };
        __data_stack.__stack6.push(__res);
        Ok(true)
    }
    ///PrecDef -> percent dprec error
    #[inline]
    fn reduce_PrecDef_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack6);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected integer literal".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#rule-priority"
                        .to_string(),
                    span: __rustylr_location_error,
                });
            PrecDPrecArgs::None
        };
        __data_stack.__stack6.push(__res);
        Ok(true)
    }
    ///PrecDef -> percent error
    #[inline]
    fn reduce_PrecDef_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(GrammarTags::__stack6);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected %prec or %dprec".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#operator-precedence"
                        .to_string(),
                    span: __rustylr_location_error,
                });
            PrecDPrecArgs::None
        };
        __data_stack.__stack6.push(__res);
        Ok(true)
    }
    ///TokenMapped -> Pattern
    #[inline]
    fn reduce_TokenMapped_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack7);
        let mut Pattern = __data_stack.__stack10.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { (None, Pattern) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///TokenMapped -> ident equal Pattern
    #[inline]
    fn reduce_TokenMapped_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack7);
        let mut Pattern = __data_stack.__stack10.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let Lexed::Ident(ident) = ident else {
                unreachable!("Token-Ident");
            };
            (Some(ident), Pattern)
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///TerminalSetItem -> ident
    #[inline]
    fn reduce_TerminalSetItem_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack8);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Ident(ident) = ident else {
                unreachable!("TerminalSetItem-Range1");
            };
            TerminalSetItem::Terminal(ident)
        };
        __data_stack.__stack8.push(__res);
        Ok(true)
    }
    ///TerminalSetItem -> ident minus ident
    #[inline]
    fn reduce_TerminalSetItem_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack8);
        let mut last = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut first = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let Lexed::Ident(first) = first else {
                unreachable!("TerminalSetItem-Range1");
            };
            let Lexed::Ident(last) = last else {
                unreachable!("TerminalSetItem-Range3");
            };
            TerminalSetItem::Range(first, last)
        };
        __data_stack.__stack8.push(__res);
        Ok(true)
    }
    ///TerminalSetItem -> ident minus error
    #[inline]
    fn reduce_TerminalSetItem_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack8);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected ident for terminal set".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#patterns"
                        .to_string(),
                    span: __rustylr_location_error,
                });
            TerminalSetItem::Terminal(format_ident!("dummy"))
        };
        __data_stack.__stack8.push(__res);
        Ok(true)
    }
    ///TerminalSetItem -> literal
    #[inline]
    fn reduce_TerminalSetItem_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack8);
        let mut literal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Literal(literal) = literal else {
                unreachable!("TerminalSetItem-Literal");
            };
            TerminalSetItem::Literal(literal)
        };
        __data_stack.__stack8.push(__res);
        Ok(true)
    }
    ///TerminalSetItem -> literal minus literal
    #[inline]
    fn reduce_TerminalSetItem_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack8);
        let mut last = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut first = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let Lexed::Literal(first) = first else {
                unreachable!("TerminalSetItem-Range1");
            };
            let Lexed::Literal(last) = last else {
                unreachable!("TerminalSetItem-Range3");
            };
            TerminalSetItem::LiteralRange(first, last)
        };
        __data_stack.__stack8.push(__res);
        Ok(true)
    }
    ///TerminalSetItem -> literal minus error
    #[inline]
    fn reduce_TerminalSetItem_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack8);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected literal for terminal set".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#patterns"
                        .to_string(),
                    span: __rustylr_location_error,
                });
            TerminalSetItem::Terminal(format_ident!("dummy"))
        };
        __data_stack.__stack8.push(__res);
        Ok(true)
    }
    ///TerminalSet -> lbracket caret? TerminalSetItem* rbracket
    #[inline]
    fn reduce_TerminalSet_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack15)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__stack14)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::__stack9);
        let mut caret = __data_stack.__stack14.pop().unwrap();
        let mut TerminalSetItem = __data_stack.__stack15.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        let mut __rustylr_location_rbracket = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let mut __rustylr_location_lbracket = __location_stack.pop().unwrap();
        let __res = {
            TerminalSet {
                negate: caret.is_some(),
                items: TerminalSetItem,
                open_span: __rustylr_location_lbracket.span(),
                close_span: __rustylr_location_rbracket.span(),
            }
        };
        __data_stack.__stack9.push(__res);
        Ok(true)
    }
    ///TerminalSet -> dot
    #[inline]
    fn reduce_TerminalSet_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack9);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut __rustylr_location_dot = __location_stack.pop().unwrap();
        let __res = {
            let span = __rustylr_location_dot.span();
            TerminalSet {
                negate: true,
                items: vec![],
                open_span: span,
                close_span: span,
            }
        };
        __data_stack.__stack9.push(__res);
        Ok(true)
    }
    ///Pattern -> ident
    #[inline]
    fn reduce_Pattern_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack10);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Ident(ident) = ident else {
                unreachable!("Pattern-Ident");
            };
            PatternArgs::Ident(ident)
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> Pattern plus
    #[inline]
    fn reduce_Pattern_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Pattern = __data_stack.__stack10.pop().unwrap();
        let mut plus = __data_stack.__terminals.pop().unwrap();
        let mut __rustylr_location_plus = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Plus(plus) = plus else {
                unreachable!("Pattern-Plus");
            };
            PatternArgs::Plus(Box::new(Pattern), __rustylr_location_plus.span())
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> Pattern star
    #[inline]
    fn reduce_Pattern_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Pattern = __data_stack.__stack10.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut __rustylr_location_star = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            PatternArgs::Star(Box::new(Pattern), __rustylr_location_star.span())
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> Pattern question
    #[inline]
    fn reduce_Pattern_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Pattern = __data_stack.__stack10.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut __rustylr_location_question = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            PatternArgs::Question(Box::new(Pattern), __rustylr_location_question.span())
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> Pattern exclamation
    #[inline]
    fn reduce_Pattern_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Pattern = __data_stack.__stack10.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut __rustylr_location_exclamation = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            PatternArgs::Exclamation(
                Box::new(Pattern),
                __rustylr_location_exclamation.span(),
            )
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> TerminalSet
    #[inline]
    fn reduce_Pattern_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack9)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack10);
        let mut TerminalSet = __data_stack.__stack9.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { PatternArgs::TerminalSet(TerminalSet) };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> Pattern slash Pattern
    #[inline]
    fn reduce_Pattern_6(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut lh = __data_stack.__stack10.pop().unwrap();
        let mut p1 = __data_stack.__stack10.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { PatternArgs::Lookaheads(Box::new(p1), Box::new(lh)) };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> lparen $sep(Pattern*, pipe, +) rparen
    #[inline]
    fn reduce_Pattern_7(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack17)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack10);
        let mut Pattern = __data_stack.__stack17.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        let mut __rustylr_location_rparen = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_lparen = __location_stack.pop().unwrap();
        let __res = {
            PatternArgs::Group(
                Pattern,
                __rustylr_location_lparen.span(),
                __rustylr_location_rparen.span(),
            )
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> lparen error rparen
    #[inline]
    fn reduce_Pattern_8(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::__stack10);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            data.error_recovered
                .push(RecoveredError {
                    message: "syntax error when parsing GROUP".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#patterns"
                        .to_string(),
                    span: __rustylr_location_error,
                });
            PatternArgs::Ident(format_ident!("dummy"))
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> literal
    #[inline]
    fn reduce_Pattern_9(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack10);
        let mut literal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Literal(literal) = literal else {
                unreachable!("Pattern-Literal");
            };
            PatternArgs::Literal(literal)
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> Pattern minus Pattern
    #[inline]
    fn reduce_Pattern_10(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut p2 = __data_stack.__stack10.pop().unwrap();
        let mut p1 = __data_stack.__stack10.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { PatternArgs::Minus(Box::new(p1), Box::new(p2)) };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> dollar ident lparen Pattern comma Pattern comma? rparen
    #[inline]
    fn reduce_Pattern_11(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack14)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 7usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 8usize);
        __data_stack.__tags.push(GrammarTags::__stack10);
        let mut del = __data_stack.__stack10.pop().unwrap();
        let mut base = __data_stack.__stack10.pop().unwrap();
        __data_stack.__stack14.truncate(__data_stack.__stack14.len() - 1usize);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 6usize);
        let mut __rustylr_location_ident = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Ident(ident) = ident else {
                unreachable!("Pattern-Sep-Ident");
            };
            if ident != "sep" {
                data.error_recovered
                    .push(RecoveredError {
                        message: "Expected $sep".to_string(),
                        link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#patterns"
                            .to_string(),
                        span: __rustylr_location_ident,
                    });
            }
            PatternArgs::Sep(Box::new(base), Box::new(del), false, *__rustylr_location0)
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> dollar ident lparen Pattern comma Pattern comma plus rparen
    #[inline]
    fn reduce_Pattern_12(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 7usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 8usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 9usize);
        __data_stack.__tags.push(GrammarTags::__stack10);
        let mut del = __data_stack.__stack10.pop().unwrap();
        let mut base = __data_stack.__stack10.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 5usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 7usize);
        let mut __rustylr_location_ident = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Ident(ident) = ident else {
                unreachable!("Pattern-Sep-Ident");
            };
            if ident != "sep" {
                data.error_recovered
                    .push(RecoveredError {
                        message: "Expected $sep".to_string(),
                        link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#patterns"
                            .to_string(),
                        span: __rustylr_location_ident,
                    });
            }
            PatternArgs::Sep(Box::new(base), Box::new(del), true, *__rustylr_location0)
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> dollar ident lparen Pattern comma Pattern comma star rparen
    #[inline]
    fn reduce_Pattern_13(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 7usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 8usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 9usize);
        __data_stack.__tags.push(GrammarTags::__stack10);
        let mut del = __data_stack.__stack10.pop().unwrap();
        let mut base = __data_stack.__stack10.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 5usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 7usize);
        let mut __rustylr_location_ident = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Ident(ident) = ident else {
                unreachable!("Pattern-Sep-Ident");
            };
            if ident != "sep" {
                data.error_recovered
                    .push(RecoveredError {
                        message: "Expected $sep".to_string(),
                        link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#patterns"
                            .to_string(),
                        span: __rustylr_location_ident,
                    });
            }
            PatternArgs::Sep(Box::new(base), Box::new(del), false, *__rustylr_location0)
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> dollar ident lparen Pattern comma Pattern error rparen
    #[inline]
    fn reduce_Pattern_14(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 7usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 8usize);
        __data_stack.__tags.push(GrammarTags::__stack10);
        let mut del = __data_stack.__stack10.pop().unwrap();
        let mut base = __data_stack.__stack10.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 4usize);
        let mut __rustylr_location_ident = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Ident(ident) = ident else {
                unreachable!("Pattern-Sep-Ident");
            };
            if ident != "sep" {
                data.error_recovered
                    .push(RecoveredError {
                        message: "Expected $sep".to_string(),
                        link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#patterns"
                            .to_string(),
                        span: __rustylr_location_ident,
                    });
            }
            data.error_recovered
                .push(RecoveredError {
                    message: "Unexpected $sep arguments".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#patterns"
                        .to_string(),
                    span: __rustylr_location_error,
                });
            PatternArgs::Sep(Box::new(base), Box::new(del), false, *__rustylr_location0)
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Pattern -> dollar ident lparen Pattern comma Pattern comma error rparen
    #[inline]
    fn reduce_Pattern_15(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 7usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 8usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 9usize);
        __data_stack.__tags.push(GrammarTags::__stack10);
        let mut del = __data_stack.__stack10.pop().unwrap();
        let mut base = __data_stack.__stack10.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 4usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 5usize);
        let mut __rustylr_location_ident = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Ident(ident) = ident else {
                unreachable!("Pattern-Sep-Ident");
            };
            if ident != "sep" {
                data.error_recovered
                    .push(RecoveredError {
                        message: "Expected $sep".to_string(),
                        link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#patterns"
                            .to_string(),
                        span: __rustylr_location_ident,
                    });
            }
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected '+' or '*' repetition".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#patterns"
                        .to_string(),
                    span: __rustylr_location_error,
                });
            PatternArgs::Sep(Box::new(base), Box::new(del), false, *__rustylr_location0)
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///Action -> bracegroup
    #[inline]
    fn reduce_Action_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack3);
        let mut bracegroup = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::BraceGroup(group) = bracegroup else {
                unreachable!("Action0");
            };
            Some(group)
        };
        __data_stack.__stack3.push(__res);
        Ok(true)
    }
    ///Action ->
    #[inline]
    fn reduce_Action_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(GrammarTags::__stack3);
        let __res = { None };
        __data_stack.__stack3.push(__res);
        Ok(true)
    }
    ///IdentOrLiteral -> ident
    #[inline]
    fn reduce_IdentOrLiteral_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack11);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Ident(ident) = ident else {
                unreachable!("IdentOrLiteral-Ident");
            };
            IdentOrLiteral::Ident(ident)
        };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///IdentOrLiteral -> literal
    #[inline]
    fn reduce_IdentOrLiteral_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack11);
        let mut literal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Lexed::Literal(literal) = literal else {
                unreachable!("IdentOrLiteral-Literal");
            };
            IdentOrLiteral::Literal(literal)
        };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///Directive -> percent token ident [^semicolon]+ semicolon
    #[inline]
    fn reduce_Directive_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut __rustylr_data_3 = __data_stack.__stack18.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __rustylr_data_3 = Self::custom_reduce_action_0(
            __rustylr_data_3,
            data,
            __rustylr_location0,
        )?;
        let mut RustCode = __rustylr_data_3;
        {
            let Lexed::Ident(ident) = ident else {
                unreachable!("TokenDef-Ident");
            };
            data.terminals.push((ident, RustCode));
        }
        Ok(false)
    }
    ///Directive -> percent token ident semicolon
    #[inline]
    fn reduce_Directive_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 4usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_ident = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected token definition".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#token-definition-must-defined"
                        .to_string(),
                    span: __rustylr_location_ident,
                });
        }
        Ok(false)
    }
    ///Directive -> percent token error semicolon
    #[inline]
    fn reduce_Directive_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected token name".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#token-definition-must-defined"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///Directive -> percent start ident semicolon
    #[inline]
    fn reduce_Directive_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        {
            let Lexed::Ident(ident) = ident else {
                unreachable!("StartDef-Ident");
            };
            data.start_rule_name.push(ident);
        }
        Ok(false)
    }
    ///Directive -> percent start error semicolon
    #[inline]
    fn reduce_Directive_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected start rule name".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#start-symbol-must-defined"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///Directive -> percent tokentype [^semicolon]+ semicolon
    #[inline]
    fn reduce_Directive_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut __rustylr_data_2 = __data_stack.__stack18.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let mut __rustylr_location_tokentype = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __rustylr_data_2 = Self::custom_reduce_action_0(
            __rustylr_data_2,
            data,
            __rustylr_location0,
        )?;
        let mut RustCode = __rustylr_data_2;
        {
            data.token_typename.push((__rustylr_location_tokentype.span(), RustCode));
        }
        Ok(false)
    }
    ///Directive -> percent tokentype semicolon
    #[inline]
    fn reduce_Directive_6(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_tokentype = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected token type definition".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#token-type-must-defined"
                        .to_string(),
                    span: __rustylr_location_tokentype,
                });
        }
        Ok(false)
    }
    ///Directive -> percent userdata [^semicolon]+ semicolon
    #[inline]
    fn reduce_Directive_7(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut __rustylr_data_2 = __data_stack.__stack18.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let mut __rustylr_location_userdata = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __rustylr_data_2 = Self::custom_reduce_action_0(
            __rustylr_data_2,
            data,
            __rustylr_location0,
        )?;
        let mut RustCode = __rustylr_data_2;
        {
            data.userdata_typename.push((__rustylr_location_userdata.span(), RustCode));
        }
        Ok(false)
    }
    ///Directive -> percent userdata semicolon
    #[inline]
    fn reduce_Directive_8(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_userdata = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected userdata definition".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#userdata-type-optional"
                        .to_string(),
                    span: __rustylr_location_userdata,
                });
        }
        Ok(false)
    }
    ///Directive -> percent left IdentOrLiteral+ semicolon
    #[inline]
    fn reduce_Directive_9(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack19)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut IdentOrLiteral = __data_stack.__stack19.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let mut __rustylr_location_left = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.precedences
                .push((
                    __rustylr_location_left.span(),
                    Some(ReduceType::Left),
                    IdentOrLiteral,
                ));
        }
        Ok(false)
    }
    ///Directive -> percent left error semicolon
    #[inline]
    fn reduce_Directive_10(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected <ident> to token or <literal>".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#operator-precedence"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///Directive -> percent right IdentOrLiteral+ semicolon
    #[inline]
    fn reduce_Directive_11(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack19)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut IdentOrLiteral = __data_stack.__stack19.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let mut __rustylr_location_right = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.precedences
                .push((
                    __rustylr_location_right.span(),
                    Some(ReduceType::Right),
                    IdentOrLiteral,
                ));
        }
        Ok(false)
    }
    ///Directive -> percent right error semicolon
    #[inline]
    fn reduce_Directive_12(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected <ident> to token or <literal>".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#operator-precedence"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///Directive -> percent precedence IdentOrLiteral+ semicolon
    #[inline]
    fn reduce_Directive_13(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack19)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut IdentOrLiteral = __data_stack.__stack19.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let mut __rustylr_location_precedence = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.precedences
                .push((__rustylr_location_precedence.span(), None, IdentOrLiteral));
        }
        Ok(false)
    }
    ///Directive -> percent precedence error semicolon
    #[inline]
    fn reduce_Directive_14(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected <ident> to token or <literal>".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#operator-precedence"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///Directive -> percent errortype [^semicolon]+ semicolon
    #[inline]
    fn reduce_Directive_15(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut __rustylr_data_2 = __data_stack.__stack18.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let mut __rustylr_location_errortype = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __rustylr_data_2 = Self::custom_reduce_action_0(
            __rustylr_data_2,
            data,
            __rustylr_location0,
        )?;
        let mut RustCode = __rustylr_data_2;
        {
            data.error_typename.push((__rustylr_location_errortype.span(), RustCode));
        }
        Ok(false)
    }
    ///Directive -> percent errortype semicolon
    #[inline]
    fn reduce_Directive_16(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_errortype = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected error type definition".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#error-type-optional"
                        .to_string(),
                    span: __rustylr_location_errortype,
                });
        }
        Ok(false)
    }
    ///Directive -> percent moduleprefix [^semicolon]+ semicolon
    #[inline]
    fn reduce_Directive_17(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut __rustylr_data_2 = __data_stack.__stack18.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let mut __rustylr_location_moduleprefix = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __rustylr_data_2 = Self::custom_reduce_action_0(
            __rustylr_data_2,
            data,
            __rustylr_location0,
        )?;
        let mut RustCode = __rustylr_data_2;
        {
            data.module_prefix.push((__rustylr_location_moduleprefix.span(), RustCode));
        }
        Ok(false)
    }
    ///Directive -> percent moduleprefix semicolon
    #[inline]
    fn reduce_Directive_18(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_moduleprefix = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected moduleprefix definition".to_string(),
                    link: "This is hidden directive, user must not use this explicitly"
                        .to_string(),
                    span: __rustylr_location_moduleprefix,
                });
        }
        Ok(false)
    }
    ///Directive -> percent glr semicolon
    #[inline]
    fn reduce_Directive_19(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut glr = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        {
            data.glr = true;
        }
        Ok(false)
    }
    ///Directive -> percent glr error semicolon
    #[inline]
    fn reduce_Directive_20(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected semicolon".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#glr-parser-generation"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///Directive -> percent lalr semicolon
    #[inline]
    fn reduce_Directive_21(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut lalr = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        {
            data.lalr = true;
        }
        Ok(false)
    }
    ///Directive -> percent lalr error semicolon
    #[inline]
    fn reduce_Directive_22(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected semicolon".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#lalr-parser-generation"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///Directive -> percent nooptim semicolon
    #[inline]
    fn reduce_Directive_23(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        {
            data.no_optim = true;
        }
        Ok(false)
    }
    ///Directive -> percent nooptim error semicolon
    #[inline]
    fn reduce_Directive_24(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected semicolon".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#no-optimization"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///Directive -> percent dense semicolon
    #[inline]
    fn reduce_Directive_25(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut dense = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        {
            data.dense = true;
        }
        Ok(false)
    }
    ///Directive -> percent dense error semicolon
    #[inline]
    fn reduce_Directive_26(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected semicolon".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#dense-parser-table"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///Directive -> percent trace ident* semicolon
    #[inline]
    fn reduce_Directive_27(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut ident = __data_stack.__stack18.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        {
            let idents = ident
                .into_iter()
                .map(|t| {
                    let Lexed::Ident(ident) = t else {
                        unreachable!("Trace-Ident");
                    };
                    ident
                });
            data.traces.extend(idents);
        }
        Ok(false)
    }
    ///Directive -> percent trace error semicolon
    #[inline]
    fn reduce_Directive_28(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected ident".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#tracing-non-terminals"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///Directive -> percent filter [^semicolon]+ semicolon
    #[inline]
    fn reduce_Directive_29(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut __rustylr_data_2 = __data_stack.__stack18.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut filter = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __rustylr_data_2 = Self::custom_reduce_action_0(
            __rustylr_data_2,
            data,
            __rustylr_location0,
        )?;
        let mut RustCode = __rustylr_data_2;
        {
            data.filter = Some(RustCode);
        }
        Ok(false)
    }
    ///Directive -> percent filter semicolon
    #[inline]
    fn reduce_Directive_30(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_filter = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected filter definition".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#filter-directive"
                        .to_string(),
                    span: __rustylr_location_filter,
                });
        }
        Ok(false)
    }
    ///Directive -> percent location [^semicolon]+ semicolon
    #[inline]
    fn reduce_Directive_31(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut __rustylr_data_2 = __data_stack.__stack18.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __rustylr_data_2 = Self::custom_reduce_action_0(
            __rustylr_data_2,
            data,
            __rustylr_location0,
        )?;
        let mut RustCode = __rustylr_data_2;
        {
            data.location_typename = Some(RustCode);
        }
        Ok(false)
    }
    ///Directive -> percent location semicolon
    #[inline]
    fn reduce_Directive_32(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_location = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected location type definition".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#location-tracking"
                        .to_string(),
                    span: __rustylr_location_location,
                });
        }
        Ok(false)
    }
    ///Directive -> percent error semicolon
    #[inline]
    fn reduce_Directive_33(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let mut __rustylr_location_error = __location_stack.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.error_recovered
                .push(RecoveredError {
                    message: "Expected directive, e.g. %token, %start, ...".to_string(),
                    link: "https://github.com/ehwan/RustyLR/blob/main/SYNTAX.md#syntax"
                        .to_string(),
                    span: __rustylr_location_error,
                });
        }
        Ok(false)
    }
    ///GrammarLine -> Rule
    #[inline]
    fn reduce_GrammarLine_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::Empty);
        let mut Rule = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        {
            data.rules.push(Rule);
        }
        Ok(false)
    }
    ///TokenMapped+ -> TokenMapped
    #[inline]
    fn reduce__TokenMappedPlus15_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack12);
        let mut A = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack12.push(__res);
        Ok(true)
    }
    ///TokenMapped+ -> TokenMapped+ TokenMapped
    #[inline]
    fn reduce__TokenMappedPlus15_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack12)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack12.pop().unwrap();
        let mut A = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack12.push(__res);
        Ok(true)
    }
    ///TokenMapped* -> TokenMapped+
    #[inline]
    fn reduce__TokenMappedStar16_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack12)
            );
        }
        let mut __token0 = __data_stack.__stack12.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = __token0;
        __data_stack.__stack12.push(__res);
        Ok(true)
    }
    ///TokenMapped* ->
    #[inline]
    fn reduce__TokenMappedStar16_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(GrammarTags::__stack12);
        let __res = { vec![] };
        __data_stack.__stack12.push(__res);
        Ok(true)
    }
    ///PrecDef+ -> PrecDef
    #[inline]
    fn reduce__PrecDefPlus17_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack6)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack13);
        let mut A = __data_stack.__stack6.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack13.push(__res);
        Ok(true)
    }
    ///PrecDef+ -> PrecDef+ PrecDef
    #[inline]
    fn reduce__PrecDefPlus17_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack6)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack13)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack13.pop().unwrap();
        let mut A = __data_stack.__stack6.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack13.push(__res);
        Ok(true)
    }
    ///PrecDef* -> PrecDef+
    #[inline]
    fn reduce__PrecDefStar18_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack13)
            );
        }
        let mut __token0 = __data_stack.__stack13.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = __token0;
        __data_stack.__stack13.push(__res);
        Ok(true)
    }
    ///PrecDef* ->
    #[inline]
    fn reduce__PrecDefStar18_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(GrammarTags::__stack13);
        let __res = { vec![] };
        __data_stack.__stack13.push(__res);
        Ok(true)
    }
    ///caret? -> caret
    #[inline]
    fn reduce__caretQuestion19_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack14);
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack14.push(__res);
        Ok(true)
    }
    ///caret? ->
    #[inline]
    fn reduce__caretQuestion19_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(GrammarTags::__stack14);
        let __res = { None };
        __data_stack.__stack14.push(__res);
        Ok(true)
    }
    ///TerminalSetItem+ -> TerminalSetItem
    #[inline]
    fn reduce__TerminalSetItemPlus20_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack8)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack15);
        let mut A = __data_stack.__stack8.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack15.push(__res);
        Ok(true)
    }
    ///TerminalSetItem+ -> TerminalSetItem+ TerminalSetItem
    #[inline]
    fn reduce__TerminalSetItemPlus20_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack8)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack15)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack15.pop().unwrap();
        let mut A = __data_stack.__stack8.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack15.push(__res);
        Ok(true)
    }
    ///TerminalSetItem* -> TerminalSetItem+
    #[inline]
    fn reduce__TerminalSetItemStar21_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack15)
            );
        }
        let mut __token0 = __data_stack.__stack15.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = __token0;
        __data_stack.__stack15.push(__res);
        Ok(true)
    }
    ///TerminalSetItem* ->
    #[inline]
    fn reduce__TerminalSetItemStar21_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(GrammarTags::__stack15);
        let __res = { vec![] };
        __data_stack.__stack15.push(__res);
        Ok(true)
    }
    ///Pattern+ -> Pattern
    #[inline]
    fn reduce__PatternPlus22_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack16);
        let mut A = __data_stack.__stack10.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack16.push(__res);
        Ok(true)
    }
    ///Pattern+ -> Pattern+ Pattern
    #[inline]
    fn reduce__PatternPlus22_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack16)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut A = __data_stack.__stack10.pop().unwrap();
        let mut Ap = __data_stack.__stack16.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack16.push(__res);
        Ok(true)
    }
    ///Pattern* -> Pattern+
    #[inline]
    fn reduce__PatternStar23_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack16)
            );
        }
        let mut __token0 = __data_stack.__stack16.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = __token0;
        __data_stack.__stack16.push(__res);
        Ok(true)
    }
    ///Pattern* ->
    #[inline]
    fn reduce__PatternStar23_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(GrammarTags::__stack16);
        let __res = { vec![] };
        __data_stack.__stack16.push(__res);
        Ok(true)
    }
    ///$sep(Pattern*, pipe, +) -> Pattern*
    #[inline]
    fn reduce___PatternStar23SepPlus24_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack16)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack17);
        let mut __token0 = __data_stack.__stack16.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![__token0] };
        __data_stack.__stack17.push(__res);
        Ok(true)
    }
    ///$sep(Pattern*, pipe, +) -> $sep(Pattern*, pipe, +) pipe Pattern*
    #[inline]
    fn reduce___PatternStar23SepPlus24_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack16)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                GrammarTags::__stack17)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut __token1 = __data_stack.__stack16.pop().unwrap();
        let mut __token0 = __data_stack.__stack17.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            __token0.push(__token1);
            __token0
        };
        __data_stack.__stack17.push(__res);
        Ok(true)
    }
    ///comma? -> comma
    #[inline]
    fn reduce__commaQuestion25_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack14);
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack14.push(__res);
        Ok(true)
    }
    ///comma? ->
    #[inline]
    fn reduce__commaQuestion25_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(GrammarTags::__stack14);
        let __res = { None };
        __data_stack.__stack14.push(__res);
        Ok(true)
    }
    ///[^semicolon]+ -> [^semicolon]
    #[inline]
    fn reduce___TermSet26Plus27_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack18);
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack18.push(__res);
        Ok(true)
    }
    ///[^semicolon]+ -> [^semicolon]+ [^semicolon]
    #[inline]
    fn reduce___TermSet26Plus27_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack18)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack18.pop().unwrap();
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack18.push(__res);
        Ok(true)
    }
    ///IdentOrLiteral+ -> IdentOrLiteral
    #[inline]
    fn reduce__IdentOrLiteralPlus28_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack11)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack19);
        let mut A = __data_stack.__stack11.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack19.push(__res);
        Ok(true)
    }
    ///IdentOrLiteral+ -> IdentOrLiteral+ IdentOrLiteral
    #[inline]
    fn reduce__IdentOrLiteralPlus28_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack11)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack19)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut A = __data_stack.__stack11.pop().unwrap();
        let mut Ap = __data_stack.__stack19.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack19.push(__res);
        Ok(true)
    }
    ///ident+ -> ident
    #[inline]
    fn reduce__identPlus29_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(GrammarTags::__stack18);
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack18.push(__res);
        Ok(true)
    }
    ///ident+ -> ident+ ident
    #[inline]
    fn reduce__identPlus29_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::__stack18)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack18.pop().unwrap();
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack18.push(__res);
        Ok(true)
    }
    ///ident* -> ident+
    #[inline]
    fn reduce__identStar30_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::__stack18)
            );
        }
        let mut __token0 = __data_stack.__stack18.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = __token0;
        __data_stack.__stack18.push(__res);
        Ok(true)
    }
    ///ident* ->
    #[inline]
    fn reduce__identStar30_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(GrammarTags::__stack18);
        let __res = { vec![] };
        __data_stack.__stack18.push(__res);
        Ok(true)
    }
    ///GrammarLine+ -> GrammarLine
    #[inline]
    fn reduce__GrammarLinePlus31_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::Empty)
            );
        }
        __location_stack.truncate(__location_stack.len() - 1usize);
        Ok(false)
    }
    ///GrammarLine+ -> GrammarLine GrammarLine+
    #[inline]
    fn reduce__GrammarLinePlus31_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<SpanPair>,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Lexed>,
        data: &mut GrammarArgs,
        __rustylr_location0: &mut SpanPair,
    ) -> Result<bool, ::rusty_lr_core::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                GrammarTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                GrammarTags::Empty)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        Ok(false)
    }
}
#[allow(
    unused_braces,
    unused_parens,
    non_snake_case,
    non_camel_case_types,
    unused_variables
)]
impl ::rusty_lr_core::parser::data_stack::DataStack for GrammarDataStack {
    type Term = Lexed;
    type NonTerm = GrammarNonTerminals;
    type ReduceActionError = ::rusty_lr_core::DefaultReduceActionError;
    type UserData = GrammarArgs;
    type StartType = ();
    type Location = SpanPair;
    fn pop_start(&mut self) -> Option<Self::StartType> {
        let tag = self.__tags.pop();
        debug_assert!(tag == Some(GrammarTags::Empty));
        Some(())
    }
    fn pop(&mut self) {
        match self.__tags.pop().unwrap() {
            GrammarTags::__terminals => {
                self.__terminals.pop();
            }
            GrammarTags::__stack2 => {
                self.__stack2.pop();
            }
            GrammarTags::__stack3 => {
                self.__stack3.pop();
            }
            GrammarTags::__stack4 => {
                self.__stack4.pop();
            }
            GrammarTags::__stack5 => {
                self.__stack5.pop();
            }
            GrammarTags::__stack6 => {
                self.__stack6.pop();
            }
            GrammarTags::__stack7 => {
                self.__stack7.pop();
            }
            GrammarTags::__stack8 => {
                self.__stack8.pop();
            }
            GrammarTags::__stack9 => {
                self.__stack9.pop();
            }
            GrammarTags::__stack10 => {
                self.__stack10.pop();
            }
            GrammarTags::__stack11 => {
                self.__stack11.pop();
            }
            GrammarTags::__stack12 => {
                self.__stack12.pop();
            }
            GrammarTags::__stack13 => {
                self.__stack13.pop();
            }
            GrammarTags::__stack14 => {
                self.__stack14.pop();
            }
            GrammarTags::__stack15 => {
                self.__stack15.pop();
            }
            GrammarTags::__stack16 => {
                self.__stack16.pop();
            }
            GrammarTags::__stack17 => {
                self.__stack17.pop();
            }
            GrammarTags::__stack18 => {
                self.__stack18.pop();
            }
            GrammarTags::__stack19 => {
                self.__stack19.pop();
            }
            _ => {}
        }
    }
    fn push_terminal(&mut self, term: Self::Term) {
        self.__tags.push(GrammarTags::__terminals);
        self.__terminals.push(term);
    }
    fn push_empty(&mut self) {
        self.__tags.push(GrammarTags::Empty);
    }
    fn clear(&mut self) {
        self.__tags.clear();
        self.__terminals.clear();
        self.__stack2.clear();
        self.__stack3.clear();
        self.__stack4.clear();
        self.__stack5.clear();
        self.__stack6.clear();
        self.__stack7.clear();
        self.__stack8.clear();
        self.__stack9.clear();
        self.__stack10.clear();
        self.__stack11.clear();
        self.__stack12.clear();
        self.__stack13.clear();
        self.__stack14.clear();
        self.__stack15.clear();
        self.__stack16.clear();
        self.__stack17.clear();
        self.__stack18.clear();
        self.__stack19.clear();
    }
    fn reserve(&mut self, additional: usize) {
        self.__tags.reserve(additional);
    }
    fn split_off(&mut self, at: usize) -> Self {
        let __other_tag_stack = self.__tags.split_off(at);
        let mut __counts: [u8; 19usize + 1] = [0; 19usize + 1];
        for &tag in &__other_tag_stack {
            __counts[tag as usize] += 1;
        }
        let __other___terminals = self
            .__terminals
            .split_off(self.__terminals.len() - (__counts[0usize] as usize));
        let __other___stack2 = self
            .__stack2
            .split_off(self.__stack2.len() - (__counts[1usize] as usize));
        let __other___stack3 = self
            .__stack3
            .split_off(self.__stack3.len() - (__counts[2usize] as usize));
        let __other___stack4 = self
            .__stack4
            .split_off(self.__stack4.len() - (__counts[3usize] as usize));
        let __other___stack5 = self
            .__stack5
            .split_off(self.__stack5.len() - (__counts[4usize] as usize));
        let __other___stack6 = self
            .__stack6
            .split_off(self.__stack6.len() - (__counts[5usize] as usize));
        let __other___stack7 = self
            .__stack7
            .split_off(self.__stack7.len() - (__counts[6usize] as usize));
        let __other___stack8 = self
            .__stack8
            .split_off(self.__stack8.len() - (__counts[7usize] as usize));
        let __other___stack9 = self
            .__stack9
            .split_off(self.__stack9.len() - (__counts[8usize] as usize));
        let __other___stack10 = self
            .__stack10
            .split_off(self.__stack10.len() - (__counts[9usize] as usize));
        let __other___stack11 = self
            .__stack11
            .split_off(self.__stack11.len() - (__counts[10usize] as usize));
        let __other___stack12 = self
            .__stack12
            .split_off(self.__stack12.len() - (__counts[11usize] as usize));
        let __other___stack13 = self
            .__stack13
            .split_off(self.__stack13.len() - (__counts[12usize] as usize));
        let __other___stack14 = self
            .__stack14
            .split_off(self.__stack14.len() - (__counts[13usize] as usize));
        let __other___stack15 = self
            .__stack15
            .split_off(self.__stack15.len() - (__counts[14usize] as usize));
        let __other___stack16 = self
            .__stack16
            .split_off(self.__stack16.len() - (__counts[15usize] as usize));
        let __other___stack17 = self
            .__stack17
            .split_off(self.__stack17.len() - (__counts[16usize] as usize));
        let __other___stack18 = self
            .__stack18
            .split_off(self.__stack18.len() - (__counts[17usize] as usize));
        let __other___stack19 = self
            .__stack19
            .split_off(self.__stack19.len() - (__counts[18usize] as usize));
        Self {
            __tags: __other_tag_stack,
            __terminals: __other___terminals,
            __stack2: __other___stack2,
            __stack3: __other___stack3,
            __stack4: __other___stack4,
            __stack5: __other___stack5,
            __stack6: __other___stack6,
            __stack7: __other___stack7,
            __stack8: __other___stack8,
            __stack9: __other___stack9,
            __stack10: __other___stack10,
            __stack11: __other___stack11,
            __stack12: __other___stack12,
            __stack13: __other___stack13,
            __stack14: __other___stack14,
            __stack15: __other___stack15,
            __stack16: __other___stack16,
            __stack17: __other___stack17,
            __stack18: __other___stack18,
            __stack19: __other___stack19,
        }
    }
    fn append(&mut self, other: &mut Self) {
        self.__tags.append(&mut other.__tags);
        self.__terminals.append(&mut other.__terminals);
        self.__stack2.append(&mut other.__stack2);
        self.__stack3.append(&mut other.__stack3);
        self.__stack4.append(&mut other.__stack4);
        self.__stack5.append(&mut other.__stack5);
        self.__stack6.append(&mut other.__stack6);
        self.__stack7.append(&mut other.__stack7);
        self.__stack8.append(&mut other.__stack8);
        self.__stack9.append(&mut other.__stack9);
        self.__stack10.append(&mut other.__stack10);
        self.__stack11.append(&mut other.__stack11);
        self.__stack12.append(&mut other.__stack12);
        self.__stack13.append(&mut other.__stack13);
        self.__stack14.append(&mut other.__stack14);
        self.__stack15.append(&mut other.__stack15);
        self.__stack16.append(&mut other.__stack16);
        self.__stack17.append(&mut other.__stack17);
        self.__stack18.append(&mut other.__stack18);
        self.__stack19.append(&mut other.__stack19);
    }
    fn reduce_action(
        data_stack: &mut Self,
        location_stack: &mut Vec<SpanPair>,
        rule_index: usize,
        shift: &mut bool,
        lookahead: &::rusty_lr_core::TerminalSymbol<Self::Term>,
        user_data: &mut Self::UserData,
        location0: &mut Self::Location,
    ) -> Result<bool, Self::ReduceActionError> {
        match rule_index {
            0usize => {
                Self::reduce_Rule_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            1usize => {
                Self::reduce_RuleType_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            2usize => {
                Self::reduce_RuleType_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            3usize => {
                Self::reduce_RuleLines_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            4usize => {
                Self::reduce_RuleLines_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            5usize => {
                Self::reduce_RuleLine_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            6usize => {
                Self::reduce_PrecDef_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            7usize => {
                Self::reduce_PrecDef_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            8usize => {
                Self::reduce_PrecDef_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            9usize => {
                Self::reduce_PrecDef_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            10usize => {
                Self::reduce_PrecDef_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            11usize => {
                Self::reduce_TokenMapped_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            12usize => {
                Self::reduce_TokenMapped_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            13usize => {
                Self::reduce_TerminalSetItem_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            14usize => {
                Self::reduce_TerminalSetItem_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            15usize => {
                Self::reduce_TerminalSetItem_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            16usize => {
                Self::reduce_TerminalSetItem_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            17usize => {
                Self::reduce_TerminalSetItem_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            18usize => {
                Self::reduce_TerminalSetItem_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            19usize => {
                Self::reduce_TerminalSet_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            20usize => {
                Self::reduce_TerminalSet_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            21usize => {
                Self::reduce_Pattern_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            22usize => {
                Self::reduce_Pattern_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            23usize => {
                Self::reduce_Pattern_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            24usize => {
                Self::reduce_Pattern_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            25usize => {
                Self::reduce_Pattern_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            26usize => {
                Self::reduce_Pattern_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            27usize => {
                Self::reduce_Pattern_6(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            28usize => {
                Self::reduce_Pattern_7(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            29usize => {
                Self::reduce_Pattern_8(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            30usize => {
                Self::reduce_Pattern_9(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            31usize => {
                Self::reduce_Pattern_10(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            32usize => {
                Self::reduce_Pattern_11(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            33usize => {
                Self::reduce_Pattern_12(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            34usize => {
                Self::reduce_Pattern_13(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            35usize => {
                Self::reduce_Pattern_14(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            36usize => {
                Self::reduce_Pattern_15(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            37usize => {
                Self::reduce_Action_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            38usize => {
                Self::reduce_Action_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            39usize => {
                Self::reduce_IdentOrLiteral_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            40usize => {
                Self::reduce_IdentOrLiteral_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            41usize => {
                Self::reduce_Directive_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            42usize => {
                Self::reduce_Directive_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            43usize => {
                Self::reduce_Directive_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            44usize => {
                Self::reduce_Directive_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            45usize => {
                Self::reduce_Directive_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            46usize => {
                Self::reduce_Directive_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            47usize => {
                Self::reduce_Directive_6(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            48usize => {
                Self::reduce_Directive_7(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            49usize => {
                Self::reduce_Directive_8(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            50usize => {
                Self::reduce_Directive_9(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            51usize => {
                Self::reduce_Directive_10(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            52usize => {
                Self::reduce_Directive_11(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            53usize => {
                Self::reduce_Directive_12(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            54usize => {
                Self::reduce_Directive_13(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            55usize => {
                Self::reduce_Directive_14(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            56usize => {
                Self::reduce_Directive_15(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            57usize => {
                Self::reduce_Directive_16(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            58usize => {
                Self::reduce_Directive_17(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            59usize => {
                Self::reduce_Directive_18(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            60usize => {
                Self::reduce_Directive_19(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            61usize => {
                Self::reduce_Directive_20(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            62usize => {
                Self::reduce_Directive_21(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            63usize => {
                Self::reduce_Directive_22(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            64usize => {
                Self::reduce_Directive_23(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            65usize => {
                Self::reduce_Directive_24(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            66usize => {
                Self::reduce_Directive_25(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            67usize => {
                Self::reduce_Directive_26(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            68usize => {
                Self::reduce_Directive_27(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            69usize => {
                Self::reduce_Directive_28(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            70usize => {
                Self::reduce_Directive_29(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            71usize => {
                Self::reduce_Directive_30(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            72usize => {
                Self::reduce_Directive_31(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            73usize => {
                Self::reduce_Directive_32(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            74usize => {
                Self::reduce_Directive_33(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            75usize => {
                Self::reduce_GrammarLine_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            78usize => {
                Self::reduce__TokenMappedPlus15_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            79usize => {
                Self::reduce__TokenMappedPlus15_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            80usize => {
                Self::reduce__TokenMappedStar16_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            81usize => {
                Self::reduce__TokenMappedStar16_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            82usize => {
                Self::reduce__PrecDefPlus17_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            83usize => {
                Self::reduce__PrecDefPlus17_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            84usize => {
                Self::reduce__PrecDefStar18_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            85usize => {
                Self::reduce__PrecDefStar18_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            86usize => {
                Self::reduce__caretQuestion19_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            87usize => {
                Self::reduce__caretQuestion19_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            88usize => {
                Self::reduce__TerminalSetItemPlus20_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            89usize => {
                Self::reduce__TerminalSetItemPlus20_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            90usize => {
                Self::reduce__TerminalSetItemStar21_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            91usize => {
                Self::reduce__TerminalSetItemStar21_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            92usize => {
                Self::reduce__PatternPlus22_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            93usize => {
                Self::reduce__PatternPlus22_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            94usize => {
                Self::reduce__PatternStar23_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            95usize => {
                Self::reduce__PatternStar23_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            96usize => {
                Self::reduce___PatternStar23SepPlus24_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            97usize => {
                Self::reduce___PatternStar23SepPlus24_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            98usize => {
                Self::reduce__commaQuestion25_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            99usize => {
                Self::reduce__commaQuestion25_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            141usize => {
                Self::reduce___TermSet26Plus27_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            142usize => {
                Self::reduce___TermSet26Plus27_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            143usize => {
                Self::reduce__IdentOrLiteralPlus28_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            144usize => {
                Self::reduce__IdentOrLiteralPlus28_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            145usize => {
                Self::reduce__identPlus29_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            146usize => {
                Self::reduce__identPlus29_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            147usize => {
                Self::reduce__identStar30_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            148usize => {
                Self::reduce__identStar30_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            149usize => {
                Self::reduce__GrammarLinePlus31_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            150usize => {
                Self::reduce__GrammarLinePlus31_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            _ => {
                unreachable!("Invalid Rule: {}", rule_index);
            }
        }
    }
}
/// A struct that holds the entire parser table and production rules.
#[allow(unused_braces, unused_parens, unused_variables, non_snake_case, unused_mut)]
pub struct GrammarParser {
    /// production rules
    pub rules: Vec<GrammarRule>,
    /// states
    pub states: Vec<GrammarState>,
    /// terminal classes
    pub classes: Vec<Vec<&'static str>>,
}
impl ::rusty_lr_core::parser::Parser for GrammarParser {
    type Term = Lexed;
    type NonTerm = GrammarNonTerminals;
    type State = GrammarState;
    type TerminalClassElement = &'static str;
    const ERROR_USED: bool = true;
    fn class_precedence(
        &self,
        class: ::rusty_lr_core::TerminalSymbol<usize>,
    ) -> ::rusty_lr_core::parser::Precedence {
        match class {
            ::rusty_lr_core::TerminalSymbol::Term(class) => {
                #[allow(unreachable_patterns)]
                match class {
                    10 => ::rusty_lr_core::parser::Precedence::new(0),
                    12 => ::rusty_lr_core::parser::Precedence::new(1),
                    6..=8 | 11 => ::rusty_lr_core::parser::Precedence::new(2),
                    _ => ::rusty_lr_core::parser::Precedence::none(),
                }
            }
            ::rusty_lr_core::TerminalSymbol::Error => {
                ::rusty_lr_core::parser::Precedence::none()
            }
            ::rusty_lr_core::TerminalSymbol::Eof => {
                unreachable!("eof token cannot be used in precedence levels")
            }
        }
    }
    fn precedence_types(&self, level: u8) -> Option<::rusty_lr_core::rule::ReduceType> {
        #[allow(unreachable_patterns)]
        match level {
            0..=2 => Some(::rusty_lr_core::rule::ReduceType::Left),
            _ => None,
        }
    }
    fn get_rules(&self) -> &[GrammarRule] {
        &self.rules
    }
    fn get_states(&self) -> &[GrammarState] {
        &self.states
    }
    fn get_terminals(
        &self,
        i: usize,
    ) -> Option<impl IntoIterator<Item = Self::TerminalClassElement> + '_> {
        self.classes.get(i).map(|class| class.iter().copied())
    }
    fn to_terminal_class(&self, terminal: &Self::Term) -> usize {
        #[allow(unreachable_patterns)]
        match terminal {
            Lexed::Ident(_) => 0,
            Lexed::Colon(_) => 1,
            Lexed::Semicolon(_) => 2,
            Lexed::Pipe(_) => 3,
            Lexed::Percent(_) => 4,
            Lexed::Equal(_) => 5,
            Lexed::Plus(_) => 6,
            Lexed::Star(_) => 7,
            Lexed::Question(_) => 8,
            Lexed::Caret(_) => 9,
            Lexed::Minus(_) => 10,
            Lexed::Exclamation(_) => 11,
            Lexed::Slash(_) => 12,
            Lexed::Dot(_) => 13,
            Lexed::Dollar(_) => 14,
            Lexed::Comma(_) => 15,
            Lexed::Literal(_) => 16,
            Lexed::ParenGroup(_) => 17,
            Lexed::BraceGroup(_) => 18,
            Lexed::LParen => 19,
            Lexed::RParen => 20,
            Lexed::LBracket => 21,
            Lexed::RBracket => 22,
            Lexed::Left(_) => 23,
            Lexed::Right(_) => 24,
            Lexed::Token(_) => 25,
            Lexed::Start(_) => 26,
            Lexed::TokenType(_) => 27,
            Lexed::UserData(_) => 28,
            Lexed::ErrorType(_) => 29,
            Lexed::ModulePrefix(_) => 30,
            Lexed::Lalr(_) => 31,
            Lexed::Glr(_) => 32,
            Lexed::Prec(_) => 33,
            Lexed::Precedence(_) => 34,
            Lexed::NoOptim(_) => 35,
            Lexed::Dense(_) => 36,
            Lexed::Trace(_) => 37,
            Lexed::DPrec(_) => 38,
            Lexed::Filter(_) => 39,
            Lexed::Location(_) => 40,
            _ => 41,
        }
    }
}
/// A struct that holds the whole parser table.
#[allow(unused_braces, unused_parens, unused_variables, non_snake_case, unused_mut)]
impl GrammarParser {
    /// Calculates the states and parser tables from the grammar.
    #[allow(clippy::clone_on_copy)]
    pub fn new() -> Self {
        let rules: Vec<
            ::rusty_lr_core::rule::ProductionRule<::rusty_lr_core::TerminalSymbol<u8>, _>,
        > = vec![
            ::rusty_lr_core::rule::ProductionRule { name : GrammarNonTerminals::Rule,
            rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleType),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(1)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleLines),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::RuleType, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(17)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::RuleType, rule : vec![], precedence : None, },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::RuleLines, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleLines),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(3)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleLine),], precedence
            : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::RuleLines, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleLine),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::RuleLine, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_TokenMappedStar16),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_PrecDefStar18),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Action),], precedence :
            None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::PrecDef, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(33)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::IdentOrLiteral),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::PrecDef, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(33)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::PrecDef, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(38)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(16)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::PrecDef, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(38)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::PrecDef, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::TokenMapped, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::TokenMapped, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(5)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),], precedence :
            None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::TerminalSetItem, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::TerminalSetItem, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(10)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),],
            precedence : Some(::rusty_lr_core::rule::Precedence::Fixed(0usize)), },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::TerminalSetItem, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(10)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),],
            precedence : Some(::rusty_lr_core::rule::Precedence::Fixed(0usize)), },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::TerminalSetItem, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(16)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::TerminalSetItem, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(16)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(10)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(16)),],
            precedence : Some(::rusty_lr_core::rule::Precedence::Fixed(0usize)), },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::TerminalSetItem, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(16)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(10)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),],
            precedence : Some(::rusty_lr_core::rule::Precedence::Fixed(0usize)), },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::TerminalSet, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(21)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_caretQuestion19),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_TerminalSetItemStar21),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(22)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::TerminalSet, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(13)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Pattern, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Pattern, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(6)),],
            precedence : Some(::rusty_lr_core::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr_core::rule::ProductionRule { name : GrammarNonTerminals::Pattern,
            rule : vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(7)),],
            precedence : Some(::rusty_lr_core::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr_core::rule::ProductionRule { name : GrammarNonTerminals::Pattern,
            rule : vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(8)),],
            precedence : Some(::rusty_lr_core::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr_core::rule::ProductionRule { name : GrammarNonTerminals::Pattern,
            rule : vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(11)),],
            precedence : Some(::rusty_lr_core::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr_core::rule::ProductionRule { name : GrammarNonTerminals::Pattern,
            rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TerminalSet),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Pattern, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(12)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),], precedence :
            Some(::rusty_lr_core::rule::Precedence::Fixed(1usize)), },
            ::rusty_lr_core::rule::ProductionRule { name : GrammarNonTerminals::Pattern,
            rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(19)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::__PatternStar23SepPlus24),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(20)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Pattern, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(19)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(20)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Pattern, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(16)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Pattern, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(10)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),], precedence :
            Some(::rusty_lr_core::rule::Precedence::Fixed(0usize)), },
            ::rusty_lr_core::rule::ProductionRule { name : GrammarNonTerminals::Pattern,
            rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(14)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(19)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(15)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_commaQuestion25),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(20)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Pattern, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(14)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(19)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(15)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(15)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(6)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(20)),],
            precedence : Some(::rusty_lr_core::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr_core::rule::ProductionRule { name : GrammarNonTerminals::Pattern,
            rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(14)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(19)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(15)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(15)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(7)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(20)),],
            precedence : Some(::rusty_lr_core::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr_core::rule::ProductionRule { name : GrammarNonTerminals::Pattern,
            rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(14)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(19)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(15)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(20)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Pattern, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(14)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(19)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(15)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(15)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(20)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Action, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(18)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Action, rule : vec![], precedence : None, },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::IdentOrLiteral, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::IdentOrLiteral, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(16)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(25)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::__TermSet26Plus27),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(25)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(25)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(26)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(26)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(27)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::__TermSet26Plus27),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(27)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(28)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::__TermSet26Plus27),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(28)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(23)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_IdentOrLiteralPlus28),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(23)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(24)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_IdentOrLiteralPlus28),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(24)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(34)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_IdentOrLiteralPlus28),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(34)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(29)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::__TermSet26Plus27),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(29)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(30)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::__TermSet26Plus27),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(30)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(32)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(32)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(31)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(31)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(35)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(35)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(36)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(36)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(37)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_identStar30),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(37)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(39)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::__TermSet26Plus27),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(39)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(40)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::__TermSet26Plus27),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(40)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Directive, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Error),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::GrammarLine, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Rule),], precedence
            : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::GrammarLine, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Directive),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Grammar, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_GrammarLinePlus31),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TokenMappedPlus15, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TokenMapped),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TokenMappedPlus15, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_TokenMappedPlus15),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TokenMapped),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TokenMappedStar16, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_TokenMappedPlus15),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TokenMappedStar16, rule : vec![], precedence : None, },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_PrecDefPlus17, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::PrecDef),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_PrecDefPlus17, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_PrecDefPlus17),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::PrecDef),], precedence :
            None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_PrecDefStar18, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_PrecDefPlus17),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_PrecDefStar18, rule : vec![], precedence : None, },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_caretQuestion19, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(9)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_caretQuestion19, rule : vec![], precedence : None, },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TerminalSetItemPlus20, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TerminalSetItem),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TerminalSetItemPlus20, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_TerminalSetItemPlus20),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TerminalSetItem),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TerminalSetItemStar21, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_TerminalSetItemPlus20),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TerminalSetItemStar21, rule : vec![], precedence :
            None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_PatternPlus22, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_PatternPlus22, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_PatternPlus22),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),], precedence :
            None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_PatternStar23, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_PatternPlus22),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_PatternStar23, rule : vec![], precedence : None, },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::__PatternStar23SepPlus24, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_PatternStar23),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::__PatternStar23SepPlus24, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::__PatternStar23SepPlus24),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(3)),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_PatternStar23),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_commaQuestion25, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(15)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_commaQuestion25, rule : vec![], precedence : None, },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(1)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(3)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(4)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(5)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(6)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(7)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(8)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(9)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(10)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(11)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(12)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(13)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(14)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(15)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(16)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(17)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(18)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(19)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(20)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(21)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(22)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(23)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(24)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(25)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(26)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(27)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(28)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(29)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(30)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(31)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(32)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(33)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(34)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(35)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(36)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(37)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(38)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(39)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(40)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_TermSet26, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(41)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::__TermSet26Plus27, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_TermSet26),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::__TermSet26Plus27, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::__TermSet26Plus27),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_TermSet26),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_IdentOrLiteralPlus28, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::IdentOrLiteral),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_IdentOrLiteralPlus28, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_IdentOrLiteralPlus28),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::IdentOrLiteral),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_identPlus29, rule :
            vec![::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_identPlus29, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_identPlus29),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Term(0)),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_identStar30, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_identPlus29),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_identStar30, rule : vec![], precedence : None, },
            ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_GrammarLinePlus31, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::GrammarLine),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::_GrammarLinePlus31, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::GrammarLine),
            ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_GrammarLinePlus31),],
            precedence : None, }, ::rusty_lr_core::rule::ProductionRule { name :
            GrammarNonTerminals::Augmented, rule :
            vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
            ::rusty_lr_core::Token::Term(::rusty_lr_core::TerminalSymbol::Eof),],
            precedence : None, },
        ];
        let terminal_class_names = vec![
            "ident", "colon", "semicolon", "pipe", "percent", "equal", "plus", "star",
            "question", "caret", "minus", "exclamation", "slash", "dot", "dollar",
            "comma", "literal", "parengroup", "bracegroup", "lparen", "rparen",
            "lbracket", "rbracket", "left", "right", "token", "start", "tokentype",
            "userdata", "errortype", "moduleprefix", "lalr", "glr", "prec", "precedence",
            "nooptim", "dense", "trace", "dprec", "filter", "location", "<Others>",
        ];
        let rules = rules
            .into_iter()
            .map(move |rule| {
                rule.map(
                    |term| match term {
                        ::rusty_lr_core::TerminalSymbol::Term(term) => {
                            terminal_class_names[term as usize]
                        }
                        ::rusty_lr_core::TerminalSymbol::Error => "error",
                        ::rusty_lr_core::TerminalSymbol::Eof => "eof",
                    },
                    |nonterm| nonterm,
                )
            })
            .collect();
        let __rustylr_tset17: Vec<u8> = vec![
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
            22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
            41
        ];
        let __rustylr_tset19: Vec<u8> = vec![0, 2];
        let __rustylr_tset3: Vec<u8> = vec![
            0, 2, 3, 4, 6, 7, 8, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21
        ];
        let __rustylr_tset2: Vec<u8> = vec![
            0, 2, 3, 4, 6, 7, 8, 10, 11, 12, 13, 14, 16, 18, 19, 21
        ];
        let __rustylr_tset8: Vec<u8> = vec![
            0, 2, 3, 4, 10, 12, 13, 14, 15, 16, 18, 19, 20, 21
        ];
        let __rustylr_tset7: Vec<u8> = vec![
            0, 2, 3, 4, 10, 13, 14, 15, 16, 18, 19, 20, 21
        ];
        let __rustylr_tset11: Vec<u8> = vec![0, 2, 3, 4, 13, 14, 16, 18, 19, 21];
        let __rustylr_tset15: Vec<u8> = vec![0, 2, 3, 4, 16, 18];
        let __rustylr_tset16: Vec<u8> = vec![0, 2, 16];
        let __rustylr_tset9: Vec<u8> = vec![0, 3, 13, 14, 16, 19, 20, 21];
        let __rustylr_tset12: Vec<u8> = vec![0, 4];
        let __rustylr_tset5: Vec<u8> = vec![0, 16, 22];
        let __rustylr_tset0: Vec<u8> = vec![1];
        let __rustylr_tset18: Vec<u8> = vec![2];
        let __rustylr_tset13: Vec<u8> = vec![2, 3];
        let __rustylr_tset1: Vec<u8> = vec![2, 3, 4, 18];
        let __rustylr_tset14: Vec<u8> = vec![2, 3, 18];
        let __rustylr_tset4: Vec<u8> = vec![3, 20];
        let __rustylr_tset10: Vec<u8> = vec![20];
        let __rustylr_tset6: Vec<u8> = vec![22];
        let states: Vec<
            ::rusty_lr_core::parser::state::IntermediateState<u8, _, u8, u8>,
        > = vec![
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(1, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(90, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::Rule,
            ::rusty_lr_core::parser::state::ShiftTarget::new(172, true)),
            (GrammarNonTerminals::Directive,
            ::rusty_lr_core::parser::state::ShiftTarget::new(173, false)),
            (GrammarNonTerminals::GrammarLine,
            ::rusty_lr_core::parser::state::ShiftTarget::new(173, true)),
            (GrammarNonTerminals::Grammar,
            ::rusty_lr_core::parser::state::ShiftTarget::new(175, true)),
            (GrammarNonTerminals::_GrammarLinePlus31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(175, false)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [0, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
            51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
            70, 71, 72, 73, 74, 75, 76, 77, 149, 150, 151,]; let shifted : & 'static [u8]
            = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(17, ::rusty_lr_core::parser::state::ShiftTarget::new(2, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::RuleType,
            ::rusty_lr_core::parser::state::ShiftTarget::new(3, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![2]; __reduce_map.extend(__rustylr_tset0.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2,]; let shifted : & 'static [u8] = & [1, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![1]; __reduce_map
            .extend(__rustylr_tset0.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [1,]; let shifted : & 'static [u8]
            = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(1, ::rusty_lr_core::parser::state::ShiftTarget::new(4, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [0,]; let shifted : & 'static [u8]
            = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(5, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::RuleLines,
            ::rusty_lr_core::parser::state::ShiftTarget::new(64, true)),
            (GrammarNonTerminals::RuleLine,
            ::rusty_lr_core::parser::state::ShiftTarget::new(89, true)),
            (GrammarNonTerminals::TokenMapped,
            ::rusty_lr_core::parser::state::ShiftTarget::new(68, true)),
            (GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(69, true)),
            (GrammarNonTerminals::_TokenMappedPlus15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(70, true)),
            (GrammarNonTerminals::_TokenMappedStar16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(72, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![81]; __reduce_map.extend(__rustylr_tset1.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [0, 3, 4,
            5, 11, 12, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
            35, 36, 78, 79, 80, 81,]; let shifted : & 'static [u8] = & [3, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(5, ::rusty_lr_core::parser::state::ShiftTarget::new(6, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![21]; __reduce_map.extend(__rustylr_tset2.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [12, 21,]; let shifted : & 'static [u8] = & [1, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(7, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(63, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [12, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
            29, 30, 31, 32, 33, 34, 35, 36,]; let shifted : & 'static [u8] = & [2, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![21]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![21]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [21,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![20]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![20]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [20,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(10, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [32, 33, 34, 35, 36,]; let shifted
            : & 'static [u8] = & [1, 1, 1, 1, 1,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(19, ::rusty_lr_core::parser::state::ShiftTarget::new(11, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [32, 33, 34, 35, 36,]; let shifted
            : & 'static [u8] = & [2, 2, 2, 2, 2,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(7, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(31, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
            30, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36, 36,]; let shifted : & 'static
            [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 3, 0, 3, 0,
            3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![30]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![30]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [30,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(7, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            Some(41), eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(43, true)),
            (GrammarNonTerminals::_PatternPlus22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(44, true)),
            (GrammarNonTerminals::_PatternStar23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(46, true)),
            (GrammarNonTerminals::__PatternStar23SepPlus24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(47, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![95]; __reduce_map.extend(__rustylr_tset4.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [19, 20,
            21, 22, 23, 24, 25, 26, 27, 28, 28, 29, 29, 30, 31, 32, 33, 34, 35, 36, 92,
            93, 94, 95, 96, 97,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(9, ::rusty_lr_core::parser::state::ShiftTarget::new(15, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_caretQuestion19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(16, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![87]; __reduce_map.extend(__rustylr_tset5.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [19, 86,
            87,]; let shifted : & 'static [u8] = & [1, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![86]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [86,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(17, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(21, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TerminalSetItem,
            ::rusty_lr_core::parser::state::ShiftTarget::new(25, true)),
            (GrammarNonTerminals::_TerminalSetItemPlus20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(26, true)),
            (GrammarNonTerminals::_TerminalSetItemStar21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(28, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![91]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [13, 14,
            15, 16, 17, 18, 19, 88, 89, 90, 91,]; let shifted : & 'static [u8] = & [0, 0,
            0, 0, 0, 0, 2, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(10, ::rusty_lr_core::parser::state::ShiftTarget::new(18, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![13]; __reduce_map.extend(__rustylr_tset5.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [13, 14, 15,]; let shifted : & 'static [u8] = & [1, 1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(19, true)),],
            error_shift : Some(20), eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [14, 15,]; let shifted : & 'static
            [u8] = & [2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![14]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [14,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![15]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [15,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(10, ::rusty_lr_core::parser::state::ShiftTarget::new(22, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![16]; __reduce_map.extend(__rustylr_tset5.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [16, 17, 18,]; let shifted : & 'static [u8] = & [1, 1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(16, ::rusty_lr_core::parser::state::ShiftTarget::new(23, true)),],
            error_shift : Some(24), eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [17, 18,]; let shifted : & 'static
            [u8] = & [2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![17]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [17,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![18]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [18,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![88]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [88,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(17, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(21, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TerminalSetItem,
            ::rusty_lr_core::parser::state::ShiftTarget::new(27, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![90]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [13, 14,
            15, 16, 17, 18, 89, 90,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0,
            1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![89]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [89,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(22, ::rusty_lr_core::parser::state::ShiftTarget::new(29, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [19,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![19]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![19]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [19,]; let
            shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![26]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![26]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [26,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(6, ::rusty_lr_core::parser::state::ShiftTarget::new(32, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(33, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(34, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(35, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(37, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(38, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(40, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [22, 23, 24, 25, 27, 31, 32, 33, 34, 35, 36,];
            let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![22]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![22]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [22,]; let
            shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![23]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![23]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [23,]; let
            shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![24]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![24]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [24,]; let
            shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(7, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(36, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
            30, 31, 31, 32, 33, 34, 35, 36,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(6, ::rusty_lr_core::parser::state::ShiftTarget::new(32, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(33, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(34, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(37, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(38, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![31]; __reduce_map.extend(__rustylr_tset7.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            Some(vec![31]), eof_reduce : None, ruleset : { let rules : & 'static [u8] = &
            [22, 23, 24, 25, 27, 31,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1,
            3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![25]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![25]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [25,]; let
            shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(7, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(39, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [19, 20, 21, 22, 23, 24, 25, 26, 27, 27, 28,
            29, 30, 31, 32, 33, 34, 35, 36,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(6, ::rusty_lr_core::parser::state::ShiftTarget::new(32, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(33, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(34, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(37, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![27]; __reduce_map.extend(__rustylr_tset8.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            Some(vec![27]), eof_reduce : None, ruleset : { let rules : & 'static [u8] = &
            [22, 23, 24, 25, 27,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(7, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(51, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
            30, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36, 36,]; let shifted : & 'static
            [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 5, 0, 5, 0,
            5,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(20, ::rusty_lr_core::parser::state::ShiftTarget::new(42, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [29,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![29]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![29]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [29,]; let
            shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(6, ::rusty_lr_core::parser::state::ShiftTarget::new(32, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(33, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(34, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(35, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(37, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(38, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![92]; __reduce_map.extend(__rustylr_tset9.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [22, 23,
            24, 25, 27, 31, 92,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(7, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(45, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![94]; __reduce_map.extend(__rustylr_tset4.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [19, 20,
            21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 93, 94,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(6, ::rusty_lr_core::parser::state::ShiftTarget::new(32, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(33, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(34, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(35, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(37, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(38, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![93]; __reduce_map.extend(__rustylr_tset9.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [22, 23,
            24, 25, 27, 31, 93,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1,
            2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![96]; __reduce_map
            .extend(__rustylr_tset4.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [96,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(3, ::rusty_lr_core::parser::state::ShiftTarget::new(48, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(50, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [28, 97,]; let shifted : & 'static [u8] = &
            [2, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(7, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(43, true)),
            (GrammarNonTerminals::_PatternPlus22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(44, true)),
            (GrammarNonTerminals::_PatternStar23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(49, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![95]; __reduce_map.extend(__rustylr_tset4.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [19, 20,
            21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 92, 93, 94,
            95, 97,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![97]; __reduce_map
            .extend(__rustylr_tset4.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [97,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![28]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![28]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [28,]; let
            shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(6, ::rusty_lr_core::parser::state::ShiftTarget::new(32, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(33, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(34, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(35, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(37, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(38, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(52, true)),], error_shift :
            Some(59), eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_commaQuestion25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(61, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![99]; __reduce_map.extend(__rustylr_tset10.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [22, 23,
            24, 25, 27, 31, 32, 33, 34, 35, 36, 98, 99,]; let shifted : & 'static [u8] =
            & [1, 1, 1, 1, 1, 1, 6, 6, 6, 6, 6, 0, 0,]; rules.iter().zip(shifted.iter())
            .map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule :
            rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(6, ::rusty_lr_core::parser::state::ShiftTarget::new(53, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(55, true)),], error_shift :
            Some(57), eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![98]; __reduce_map.extend(__rustylr_tset10.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [33, 34,
            36, 98,]; let shifted : & 'static [u8] = & [7, 7, 7, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(20, ::rusty_lr_core::parser::state::ShiftTarget::new(54, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [33,]; let shifted : & 'static
            [u8] = & [8,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![33]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![33]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [33,]; let
            shifted : & 'static [u8] = & [9,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(20, ::rusty_lr_core::parser::state::ShiftTarget::new(56, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [34,]; let shifted : & 'static
            [u8] = & [8,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![34]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![34]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [34,]; let
            shifted : & 'static [u8] = & [9,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(20, ::rusty_lr_core::parser::state::ShiftTarget::new(58, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [36,]; let shifted : & 'static
            [u8] = & [8,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![36]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![36]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [36,]; let
            shifted : & 'static [u8] = & [9,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(20, ::rusty_lr_core::parser::state::ShiftTarget::new(60, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [35,]; let shifted : & 'static
            [u8] = & [7,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![35]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![35]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [35,]; let
            shifted : & 'static [u8] = & [8,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(20, ::rusty_lr_core::parser::state::ShiftTarget::new(62, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [32,]; let shifted : & 'static
            [u8] = & [7,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![32]; __reduce_map
            .extend(__rustylr_tset3.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : Some(vec![32]),
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [32,]; let
            shifted : & 'static [u8] = & [8,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(6, ::rusty_lr_core::parser::state::ShiftTarget::new(32, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(33, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(34, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(35, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(37, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(38, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![12]; __reduce_map.extend(__rustylr_tset11.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [12, 22,
            23, 24, 25, 27, 31,]; let shifted : & 'static [u8] = & [3, 1, 1, 1, 1, 1,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(65, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(66, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [0, 3,]; let shifted : & 'static [u8] = & [4,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![0]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![0]), ruleset : { let rules : & 'static [u8] = & [0,];
            let shifted : & 'static [u8] = & [5,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(5, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::RuleLine,
            ::rusty_lr_core::parser::state::ShiftTarget::new(67, true)),
            (GrammarNonTerminals::TokenMapped,
            ::rusty_lr_core::parser::state::ShiftTarget::new(68, true)),
            (GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(69, true)),
            (GrammarNonTerminals::_TokenMappedPlus15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(70, true)),
            (GrammarNonTerminals::_TokenMappedStar16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(72, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![81]; __reduce_map.extend(__rustylr_tset1.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3, 5,
            11, 12, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
            36, 78, 79, 80, 81,]; let shifted : & 'static [u8] = & [2, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![3]; __reduce_map
            .extend(__rustylr_tset13.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3,]; let
            shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![78]; __reduce_map
            .extend(__rustylr_tset11.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [78,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(6, ::rusty_lr_core::parser::state::ShiftTarget::new(32, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(33, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(34, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(35, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(37, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(38, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![11]; __reduce_map.extend(__rustylr_tset11.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [11, 22,
            23, 24, 25, 27, 31,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(5, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(8, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(9, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(12, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(13, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(14, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::TokenMapped,
            ::rusty_lr_core::parser::state::ShiftTarget::new(71, true)),
            (GrammarNonTerminals::TerminalSet,
            ::rusty_lr_core::parser::state::ShiftTarget::new(30, true)),
            (GrammarNonTerminals::Pattern,
            ::rusty_lr_core::parser::state::ShiftTarget::new(69, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![80]; __reduce_map.extend(__rustylr_tset1.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [11, 12,
            19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 79,
            80,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![79]; __reduce_map
            .extend(__rustylr_tset11.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [79,]; let
            shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(4, ::rusty_lr_core::parser::state::ShiftTarget::new(73, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::PrecDef,
            ::rusty_lr_core::parser::state::ShiftTarget::new(83, true)),
            (GrammarNonTerminals::_PrecDefPlus17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(84, true)),
            (GrammarNonTerminals::_PrecDefStar18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(86, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![85]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [5, 6, 7,
            8, 9, 10, 82, 83, 84, 85,]; let shifted : & 'static [u8] = & [1, 0, 0, 0, 0,
            0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) |
            { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(33, ::rusty_lr_core::parser::state::ShiftTarget::new(74, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(79, true)),], error_shift :
            Some(82), eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [6, 7, 8, 9, 10,]; let shifted : & 'static
            [u8] = & [1, 1, 1, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(75, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(76, true)),], error_shift :
            Some(77), eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::IdentOrLiteral,
            ::rusty_lr_core::parser::state::ShiftTarget::new(78, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [6, 7, 39, 40,]; let shifted : & 'static [u8]
            = & [2, 2, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![39]; __reduce_map
            .extend(__rustylr_tset15.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [39,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![40]; __reduce_map
            .extend(__rustylr_tset15.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [40,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![7]; __reduce_map
            .extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [7,]; let shifted : & 'static [u8]
            = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![6]; __reduce_map
            .extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [6,]; let shifted : & 'static [u8]
            = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(16, ::rusty_lr_core::parser::state::ShiftTarget::new(80, true)),],
            error_shift : Some(81), eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [8, 9,]; let shifted : & 'static
            [u8] = & [2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![8]; __reduce_map
            .extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [8,]; let shifted : & 'static [u8]
            = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![9]; __reduce_map
            .extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [9,]; let shifted : & 'static [u8]
            = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![10]; __reduce_map
            .extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [10,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![82]; __reduce_map
            .extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [82,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(4, ::rusty_lr_core::parser::state::ShiftTarget::new(73, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::PrecDef,
            ::rusty_lr_core::parser::state::ShiftTarget::new(85, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![84]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [6, 7, 8,
            9, 10, 83, 84,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 1, 1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![83]; __reduce_map
            .extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [83,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(18, ::rusty_lr_core::parser::state::ShiftTarget::new(87, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::Action,
            ::rusty_lr_core::parser::state::ShiftTarget::new(88, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![38]; __reduce_map.extend(__rustylr_tset13.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [5, 37,
            38,]; let shifted : & 'static [u8] = & [2, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![37]; __reduce_map
            .extend(__rustylr_tset13.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [37,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![5]; __reduce_map
            .extend(__rustylr_tset13.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [5,]; let
            shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![4]; __reduce_map
            .extend(__rustylr_tset13.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [4,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(23, ::rusty_lr_core::parser::state::ShiftTarget::new(91, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(98, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(103, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(112, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(117, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(121, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(125, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(129, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(133, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(137, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(141, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(146, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(150, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(154, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(162, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(166, true)),], error_shift :
            Some(170), eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
            71, 72, 73, 74,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(75, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(76, true)),], error_shift :
            Some(92), eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::IdentOrLiteral,
            ::rusty_lr_core::parser::state::ShiftTarget::new(94, true)),
            (GrammarNonTerminals::_IdentOrLiteralPlus28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(95, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [39, 40, 50, 51, 143, 144,]; let shifted : &
            'static [u8] = & [0, 0, 2, 2, 0, 0,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(93, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [51,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![51]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![51]), ruleset : { let rules : & 'static [u8] = &
            [51,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![143]; __reduce_map
            .extend(__rustylr_tset16.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [143,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(75, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(96, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(76, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::IdentOrLiteral,
            ::rusty_lr_core::parser::state::ShiftTarget::new(97, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [39, 40, 50, 144,]; let shifted : & 'static
            [u8] = & [0, 0, 3, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![50]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![50]), ruleset : { let rules : & 'static [u8] = &
            [50,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![144]; __reduce_map
            .extend(__rustylr_tset16.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [144,]; let
            shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(75, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(76, true)),], error_shift :
            Some(99), eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::IdentOrLiteral,
            ::rusty_lr_core::parser::state::ShiftTarget::new(94, true)),
            (GrammarNonTerminals::_IdentOrLiteralPlus28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(101, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [39, 40, 52, 53, 143, 144,]; let shifted : &
            'static [u8] = & [0, 0, 2, 2, 0, 0,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(100, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [53,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![53]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![53]), ruleset : { let rules : & 'static [u8] = &
            [53,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(75, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(102, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(76, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::IdentOrLiteral,
            ::rusty_lr_core::parser::state::ShiftTarget::new(97, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [39, 40, 52, 144,]; let shifted : & 'static
            [u8] = & [0, 0, 3, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![52]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![52]), ruleset : { let rules : & 'static [u8] = &
            [52,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(104, true)),],
            error_shift : Some(110), eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [41, 42, 43,]; let shifted : &
            'static [u8] = & [2, 2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(105, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),
            (GrammarNonTerminals::__TermSet26Plus27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(107, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [41, 42, 100, 101, 102, 103, 104, 105, 106,
            107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
            122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
            137, 138, 139, 140, 141, 142,]; let shifted : & 'static [u8] = & [3, 3, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![42]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![42]), ruleset : { let rules : & 'static [u8] = &
            [42,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![141]; __reduce_map
            .extend(__rustylr_tset17.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [141,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(108, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [41, 100, 101, 102, 103, 104, 105, 106, 107,
            108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
            123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
            138, 139, 140, 142,]; let shifted : & 'static [u8] = & [4, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![41]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![41]), ruleset : { let rules : & 'static [u8] = &
            [41,]; let shifted : & 'static [u8] = & [5,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![142]; __reduce_map
            .extend(__rustylr_tset17.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [142,]; let
            shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(111, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [43,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![43]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![43]), ruleset : { let rules : & 'static [u8] = &
            [43,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(113, true)),],
            error_shift : Some(115), eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [44, 45,]; let shifted : & 'static
            [u8] = & [2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(114, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [44,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![44]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![44]), ruleset : { let rules : & 'static [u8] = &
            [44,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(116, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [45,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![45]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![45]), ruleset : { let rules : & 'static [u8] = &
            [45,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(118, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),
            (GrammarNonTerminals::__TermSet26Plus27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(119, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [46, 47, 100, 101, 102, 103, 104, 105, 106,
            107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
            122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
            137, 138, 139, 140, 141, 142,]; let shifted : & 'static [u8] = & [2, 2, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![47]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![47]), ruleset : { let rules : & 'static [u8] = &
            [47,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(120, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [46, 100, 101, 102, 103, 104, 105, 106, 107,
            108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
            123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
            138, 139, 140, 142,]; let shifted : & 'static [u8] = & [3, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![46]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![46]), ruleset : { let rules : & 'static [u8] = &
            [46,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(122, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),
            (GrammarNonTerminals::__TermSet26Plus27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(123, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [48, 49, 100, 101, 102, 103, 104, 105, 106,
            107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
            122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
            137, 138, 139, 140, 141, 142,]; let shifted : & 'static [u8] = & [2, 2, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![49]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![49]), ruleset : { let rules : & 'static [u8] = &
            [49,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(124, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [48, 100, 101, 102, 103, 104, 105, 106, 107,
            108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
            123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
            138, 139, 140, 142,]; let shifted : & 'static [u8] = & [3, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![48]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![48]), ruleset : { let rules : & 'static [u8] = &
            [48,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(126, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),
            (GrammarNonTerminals::__TermSet26Plus27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(127, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [56, 57, 100, 101, 102, 103, 104, 105, 106,
            107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
            122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
            137, 138, 139, 140, 141, 142,]; let shifted : & 'static [u8] = & [2, 2, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![57]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![57]), ruleset : { let rules : & 'static [u8] = &
            [57,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(128, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [56, 100, 101, 102, 103, 104, 105, 106, 107,
            108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
            123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
            138, 139, 140, 142,]; let shifted : & 'static [u8] = & [3, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![56]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![56]), ruleset : { let rules : & 'static [u8] = &
            [56,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(130, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),
            (GrammarNonTerminals::__TermSet26Plus27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(131, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [58, 59, 100, 101, 102, 103, 104, 105, 106,
            107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
            122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
            137, 138, 139, 140, 141, 142,]; let shifted : & 'static [u8] = & [2, 2, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![59]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![59]), ruleset : { let rules : & 'static [u8] = &
            [59,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(132, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [58, 100, 101, 102, 103, 104, 105, 106, 107,
            108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
            123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
            138, 139, 140, 142,]; let shifted : & 'static [u8] = & [3, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![58]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![58]), ruleset : { let rules : & 'static [u8] = &
            [58,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(134, true)),],
            error_shift : Some(135), eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [62, 63,]; let shifted : & 'static
            [u8] = & [2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![62]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![62]), ruleset : { let rules : & 'static [u8] = &
            [62,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(136, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [63,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![63]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![63]), ruleset : { let rules : & 'static [u8] = &
            [63,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(138, true)),],
            error_shift : Some(139), eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [60, 61,]; let shifted : & 'static
            [u8] = & [2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![60]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![60]), ruleset : { let rules : & 'static [u8] = &
            [60,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(140, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [61,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![61]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![61]), ruleset : { let rules : & 'static [u8] = &
            [61,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(75, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(76, true)),], error_shift :
            Some(142), eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::IdentOrLiteral,
            ::rusty_lr_core::parser::state::ShiftTarget::new(94, true)),
            (GrammarNonTerminals::_IdentOrLiteralPlus28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(144, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [39, 40, 54, 55, 143, 144,]; let shifted : &
            'static [u8] = & [0, 0, 2, 2, 0, 0,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(143, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [55,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![55]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![55]), ruleset : { let rules : & 'static [u8] = &
            [55,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(75, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(145, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(76, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::IdentOrLiteral,
            ::rusty_lr_core::parser::state::ShiftTarget::new(97, true)),], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [39, 40, 54, 144,]; let shifted : & 'static
            [u8] = & [0, 0, 3, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![54]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![54]), ruleset : { let rules : & 'static [u8] = &
            [54,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(147, true)),],
            error_shift : Some(148), eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [64, 65,]; let shifted : & 'static
            [u8] = & [2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![64]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![64]), ruleset : { let rules : & 'static [u8] = &
            [64,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(149, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [65,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![65]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![65]), ruleset : { let rules : & 'static [u8] = &
            [65,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(151, true)),],
            error_shift : Some(152), eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [66, 67,]; let shifted : & 'static
            [u8] = & [2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![66]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![66]), ruleset : { let rules : & 'static [u8] = &
            [66,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(153, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [67,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![67]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![67]), ruleset : { let rules : & 'static [u8] = &
            [67,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(155, true)),],
            error_shift : Some(156), eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_identPlus29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(158, true)),
            (GrammarNonTerminals::_identStar30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(160, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules
            = vec![148]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (*
            term, reduce_rules.clone()))); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [68, 69, 145, 146, 147, 148,]; let shifted : & 'static [u8] = & [2,
            2, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) |
            { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![145]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [145,]; let
            shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(157, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [69,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![69]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![69]), ruleset : { let rules : & 'static [u8] = &
            [69,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(159, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![147]; __reduce_map.extend(__rustylr_tset18.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [146, 147,]; let shifted : & 'static [u8] = & [1, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![146]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [146,]; let
            shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(161, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [68,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![68]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![68]), ruleset : { let rules : & 'static [u8] = &
            [68,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(163, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),
            (GrammarNonTerminals::__TermSet26Plus27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(164, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [70, 71, 100, 101, 102, 103, 104, 105, 106,
            107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
            122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
            137, 138, 139, 140, 141, 142,]; let shifted : & 'static [u8] = & [2, 2, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![71]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![71]), ruleset : { let rules : & 'static [u8] = &
            [71,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(165, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [70, 100, 101, 102, 103, 104, 105, 106, 107,
            108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
            123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
            138, 139, 140, 142,]; let shifted : & 'static [u8] = & [3, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![70]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![70]), ruleset : { let rules : & 'static [u8] = &
            [70,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(167, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(106, true)),
            (GrammarNonTerminals::__TermSet26Plus27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(168, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [72, 73, 100, 101, 102, 103, 104, 105, 106,
            107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
            122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
            137, 138, 139, 140, 141, 142,]; let shifted : & 'static [u8] = & [2, 2, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![73]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![73]), ruleset : { let rules : & 'static [u8] = &
            [73,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (1,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (2,
            ::rusty_lr_core::parser::state::ShiftTarget::new(169, true)), (3,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (5,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (6,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (7,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (8,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (9,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (10,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (11,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (12,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (13,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (14,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (15,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (16,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (17,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (18,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (19,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (20,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (21,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (22,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (23,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (24,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (25,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (27,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (28,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (29,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (30,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (32,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (33,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (34,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (35,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (36,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (37,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (38,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (39,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (40,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)), (41,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::_TermSet26,
            ::rusty_lr_core::parser::state::ShiftTarget::new(109, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [72, 100, 101, 102, 103, 104, 105, 106, 107,
            108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
            123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
            138, 139, 140, 142,]; let shifted : & 'static [u8] = & [3, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![72]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![72]), ruleset : { let rules : & 'static [u8] = &
            [72,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(2, ::rusty_lr_core::parser::state::ShiftTarget::new(171, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [74,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![74]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![74]), ruleset : { let rules : & 'static [u8] = &
            [74,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![75]; __reduce_map
            .extend(__rustylr_tset12.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![75]), ruleset : { let rules : & 'static [u8] = &
            [75,]; let shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr_core::rule::ShiftedRuleRef
            { rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![(0, ::rusty_lr_core::parser::state::ShiftTarget::new(1, true)), (4,
            ::rusty_lr_core::parser::state::ShiftTarget::new(90, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(GrammarNonTerminals::Rule,
            ::rusty_lr_core::parser::state::ShiftTarget::new(172, true)),
            (GrammarNonTerminals::Directive,
            ::rusty_lr_core::parser::state::ShiftTarget::new(173, false)),
            (GrammarNonTerminals::GrammarLine,
            ::rusty_lr_core::parser::state::ShiftTarget::new(173, true)),
            (GrammarNonTerminals::_GrammarLinePlus31,
            ::rusty_lr_core::parser::state::ShiftTarget::new(174, true)),], reduce_map :
            { let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : Some(vec![149]),
            ruleset : { let rules : & 'static [u8] = & [0, 41, 42, 43, 44, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 149, 149, 150, 150,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : Some(vec![150]), ruleset : { let rules : &
            'static [u8] = & [150,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : Some(176), shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [151,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr_core::parser::state::IntermediateState { shift_goto_map_term :
            vec![], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [151,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr_core::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
        ];
        let states: Vec<GrammarState> = states
            .into_iter()
            .map(|state| state.into())
            .collect();
        Self {
            rules,
            states,
            classes: vec![
                vec!["ident",], vec!["colon",], vec!["semicolon",], vec!["pipe",],
                vec!["percent",], vec!["equal",], vec!["plus",], vec!["star",],
                vec!["question",], vec!["caret",], vec!["minus",], vec!["exclamation",],
                vec!["slash",], vec!["dot",], vec!["dollar",], vec!["comma",],
                vec!["literal",], vec!["parengroup",], vec!["bracegroup",],
                vec!["lparen",], vec!["rparen",], vec!["lbracket",], vec!["rbracket",],
                vec!["left",], vec!["right",], vec!["token",], vec!["start",],
                vec!["tokentype",], vec!["userdata",], vec!["errortype",],
                vec!["moduleprefix",], vec!["lalr",], vec!["glr",], vec!["prec",],
                vec!["precedence",], vec!["nooptim",], vec!["dense",], vec!["trace",],
                vec!["dprec",], vec!["filter",], vec!["location",],
            ],
        }
    }
}

// ==============================Generated Codes End===============================
        