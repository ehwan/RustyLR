// This file was generated by rustylr 0.6.3
//
// Input file: ../rusty_lr_parser/src/parser/parser copy.rs
// Output file: parser_expanded.rs
// ================================User Codes Begin================================
use crate::parser::args::GrammarArgs;
use crate::parser::args::PatternArgs;
use crate::parser::args::ReduceTypeArgs;
use crate::parser::args::RuleDefArgs;
use crate::parser::args::RuleLineArgs;
use crate::parser::lexer::Lexed;
use crate::terminalset::TerminalSet;
use crate::terminalset::TerminalSetItem;
use proc_macro2::Group;
use proc_macro2::Ident;
use proc_macro2::Span;
use proc_macro2::TokenStream;
use quote::ToTokens;
use rusty_lr_core::ReduceType;
use std::boxed::Box;
// =================================User Codes End=================================
/*
====================================Grammar=====================================
Rule -> ident RuleType colon RuleLines semicolon
RuleType -> parengroup
RuleType ->
RuleLines -> RuleLines pipe RuleLine
RuleLines -> RuleLine
RuleLine -> _RustyLRGenerated0 Action
_RustyLRGenerated1 -> TokenMapped
_RustyLRGenerated1 -> _RustyLRGenerated1 TokenMapped
_RustyLRGenerated0 -> _RustyLRGenerated1
_RustyLRGenerated0 ->
TokenMapped -> Pattern
TokenMapped -> ident equal Pattern
TerminalSetItem -> ident
TerminalSetItem -> ident minus ident
TerminalSet -> lbracket _RustyLRGenerated2 _RustyLRGenerated3 rbracket
_RustyLRGenerated2 -> caret
_RustyLRGenerated2 ->
_RustyLRGenerated4 -> TerminalSetItem
_RustyLRGenerated4 -> _RustyLRGenerated4 TerminalSetItem
_RustyLRGenerated3 -> _RustyLRGenerated4
_RustyLRGenerated3 ->
Pattern -> ident
Pattern -> Pattern plus
Pattern -> Pattern star
Pattern -> Pattern question
Pattern -> Pattern exclamation
Pattern -> TerminalSet
Action -> bracegroup
Action ->
TokenDef -> token ident RustCode semicolon
RustCode -> _RustyLRGenerated5
_RustyLRGenerated6 -> bracegroup
_RustyLRGenerated6 -> bracketgroup
_RustyLRGenerated6 -> caret
_RustyLRGenerated6 -> colon
_RustyLRGenerated6 -> equal
_RustyLRGenerated6 -> exclamation
_RustyLRGenerated6 -> ident
_RustyLRGenerated6 -> literal
_RustyLRGenerated6 -> minus
_RustyLRGenerated6 -> nonegroup
_RustyLRGenerated6 -> otherpunct
_RustyLRGenerated6 -> parengroup
_RustyLRGenerated6 -> percent
_RustyLRGenerated6 -> pipe
_RustyLRGenerated6 -> plus
_RustyLRGenerated6 -> question
_RustyLRGenerated6 -> star
_RustyLRGenerated5 -> _RustyLRGenerated6
_RustyLRGenerated5 -> _RustyLRGenerated5 _RustyLRGenerated6
StartDef -> start ident semicolon
EofDef -> eofdef RustCode semicolon
TokenTypeDef -> tokentype RustCode semicolon
UserDataDef -> userdata RustCode semicolon
ReduceType -> left
ReduceType -> right
ReduceDef -> ReduceType ident semicolon
ReduceDef -> ReduceType TerminalSet semicolon
ErrorDef -> errortype RustCode semicolon
ModulePrefixDef -> moduleprefix RustCode semicolon
Grammar -> Grammar Rule
Grammar -> Rule
Grammar -> Grammar TokenDef
Grammar -> TokenDef
Grammar -> Grammar StartDef
Grammar -> StartDef
Grammar -> Grammar EofDef
Grammar -> EofDef
Grammar -> Grammar TokenTypeDef
Grammar -> TokenTypeDef
Grammar -> Grammar UserDataDef
Grammar -> UserDataDef
Grammar -> Grammar ReduceDef
Grammar -> ReduceDef
Grammar -> Grammar ErrorDef
Grammar -> ErrorDef
Grammar -> Grammar ModulePrefixDef
Grammar -> ModulePrefixDef
Augmented -> Grammar eof

*/
// =============================Generated Codes Begin==============================
#[doc = r" type alias for CFG production rule"]
#[allow(non_camel_case_types, dead_code)]
pub type GrammarRule = ::rusty_lr_core::ProductionRule<Lexed, GrammarNonTerminals>;
#[doc = r" type alias for DFA state"]
#[allow(non_camel_case_types, dead_code)]
pub type GrammarState = ::rusty_lr_core::State<Lexed, GrammarNonTerminals>;
#[doc = r" type alias for `ParseError`"]
#[allow(non_camel_case_types, dead_code)]
pub type GrammarParseError = ::rusty_lr_core::ParseError<Lexed, String>;
#[doc = r" type alias for `InvalidTerminalError`"]
#[allow(non_camel_case_types, dead_code)]
pub type GrammarInvalidTerminalError = ::rusty_lr_core::InvalidTerminalError<Lexed>;
#[doc = r" An enum that represents non-terminal symbols"]
#[allow(non_camel_case_types)]
#[derive(
    Debug,
    Clone,
    Copy,
    std :: hash :: Hash,
    std :: cmp :: PartialEq,
    std :: cmp :: Eq,
    std :: cmp :: PartialOrd,
    std :: cmp :: Ord,
)]
pub enum GrammarNonTerminals {
    Rule,
    RuleType,
    RuleLines,
    RuleLine,
    _RustyLRGenerated1,
    _RustyLRGenerated0,
    TokenMapped,
    TerminalSetItem,
    TerminalSet,
    _RustyLRGenerated2,
    _RustyLRGenerated4,
    _RustyLRGenerated3,
    Pattern,
    Action,
    TokenDef,
    RustCode,
    _RustyLRGenerated6,
    _RustyLRGenerated5,
    StartDef,
    EofDef,
    TokenTypeDef,
    UserDataDef,
    ReduceType,
    ReduceDef,
    ErrorDef,
    ModulePrefixDef,
    Grammar,
    Augmented,
}
impl std::fmt::Display for GrammarNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GrammarNonTerminals::Rule => write!(f, "Rule"),
            GrammarNonTerminals::RuleType => write!(f, "RuleType"),
            GrammarNonTerminals::RuleLines => write!(f, "RuleLines"),
            GrammarNonTerminals::RuleLine => write!(f, "RuleLine"),
            GrammarNonTerminals::_RustyLRGenerated1 => write!(f, "_RustyLRGenerated1"),
            GrammarNonTerminals::_RustyLRGenerated0 => write!(f, "_RustyLRGenerated0"),
            GrammarNonTerminals::TokenMapped => write!(f, "TokenMapped"),
            GrammarNonTerminals::TerminalSetItem => write!(f, "TerminalSetItem"),
            GrammarNonTerminals::TerminalSet => write!(f, "TerminalSet"),
            GrammarNonTerminals::_RustyLRGenerated2 => write!(f, "_RustyLRGenerated2"),
            GrammarNonTerminals::_RustyLRGenerated4 => write!(f, "_RustyLRGenerated4"),
            GrammarNonTerminals::_RustyLRGenerated3 => write!(f, "_RustyLRGenerated3"),
            GrammarNonTerminals::Pattern => write!(f, "Pattern"),
            GrammarNonTerminals::Action => write!(f, "Action"),
            GrammarNonTerminals::TokenDef => write!(f, "TokenDef"),
            GrammarNonTerminals::RustCode => write!(f, "RustCode"),
            GrammarNonTerminals::_RustyLRGenerated6 => write!(f, "_RustyLRGenerated6"),
            GrammarNonTerminals::_RustyLRGenerated5 => write!(f, "_RustyLRGenerated5"),
            GrammarNonTerminals::StartDef => write!(f, "StartDef"),
            GrammarNonTerminals::EofDef => write!(f, "EofDef"),
            GrammarNonTerminals::TokenTypeDef => write!(f, "TokenTypeDef"),
            GrammarNonTerminals::UserDataDef => write!(f, "UserDataDef"),
            GrammarNonTerminals::ReduceType => write!(f, "ReduceType"),
            GrammarNonTerminals::ReduceDef => write!(f, "ReduceDef"),
            GrammarNonTerminals::ErrorDef => write!(f, "ErrorDef"),
            GrammarNonTerminals::ModulePrefixDef => write!(f, "ModulePrefixDef"),
            GrammarNonTerminals::Grammar => write!(f, "Grammar"),
            GrammarNonTerminals::Augmented => write!(f, "Augmented"),
        }
    }
}
#[doc = r" struct that holds internal parser data, for reduce action and state transition"]
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
pub struct GrammarContext {
    #[doc = r" state stack, user must not modify this"]
    pub state_stack: Vec<usize>,
    __rustylr_generated_terminal_stack: Vec<Lexed>,
    _rustylr_generated_Rule_stack: Vec<(RuleDefArgs)>,
    _rustylr_generated_RuleType_stack: Vec<(Option<Group>)>,
    _rustylr_generated_RuleLines_stack: Vec<(Vec<RuleLineArgs>)>,
    _rustylr_generated_RuleLine_stack: Vec<(RuleLineArgs)>,
    _rustylr_generated__RustyLRGenerated1_stack: Vec<Vec<((Option<Ident>, PatternArgs))>>,
    _rustylr_generated__RustyLRGenerated0_stack: Vec<Vec<((Option<Ident>, PatternArgs))>>,
    _rustylr_generated_TokenMapped_stack: Vec<((Option<Ident>, PatternArgs))>,
    _rustylr_generated_TerminalSetItem_stack: Vec<(TerminalSetItem)>,
    _rustylr_generated_TerminalSet_stack: Vec<(TerminalSet)>,
    _rustylr_generated__RustyLRGenerated2_stack: Vec<Option<Lexed>>,
    _rustylr_generated__RustyLRGenerated4_stack: Vec<Vec<(TerminalSetItem)>>,
    _rustylr_generated__RustyLRGenerated3_stack: Vec<Vec<(TerminalSetItem)>>,
    _rustylr_generated_Pattern_stack: Vec<(PatternArgs)>,
    _rustylr_generated_Action_stack: Vec<(Option<Group>)>,
    _rustylr_generated_TokenDef_stack: Vec<((Ident, TokenStream))>,
    _rustylr_generated_RustCode_stack: Vec<(TokenStream)>,
    _rustylr_generated__RustyLRGenerated6_stack: Vec<Lexed>,
    _rustylr_generated__RustyLRGenerated5_stack: Vec<Vec<Lexed>>,
    _rustylr_generated_StartDef_stack: Vec<(Ident)>,
    _rustylr_generated_EofDef_stack: Vec<((Span, TokenStream))>,
    _rustylr_generated_TokenTypeDef_stack: Vec<((Span, TokenStream))>,
    _rustylr_generated_UserDataDef_stack: Vec<((Span, TokenStream))>,
    _rustylr_generated_ReduceType_stack: Vec<(ReduceType)>,
    _rustylr_generated_ReduceDef_stack: Vec<((ReduceTypeArgs, ReduceType))>,
    _rustylr_generated_ErrorDef_stack: Vec<((Span, TokenStream))>,
    _rustylr_generated_ModulePrefixDef_stack: Vec<((Span, TokenStream))>,
    _rustylr_generated_Grammar_stack: Vec<(GrammarArgs)>,
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
impl GrammarContext {
    pub fn new() -> Self {
        Self {
            state_stack: vec![0],
            __rustylr_generated_terminal_stack: Vec::new(),
            _rustylr_generated_Rule_stack: Vec::new(),
            _rustylr_generated_RuleType_stack: Vec::new(),
            _rustylr_generated_RuleLines_stack: Vec::new(),
            _rustylr_generated_RuleLine_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated1_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated0_stack: Vec::new(),
            _rustylr_generated_TokenMapped_stack: Vec::new(),
            _rustylr_generated_TerminalSetItem_stack: Vec::new(),
            _rustylr_generated_TerminalSet_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated2_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated4_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated3_stack: Vec::new(),
            _rustylr_generated_Pattern_stack: Vec::new(),
            _rustylr_generated_Action_stack: Vec::new(),
            _rustylr_generated_TokenDef_stack: Vec::new(),
            _rustylr_generated_RustCode_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated6_stack: Vec::new(),
            _rustylr_generated__RustyLRGenerated5_stack: Vec::new(),
            _rustylr_generated_StartDef_stack: Vec::new(),
            _rustylr_generated_EofDef_stack: Vec::new(),
            _rustylr_generated_TokenTypeDef_stack: Vec::new(),
            _rustylr_generated_UserDataDef_stack: Vec::new(),
            _rustylr_generated_ReduceType_stack: Vec::new(),
            _rustylr_generated_ReduceDef_stack: Vec::new(),
            _rustylr_generated_ErrorDef_stack: Vec::new(),
            _rustylr_generated_ModulePrefixDef_stack: Vec::new(),
            _rustylr_generated_Grammar_stack: Vec::new(),
        }
    }
    fn reduce_Rule_0(&mut self) -> Result<(), String> {
        let mut semicolon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut RuleLines = self._rustylr_generated_RuleLines_stack.pop().unwrap();
        let mut colon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut RuleType = self._rustylr_generated_RuleType_stack.pop().unwrap();
        let mut ident = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_Rule_stack.push({
            let ident = if let Lexed::Ident(ident) = ident {
                ident.unwrap()
            } else {
                unreachable!("Rule-Ident");
            };
            if let Lexed::Colon(colon) = colon {
                let span = colon.unwrap().span();
                if let Some(fisrt) = RuleLines.first_mut() {
                    fisrt.separator_span = span;
                }
            } else {
                unreachable!("Rule-Colon2");
            }
            RuleDefArgs {
                name: ident,
                typename: RuleType.map(|t| t.to_token_stream()),
                rule_lines: RuleLines,
            }
        });
        Ok(())
    }
    fn reduce_RuleType_0(&mut self) -> Result<(), String> {
        let mut parengroup = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_RuleType_stack.push({
            if let Lexed::ParenGroup(group) = parengroup {
                group
            } else {
                unreachable!("RuleType - Group");
            }
        });
        Ok(())
    }
    fn reduce_RuleType_1(&mut self) -> Result<(), String> {
        self._rustylr_generated_RuleType_stack.push({ None });
        Ok(())
    }
    fn reduce_RuleLines_0(&mut self) -> Result<(), String> {
        let mut RuleLine = self._rustylr_generated_RuleLine_stack.pop().unwrap();
        let mut pipe = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut RuleLines = self._rustylr_generated_RuleLines_stack.pop().unwrap();
        self._rustylr_generated_RuleLines_stack.push({
            if let Lexed::Pipe(punct) = pipe {
                RuleLine.separator_span = punct.unwrap().span();
                RuleLines.push(RuleLine);
            }
            RuleLines
        });
        Ok(())
    }
    fn reduce_RuleLines_1(&mut self) -> Result<(), String> {
        let mut RuleLine = self._rustylr_generated_RuleLine_stack.pop().unwrap();
        self._rustylr_generated_RuleLines_stack
            .push({ vec![RuleLine] });
        Ok(())
    }
    fn reduce_RuleLine_0(&mut self) -> Result<(), String> {
        let mut Action = self._rustylr_generated_Action_stack.pop().unwrap();
        let mut TokenMapped = self
            ._rustylr_generated__RustyLRGenerated0_stack
            .pop()
            .unwrap();
        self._rustylr_generated_RuleLine_stack.push({
            RuleLineArgs {
                tokens: TokenMapped,
                reduce_action: Action.map(|action| action.to_token_stream()),
                separator_span: Span::call_site(),
            }
        });
        Ok(())
    }
    fn reduce__RustyLRGenerated1_0(&mut self) -> Result<(), String> {
        let mut A = self._rustylr_generated_TokenMapped_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated1_stack
            .push({ vec![A] });
        Ok(())
    }
    fn reduce__RustyLRGenerated1_1(&mut self) -> Result<(), String> {
        let mut A = self._rustylr_generated_TokenMapped_stack.pop().unwrap();
        let mut Ap = self
            ._rustylr_generated__RustyLRGenerated1_stack
            .pop()
            .unwrap();
        self._rustylr_generated__RustyLRGenerated1_stack.push({
            Ap.push(A);
            Ap
        });
        Ok(())
    }
    fn reduce__RustyLRGenerated0_0(&mut self) -> Result<(), String> {
        let mut Ap = self
            ._rustylr_generated__RustyLRGenerated1_stack
            .pop()
            .unwrap();
        self._rustylr_generated__RustyLRGenerated0_stack
            .push({ Ap });
        Ok(())
    }
    fn reduce__RustyLRGenerated0_1(&mut self) -> Result<(), String> {
        self._rustylr_generated__RustyLRGenerated0_stack
            .push({ vec![] });
        Ok(())
    }
    fn reduce_TokenMapped_0(&mut self) -> Result<(), String> {
        let mut Pattern = self._rustylr_generated_Pattern_stack.pop().unwrap();
        self._rustylr_generated_TokenMapped_stack
            .push({ (None, Pattern) });
        Ok(())
    }
    fn reduce_TokenMapped_1(&mut self) -> Result<(), String> {
        let mut Pattern = self._rustylr_generated_Pattern_stack.pop().unwrap();
        let mut equal = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut ident = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_TokenMapped_stack.push({
            if let Lexed::Ident(ident) = ident {
                (ident, Pattern)
            } else {
                unreachable!("Token-Ident");
            }
        });
        Ok(())
    }
    fn reduce_TerminalSetItem_0(&mut self) -> Result<(), String> {
        let mut ident = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_TerminalSetItem_stack.push({
            let ident = if let Lexed::Ident(ident) = ident {
                ident.unwrap()
            } else {
                unreachable!("TerminalSetItem-Range1");
            };
            TerminalSetItem::Terminal(ident)
        });
        Ok(())
    }
    fn reduce_TerminalSetItem_1(&mut self) -> Result<(), String> {
        let mut last = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut minus = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut first = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_TerminalSetItem_stack.push({
            let first = if let Lexed::Ident(first) = first {
                first.unwrap()
            } else {
                unreachable!("TerminalSetItem-Range1");
            };
            let last = if let Lexed::Ident(last) = last {
                last.unwrap()
            } else {
                unreachable!("TerminalSetItem-Range3");
            };
            TerminalSetItem::Range(first, last)
        });
        Ok(())
    }
    fn reduce_TerminalSet_0(&mut self) -> Result<(), String> {
        let mut rbracket = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut TerminalSetItem = self
            ._rustylr_generated__RustyLRGenerated3_stack
            .pop()
            .unwrap();
        let mut caret = self
            ._rustylr_generated__RustyLRGenerated2_stack
            .pop()
            .unwrap();
        let mut lbracket = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_TerminalSet_stack.push({
            let open_span = if let Lexed::LBracket(lbracket) = lbracket {
                lbracket.unwrap()
            } else {
                unreachable!("TerminalSet-Open");
            };
            let close_span = if let Lexed::RBracket(rbracket) = rbracket {
                rbracket.unwrap()
            } else {
                unreachable!("TerminalSet-Close");
            };
            TerminalSet {
                negate: caret.is_some(),
                items: TerminalSetItem,
                open_span,
                close_span,
            }
        });
        Ok(())
    }
    fn reduce__RustyLRGenerated2_0(&mut self) -> Result<(), String> {
        let mut A = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated2_stack
            .push({ Some(A) });
        Ok(())
    }
    fn reduce__RustyLRGenerated2_1(&mut self) -> Result<(), String> {
        self._rustylr_generated__RustyLRGenerated2_stack
            .push({ None });
        Ok(())
    }
    fn reduce__RustyLRGenerated4_0(&mut self) -> Result<(), String> {
        let mut A = self._rustylr_generated_TerminalSetItem_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated4_stack
            .push({ vec![A] });
        Ok(())
    }
    fn reduce__RustyLRGenerated4_1(&mut self) -> Result<(), String> {
        let mut A = self._rustylr_generated_TerminalSetItem_stack.pop().unwrap();
        let mut Ap = self
            ._rustylr_generated__RustyLRGenerated4_stack
            .pop()
            .unwrap();
        self._rustylr_generated__RustyLRGenerated4_stack.push({
            Ap.push(A);
            Ap
        });
        Ok(())
    }
    fn reduce__RustyLRGenerated3_0(&mut self) -> Result<(), String> {
        let mut Ap = self
            ._rustylr_generated__RustyLRGenerated4_stack
            .pop()
            .unwrap();
        self._rustylr_generated__RustyLRGenerated3_stack
            .push({ Ap });
        Ok(())
    }
    fn reduce__RustyLRGenerated3_1(&mut self) -> Result<(), String> {
        self._rustylr_generated__RustyLRGenerated3_stack
            .push({ vec![] });
        Ok(())
    }
    fn reduce_Pattern_0(&mut self) -> Result<(), String> {
        let mut ident = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_Pattern_stack.push({
            if let Lexed::Ident(ident) = ident {
                let ident = ident.unwrap();
                let span = ident.span();
                PatternArgs::Ident(ident, span)
            } else {
                unreachable!("Pattern-Ident");
            }
        });
        Ok(())
    }
    fn reduce_Pattern_1(&mut self) -> Result<(), String> {
        let mut plus = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut Pattern = self._rustylr_generated_Pattern_stack.pop().unwrap();
        self._rustylr_generated_Pattern_stack.push({
            if let Lexed::Plus(plus) = plus {
                PatternArgs::Plus(Box::new(Pattern), plus.unwrap().span())
            } else {
                unreachable!("Pattern-Plus");
            }
        });
        Ok(())
    }
    fn reduce_Pattern_2(&mut self) -> Result<(), String> {
        let mut star = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut Pattern = self._rustylr_generated_Pattern_stack.pop().unwrap();
        self._rustylr_generated_Pattern_stack.push({
            if let Lexed::Star(star) = star {
                PatternArgs::Star(Box::new(Pattern), star.unwrap().span())
            } else {
                unreachable!("Pattern-Star");
            }
        });
        Ok(())
    }
    fn reduce_Pattern_3(&mut self) -> Result<(), String> {
        let mut question = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut Pattern = self._rustylr_generated_Pattern_stack.pop().unwrap();
        self._rustylr_generated_Pattern_stack.push({
            if let Lexed::Question(question) = question {
                PatternArgs::Question(Box::new(Pattern), question.unwrap().span())
            } else {
                unreachable!("Pattern-Question");
            }
        });
        Ok(())
    }
    fn reduce_Pattern_4(&mut self) -> Result<(), String> {
        let mut exclamation = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut Pattern = self._rustylr_generated_Pattern_stack.pop().unwrap();
        self._rustylr_generated_Pattern_stack.push({
            if let Lexed::Exclamation(exclamation) = exclamation {
                PatternArgs::Exclamation(Box::new(Pattern), exclamation.unwrap().span())
            } else {
                unreachable!("Pattern-Exclamation");
            }
        });
        Ok(())
    }
    fn reduce_Pattern_5(&mut self) -> Result<(), String> {
        let mut TerminalSet = self._rustylr_generated_TerminalSet_stack.pop().unwrap();
        self._rustylr_generated_Pattern_stack
            .push({ PatternArgs::TerminalSet(TerminalSet) });
        Ok(())
    }
    fn reduce_Action_0(&mut self) -> Result<(), String> {
        let mut bracegroup = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_Action_stack.push({
            if let Lexed::BraceGroup(group) = bracegroup {
                group
            } else {
                unreachable!("Action0");
            }
        });
        Ok(())
    }
    fn reduce_Action_1(&mut self) -> Result<(), String> {
        self._rustylr_generated_Action_stack.push({ None });
        Ok(())
    }
    fn reduce_TokenDef_0(&mut self) -> Result<(), String> {
        let mut semicolon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut RustCode = self._rustylr_generated_RustCode_stack.pop().unwrap();
        let mut ident = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut token = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_TokenDef_stack.push({
            if let Lexed::Ident(ident) = ident {
                (ident.unwrap(), RustCode)
            } else {
                unreachable!("TokenDef-Ident");
            }
        });
        Ok(())
    }
    fn reduce_RustCode_0(&mut self) -> Result<(), String> {
        let mut t = self
            ._rustylr_generated__RustyLRGenerated5_stack
            .pop()
            .unwrap();
        self._rustylr_generated_RustCode_stack.push({
            let mut tokens = TokenStream::new();
            for token in t.into_iter() {
                tokens.extend(token.stream());
            }
            tokens
        });
        Ok(())
    }
    fn reduce__RustyLRGenerated6_0(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_1(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_2(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_3(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_4(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_5(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_6(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_7(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_8(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_9(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_10(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_11(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_12(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_13(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_14(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_15(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated6_16(&mut self) -> Result<(), String> {
        let mut term = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated__RustyLRGenerated6_stack.push(term);
        Ok(())
    }
    fn reduce__RustyLRGenerated5_0(&mut self) -> Result<(), String> {
        let mut A = self
            ._rustylr_generated__RustyLRGenerated6_stack
            .pop()
            .unwrap();
        self._rustylr_generated__RustyLRGenerated5_stack
            .push({ vec![A] });
        Ok(())
    }
    fn reduce__RustyLRGenerated5_1(&mut self) -> Result<(), String> {
        let mut A = self
            ._rustylr_generated__RustyLRGenerated6_stack
            .pop()
            .unwrap();
        let mut Ap = self
            ._rustylr_generated__RustyLRGenerated5_stack
            .pop()
            .unwrap();
        self._rustylr_generated__RustyLRGenerated5_stack.push({
            Ap.push(A);
            Ap
        });
        Ok(())
    }
    fn reduce_StartDef_0(&mut self) -> Result<(), String> {
        let mut semicolon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut ident = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut start = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_StartDef_stack.push({
            if let Lexed::Ident(ident) = ident {
                ident.unwrap()
            } else {
                unreachable!("StartDef-Ident");
            }
        });
        Ok(())
    }
    fn reduce_EofDef_0(&mut self) -> Result<(), String> {
        let mut semicolon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut RustCode = self._rustylr_generated_RustCode_stack.pop().unwrap();
        let mut eofdef = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_EofDef_stack
            .push({ (eofdef.span().unwrap(), RustCode) });
        Ok(())
    }
    fn reduce_TokenTypeDef_0(&mut self) -> Result<(), String> {
        let mut semicolon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut RustCode = self._rustylr_generated_RustCode_stack.pop().unwrap();
        let mut tokentype = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_TokenTypeDef_stack
            .push({ (tokentype.span().unwrap(), RustCode) });
        Ok(())
    }
    fn reduce_UserDataDef_0(&mut self) -> Result<(), String> {
        let mut semicolon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut RustCode = self._rustylr_generated_RustCode_stack.pop().unwrap();
        let mut userdata = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_UserDataDef_stack
            .push({ (userdata.span().unwrap(), RustCode) });
        Ok(())
    }
    fn reduce_ReduceType_0(&mut self) -> Result<(), String> {
        let mut left = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_ReduceType_stack
            .push({ ReduceType::Left });
        Ok(())
    }
    fn reduce_ReduceType_1(&mut self) -> Result<(), String> {
        let mut right = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_ReduceType_stack
            .push({ ReduceType::Right });
        Ok(())
    }
    fn reduce_ReduceDef_0(&mut self) -> Result<(), String> {
        let mut semicolon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut ident = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut reducetype = self._rustylr_generated_ReduceType_stack.pop().unwrap();
        self._rustylr_generated_ReduceDef_stack.push({
            if let Lexed::Ident(ident) = ident {
                (ReduceTypeArgs::Ident(ident.unwrap()), reducetype)
            } else {
                unreachable!("ReduceDef-Ident (Left)");
            }
        });
        Ok(())
    }
    fn reduce_ReduceDef_1(&mut self) -> Result<(), String> {
        let mut semicolon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut TerminalSet = self._rustylr_generated_TerminalSet_stack.pop().unwrap();
        let mut reducetype = self._rustylr_generated_ReduceType_stack.pop().unwrap();
        self._rustylr_generated_ReduceDef_stack
            .push({ (ReduceTypeArgs::TerminalSet(TerminalSet), reducetype) });
        Ok(())
    }
    fn reduce_ErrorDef_0(&mut self) -> Result<(), String> {
        let mut semicolon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut RustCode = self._rustylr_generated_RustCode_stack.pop().unwrap();
        let mut errortype = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_ErrorDef_stack
            .push({ (errortype.span().unwrap(), RustCode) });
        Ok(())
    }
    fn reduce_ModulePrefixDef_0(&mut self) -> Result<(), String> {
        let mut semicolon = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut RustCode = self._rustylr_generated_RustCode_stack.pop().unwrap();
        let mut moduleprefix = self.__rustylr_generated_terminal_stack.pop().unwrap();
        self._rustylr_generated_ModulePrefixDef_stack
            .push({ (moduleprefix.span().unwrap(), RustCode) });
        Ok(())
    }
    fn reduce_Grammar_0(&mut self) -> Result<(), String> {
        let mut Rule = self._rustylr_generated_Rule_stack.pop().unwrap();
        let mut Grammar = self._rustylr_generated_Grammar_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            Grammar.rules.push(Rule);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_1(&mut self) -> Result<(), String> {
        let mut Rule = self._rustylr_generated_Rule_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.rules.push(Rule);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_2(&mut self) -> Result<(), String> {
        let mut TokenDef = self._rustylr_generated_TokenDef_stack.pop().unwrap();
        let mut Grammar = self._rustylr_generated_Grammar_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            Grammar.terminals.push(TokenDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_3(&mut self) -> Result<(), String> {
        let mut TokenDef = self._rustylr_generated_TokenDef_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.terminals.push(TokenDef);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_4(&mut self) -> Result<(), String> {
        let mut StartDef = self._rustylr_generated_StartDef_stack.pop().unwrap();
        let mut Grammar = self._rustylr_generated_Grammar_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            Grammar.start_rule_name.push(StartDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_5(&mut self) -> Result<(), String> {
        let mut StartDef = self._rustylr_generated_StartDef_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.start_rule_name.push(StartDef);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_6(&mut self) -> Result<(), String> {
        let mut EofDef = self._rustylr_generated_EofDef_stack.pop().unwrap();
        let mut Grammar = self._rustylr_generated_Grammar_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            Grammar.eof.push(EofDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_7(&mut self) -> Result<(), String> {
        let mut EofDef = self._rustylr_generated_EofDef_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.eof.push(EofDef);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_8(&mut self) -> Result<(), String> {
        let mut TokenTypeDef = self._rustylr_generated_TokenTypeDef_stack.pop().unwrap();
        let mut Grammar = self._rustylr_generated_Grammar_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            Grammar.token_typename.push(TokenTypeDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_9(&mut self) -> Result<(), String> {
        let mut TokenTypeDef = self._rustylr_generated_TokenTypeDef_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.token_typename.push(TokenTypeDef);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_10(&mut self) -> Result<(), String> {
        let mut UserDataDef = self._rustylr_generated_UserDataDef_stack.pop().unwrap();
        let mut Grammar = self._rustylr_generated_Grammar_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            Grammar.userdata_typename.push(UserDataDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_11(&mut self) -> Result<(), String> {
        let mut UserDataDef = self._rustylr_generated_UserDataDef_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.userdata_typename.push(UserDataDef);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_12(&mut self) -> Result<(), String> {
        let mut ReduceDef = self._rustylr_generated_ReduceDef_stack.pop().unwrap();
        let mut Grammar = self._rustylr_generated_Grammar_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            Grammar.reduce_types.push(ReduceDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_13(&mut self) -> Result<(), String> {
        let mut ReduceDef = self._rustylr_generated_ReduceDef_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.reduce_types.push(ReduceDef);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_14(&mut self) -> Result<(), String> {
        let mut ErrorDef = self._rustylr_generated_ErrorDef_stack.pop().unwrap();
        let mut Grammar = self._rustylr_generated_Grammar_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            Grammar.error_typename.push(ErrorDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_15(&mut self) -> Result<(), String> {
        let mut ErrorDef = self._rustylr_generated_ErrorDef_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.error_typename.push(ErrorDef);
            g
        });
        Ok(())
    }
    fn reduce_Grammar_16(&mut self) -> Result<(), String> {
        let mut ModulePrefixDef = self._rustylr_generated_ModulePrefixDef_stack.pop().unwrap();
        let mut Grammar = self._rustylr_generated_Grammar_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            Grammar.module_prefix.push(ModulePrefixDef);
            Grammar
        });
        Ok(())
    }
    fn reduce_Grammar_17(&mut self) -> Result<(), String> {
        let mut ModulePrefixDef = self._rustylr_generated_ModulePrefixDef_stack.pop().unwrap();
        self._rustylr_generated_Grammar_stack.push({
            let mut g: GrammarArgs = Default::default();
            g.module_prefix.push(ModulePrefixDef);
            g
        });
        Ok(())
    }
    fn reduce_Augmented_0(&mut self) -> Result<(), String> {
        let mut eof = self.__rustylr_generated_terminal_stack.pop().unwrap();
        let mut Grammar = self._rustylr_generated_Grammar_stack.pop().unwrap();
        Ok(())
    }
    #[doc = r" reduce items in stack, this function is called automatically by parser"]
    pub fn reduce(
        &mut self,
        rulelen: usize,
        rustylr_macro_generated_ruleid__: usize,
    ) -> Result<(), String> {
        match rustylr_macro_generated_ruleid__ {
            0usize => {
                self.reduce_Rule_0()?;
            }
            1usize => {
                self.reduce_RuleType_0()?;
            }
            2usize => {
                self.reduce_RuleType_1()?;
            }
            3usize => {
                self.reduce_RuleLines_0()?;
            }
            4usize => {
                self.reduce_RuleLines_1()?;
            }
            5usize => {
                self.reduce_RuleLine_0()?;
            }
            6usize => {
                self.reduce__RustyLRGenerated1_0()?;
            }
            7usize => {
                self.reduce__RustyLRGenerated1_1()?;
            }
            8usize => {
                self.reduce__RustyLRGenerated0_0()?;
            }
            9usize => {
                self.reduce__RustyLRGenerated0_1()?;
            }
            10usize => {
                self.reduce_TokenMapped_0()?;
            }
            11usize => {
                self.reduce_TokenMapped_1()?;
            }
            12usize => {
                self.reduce_TerminalSetItem_0()?;
            }
            13usize => {
                self.reduce_TerminalSetItem_1()?;
            }
            14usize => {
                self.reduce_TerminalSet_0()?;
            }
            15usize => {
                self.reduce__RustyLRGenerated2_0()?;
            }
            16usize => {
                self.reduce__RustyLRGenerated2_1()?;
            }
            17usize => {
                self.reduce__RustyLRGenerated4_0()?;
            }
            18usize => {
                self.reduce__RustyLRGenerated4_1()?;
            }
            19usize => {
                self.reduce__RustyLRGenerated3_0()?;
            }
            20usize => {
                self.reduce__RustyLRGenerated3_1()?;
            }
            21usize => {
                self.reduce_Pattern_0()?;
            }
            22usize => {
                self.reduce_Pattern_1()?;
            }
            23usize => {
                self.reduce_Pattern_2()?;
            }
            24usize => {
                self.reduce_Pattern_3()?;
            }
            25usize => {
                self.reduce_Pattern_4()?;
            }
            26usize => {
                self.reduce_Pattern_5()?;
            }
            27usize => {
                self.reduce_Action_0()?;
            }
            28usize => {
                self.reduce_Action_1()?;
            }
            29usize => {
                self.reduce_TokenDef_0()?;
            }
            30usize => {
                self.reduce_RustCode_0()?;
            }
            31usize => {
                self.reduce__RustyLRGenerated6_0()?;
            }
            32usize => {
                self.reduce__RustyLRGenerated6_1()?;
            }
            33usize => {
                self.reduce__RustyLRGenerated6_2()?;
            }
            34usize => {
                self.reduce__RustyLRGenerated6_3()?;
            }
            35usize => {
                self.reduce__RustyLRGenerated6_4()?;
            }
            36usize => {
                self.reduce__RustyLRGenerated6_5()?;
            }
            37usize => {
                self.reduce__RustyLRGenerated6_6()?;
            }
            38usize => {
                self.reduce__RustyLRGenerated6_7()?;
            }
            39usize => {
                self.reduce__RustyLRGenerated6_8()?;
            }
            40usize => {
                self.reduce__RustyLRGenerated6_9()?;
            }
            41usize => {
                self.reduce__RustyLRGenerated6_10()?;
            }
            42usize => {
                self.reduce__RustyLRGenerated6_11()?;
            }
            43usize => {
                self.reduce__RustyLRGenerated6_12()?;
            }
            44usize => {
                self.reduce__RustyLRGenerated6_13()?;
            }
            45usize => {
                self.reduce__RustyLRGenerated6_14()?;
            }
            46usize => {
                self.reduce__RustyLRGenerated6_15()?;
            }
            47usize => {
                self.reduce__RustyLRGenerated6_16()?;
            }
            48usize => {
                self.reduce__RustyLRGenerated5_0()?;
            }
            49usize => {
                self.reduce__RustyLRGenerated5_1()?;
            }
            50usize => {
                self.reduce_StartDef_0()?;
            }
            51usize => {
                self.reduce_EofDef_0()?;
            }
            52usize => {
                self.reduce_TokenTypeDef_0()?;
            }
            53usize => {
                self.reduce_UserDataDef_0()?;
            }
            54usize => {
                self.reduce_ReduceType_0()?;
            }
            55usize => {
                self.reduce_ReduceType_1()?;
            }
            56usize => {
                self.reduce_ReduceDef_0()?;
            }
            57usize => {
                self.reduce_ReduceDef_1()?;
            }
            58usize => {
                self.reduce_ErrorDef_0()?;
            }
            59usize => {
                self.reduce_ModulePrefixDef_0()?;
            }
            60usize => {
                self.reduce_Grammar_0()?;
            }
            61usize => {
                self.reduce_Grammar_1()?;
            }
            62usize => {
                self.reduce_Grammar_2()?;
            }
            63usize => {
                self.reduce_Grammar_3()?;
            }
            64usize => {
                self.reduce_Grammar_4()?;
            }
            65usize => {
                self.reduce_Grammar_5()?;
            }
            66usize => {
                self.reduce_Grammar_6()?;
            }
            67usize => {
                self.reduce_Grammar_7()?;
            }
            68usize => {
                self.reduce_Grammar_8()?;
            }
            69usize => {
                self.reduce_Grammar_9()?;
            }
            70usize => {
                self.reduce_Grammar_10()?;
            }
            71usize => {
                self.reduce_Grammar_11()?;
            }
            72usize => {
                self.reduce_Grammar_12()?;
            }
            73usize => {
                self.reduce_Grammar_13()?;
            }
            74usize => {
                self.reduce_Grammar_14()?;
            }
            75usize => {
                self.reduce_Grammar_15()?;
            }
            76usize => {
                self.reduce_Grammar_16()?;
            }
            77usize => {
                self.reduce_Grammar_17()?;
            }
            78usize => {
                self.reduce_Augmented_0()?;
            }
            _ => {
                unreachable!("Invalid Rule: {}", rustylr_macro_generated_ruleid__);
            }
        }
        Ok(())
    }
    #[doc = r" pop value from start rule"]
    pub fn accept(&mut self) -> (GrammarArgs) {
        self._rustylr_generated_Grammar_stack.pop().unwrap()
    }
    #[doc = r" push terminal symbol to stack, this function is called automatically by parser"]
    pub fn push(&mut self, term: Lexed) {
        self.__rustylr_generated_terminal_stack.push(term);
    }
}
impl ::rusty_lr_core::GetContext<Lexed, GrammarNonTerminals> for GrammarContext {
    fn get_state_stack(&self) -> &[usize] {
        &self.state_stack
    }
}
#[doc = r" struct that holds parser data, DFA tables"]
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
pub struct GrammarParser {
    #[doc = r" production rules"]
    pub rules: Vec<GrammarRule>,
    #[doc = r" states"]
    pub states: Vec<GrammarState>,
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
impl GrammarParser {
    pub fn new() -> Self {
        let rules = vec![
            GrammarRule {
                name: GrammarNonTerminals::Rule,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleType),
                    ::rusty_lr_core::Token::Term(Lexed::Colon(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleLines),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::RuleType,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::ParenGroup(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::RuleType,
                rule: vec![],
            },
            GrammarRule {
                name: GrammarNonTerminals::RuleLines,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleLines),
                    ::rusty_lr_core::Token::Term(Lexed::Pipe(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RuleLine),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::RuleLines,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::RuleLine,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::RuleLine,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated0),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Action),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated1,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::TokenMapped,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated1,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated1),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TokenMapped),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated0,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::_RustyLRGenerated1,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated0,
                rule: vec![],
            },
            GrammarRule {
                name: GrammarNonTerminals::TokenMapped,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::Pattern,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::TokenMapped,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Equal(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::TerminalSetItem,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Ident(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::TerminalSetItem,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Minus(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::TerminalSet,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::LBracket(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated2),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated3),
                    ::rusty_lr_core::Token::Term(Lexed::RBracket(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated2,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Caret(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated2,
                rule: vec![],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated4,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::TerminalSetItem,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated4,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated4),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TerminalSetItem),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated3,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::_RustyLRGenerated4,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated3,
                rule: vec![],
            },
            GrammarRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Ident(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
                    ::rusty_lr_core::Token::Term(Lexed::Plus(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
                    ::rusty_lr_core::Token::Term(Lexed::Star(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
                    ::rusty_lr_core::Token::Term(Lexed::Question(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Pattern),
                    ::rusty_lr_core::Token::Term(Lexed::Exclamation(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Pattern,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::TerminalSet,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::Action,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::BraceGroup(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::Action,
                rule: vec![],
            },
            GrammarRule {
                name: GrammarNonTerminals::TokenDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::Token(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::RustCode,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::_RustyLRGenerated5,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::BraceGroup(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::BracketGroup(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Caret(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Colon(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Equal(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Exclamation(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Ident(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Literal(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Minus(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::NoneGroup(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::OtherPunct(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::ParenGroup(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Percent(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Pipe(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Plus(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Question(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated6,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Star(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::_RustyLRGenerated6,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::_RustyLRGenerated5,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated5),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::_RustyLRGenerated6),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::StartDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::Start(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::EofDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::EofDef(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::TokenTypeDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::TokenType(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::UserDataDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::UserData(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::ReduceType,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Left(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::ReduceType,
                rule: vec![::rusty_lr_core::Token::Term(Lexed::Right(None))],
            },
            GrammarRule {
                name: GrammarNonTerminals::ReduceDef,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::ReduceType),
                    ::rusty_lr_core::Token::Term(Lexed::Ident(None)),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::ReduceDef,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::ReduceType),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TerminalSet),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::ErrorDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::ErrorType(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::ModulePrefixDef,
                rule: vec![
                    ::rusty_lr_core::Token::Term(Lexed::ModulePrefix(None)),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::RustCode),
                    ::rusty_lr_core::Token::Term(Lexed::Semicolon(None)),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Rule),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Rule)],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TokenDef),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::TokenDef,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::StartDef),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::StartDef,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::EofDef),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::EofDef)],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::TokenTypeDef),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::TokenTypeDef,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::UserDataDef),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::UserDataDef,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::ReduceDef),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::ReduceDef,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::ErrorDef),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::ErrorDef,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::ModulePrefixDef),
                ],
            },
            GrammarRule {
                name: GrammarNonTerminals::Grammar,
                rule: vec![::rusty_lr_core::Token::NonTerm(
                    GrammarNonTerminals::ModulePrefixDef,
                )],
            },
            GrammarRule {
                name: GrammarNonTerminals::Augmented,
                rule: vec![
                    ::rusty_lr_core::Token::NonTerm(GrammarNonTerminals::Grammar),
                    ::rusty_lr_core::Token::Term(Lexed::Eof),
                ],
            },
        ];
        let _rustylr_generated_terminals_0 = vec![
            Lexed::BraceGroup(None),
            Lexed::BracketGroup(None),
            Lexed::Caret(None),
            Lexed::Colon(None),
            Lexed::Equal(None),
            Lexed::Exclamation(None),
            Lexed::Ident(None),
            Lexed::Literal(None),
            Lexed::Minus(None),
            Lexed::NoneGroup(None),
            Lexed::OtherPunct(None),
            Lexed::ParenGroup(None),
            Lexed::Percent(None),
            Lexed::Pipe(None),
            Lexed::Plus(None),
            Lexed::Question(None),
            Lexed::Semicolon(None),
            Lexed::Star(None),
        ];
        let _rustylr_generated_terminals_1 = vec![
            Lexed::Eof,
            Lexed::EofDef(None),
            Lexed::ErrorType(None),
            Lexed::Ident(None),
            Lexed::Left(None),
            Lexed::ModulePrefix(None),
            Lexed::Right(None),
            Lexed::Start(None),
            Lexed::Token(None),
            Lexed::TokenType(None),
            Lexed::UserData(None),
        ];
        let _rustylr_generated_terminals_2 = [Lexed::Semicolon(None)];
        let _rustylr_generated_terminals_3 = [Lexed::Colon(None)];
        let _rustylr_generated_terminals_4 = [Lexed::BraceGroup(None),
            Lexed::Pipe(None),
            Lexed::Semicolon(None)];
        let _rustylr_generated_terminals_5 = vec![
            Lexed::BraceGroup(None),
            Lexed::Exclamation(None),
            Lexed::Ident(None),
            Lexed::LBracket(None),
            Lexed::Pipe(None),
            Lexed::Plus(None),
            Lexed::Question(None),
            Lexed::Semicolon(None),
            Lexed::Star(None),
        ];
        let _rustylr_generated_terminals_6 = [Lexed::Ident(None), Lexed::RBracket(None)];
        let _rustylr_generated_terminals_7 = [Lexed::RBracket(None)];
        let _rustylr_generated_terminals_8 = vec![
            Lexed::BraceGroup(None),
            Lexed::Ident(None),
            Lexed::LBracket(None),
            Lexed::Pipe(None),
            Lexed::Semicolon(None),
        ];
        let _rustylr_generated_terminals_9 = [Lexed::Pipe(None), Lexed::Semicolon(None)];
        let _rustylr_generated_terminals_10 = [Lexed::Ident(None), Lexed::LBracket(None)];
        let pair_to_rule = |(rule, shifted): (usize, usize)| -> (
            ::rusty_lr_core::ShiftedRuleRef,
            std::collections::BTreeSet<Lexed>,
        ) {
            (
                ::rusty_lr_core::ShiftedRuleRef { rule, shifted },
                Default::default(),
            )
        };
        let mut states = Vec::with_capacity(110usize);
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(10usize);
            shift_goto_map_term.insert(Lexed::EofDef(None), 1usize);
            shift_goto_map_term.insert(Lexed::ErrorType(None), 24usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 27usize);
            shift_goto_map_term.insert(Lexed::Left(None), 63usize);
            shift_goto_map_term.insert(Lexed::ModulePrefix(None), 64usize);
            shift_goto_map_term.insert(Lexed::Right(None), 67usize);
            shift_goto_map_term.insert(Lexed::Start(None), 68usize);
            shift_goto_map_term.insert(Lexed::Token(None), 71usize);
            shift_goto_map_term.insert(Lexed::TokenType(None), 75usize);
            shift_goto_map_term.insert(Lexed::UserData(None), 78usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(11usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::EofDef, 81usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ErrorDef, 82usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Grammar, 83usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ModulePrefixDef, 103usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ReduceDef, 104usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ReduceType, 89usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Rule, 105usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::StartDef, 106usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenDef, 107usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenTypeDef, 108usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::UserDataDef, 109usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (0usize, 0usize),
                (29usize, 0usize),
                (50usize, 0usize),
                (51usize, 0usize),
                (52usize, 0usize),
                (53usize, 0usize),
                (54usize, 0usize),
                (55usize, 0usize),
                (56usize, 0usize),
                (57usize, 0usize),
                (58usize, 0usize),
                (59usize, 0usize),
                (60usize, 0usize),
                (61usize, 0usize),
                (62usize, 0usize),
                (63usize, 0usize),
                (64usize, 0usize),
                (65usize, 0usize),
                (66usize, 0usize),
                (67usize, 0usize),
                (68usize, 0usize),
                (69usize, 0usize),
                (70usize, 0usize),
                (71usize, 0usize),
                (72usize, 0usize),
                (73usize, 0usize),
                (74usize, 0usize),
                (75usize, 0usize),
                (76usize, 0usize),
                (77usize, 0usize),
                (78usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(17usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Exclamation(None), 7usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 8usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 9usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 10usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 11usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 12usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 13usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 14usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 15usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 16usize);
            shift_goto_map_term.insert(Lexed::Question(None), 17usize);
            shift_goto_map_term.insert(Lexed::Star(None), 18usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 19usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 21usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated6, 23usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (30usize, 0usize),
                (31usize, 0usize),
                (32usize, 0usize),
                (33usize, 0usize),
                (34usize, 0usize),
                (35usize, 0usize),
                (36usize, 0usize),
                (37usize, 0usize),
                (38usize, 0usize),
                (39usize, 0usize),
                (40usize, 0usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (43usize, 0usize),
                (44usize, 0usize),
                (45usize, 0usize),
                (46usize, 0usize),
                (47usize, 0usize),
                (48usize, 0usize),
                (49usize, 0usize),
                (51usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 31usize);
            }
            let rule_shifted_pairs = vec![(31usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 32usize);
            }
            let rule_shifted_pairs = vec![(32usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 33usize);
            }
            let rule_shifted_pairs = vec![(33usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 34usize);
            }
            let rule_shifted_pairs = vec![(34usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 35usize);
            }
            let rule_shifted_pairs = vec![(35usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 36usize);
            }
            let rule_shifted_pairs = vec![(36usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 37usize);
            }
            let rule_shifted_pairs = vec![(37usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 38usize);
            }
            let rule_shifted_pairs = vec![(38usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 39usize);
            }
            let rule_shifted_pairs = vec![(39usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 40usize);
            }
            let rule_shifted_pairs = vec![(40usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 41usize);
            }
            let rule_shifted_pairs = vec![(41usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 42usize);
            }
            let rule_shifted_pairs = vec![(42usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 43usize);
            }
            let rule_shifted_pairs = vec![(43usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 44usize);
            }
            let rule_shifted_pairs = vec![(44usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 45usize);
            }
            let rule_shifted_pairs = vec![(45usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 46usize);
            }
            let rule_shifted_pairs = vec![(46usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 47usize);
            }
            let rule_shifted_pairs = vec![(47usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 20usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(51usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 51usize);
            }
            let rule_shifted_pairs = vec![(51usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(17usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Exclamation(None), 7usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 8usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 9usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 10usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 11usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 12usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 13usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 14usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 15usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 16usize);
            shift_goto_map_term.insert(Lexed::Question(None), 17usize);
            shift_goto_map_term.insert(Lexed::Star(None), 18usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated6, 22usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_2.iter() {
                reduce_map.insert(term.clone(), 30usize);
            }
            let rule_shifted_pairs = vec![
                (30usize, 1usize),
                (31usize, 0usize),
                (32usize, 0usize),
                (33usize, 0usize),
                (34usize, 0usize),
                (35usize, 0usize),
                (36usize, 0usize),
                (37usize, 0usize),
                (38usize, 0usize),
                (39usize, 0usize),
                (40usize, 0usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (43usize, 0usize),
                (44usize, 0usize),
                (45usize, 0usize),
                (46usize, 0usize),
                (47usize, 0usize),
                (49usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 49usize);
            }
            let rule_shifted_pairs = vec![(49usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(18usize);
            for term in _rustylr_generated_terminals_0.iter() {
                reduce_map.insert(term.clone(), 48usize);
            }
            let rule_shifted_pairs = vec![(48usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(17usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Exclamation(None), 7usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 8usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 9usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 10usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 11usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 12usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 13usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 14usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 15usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 16usize);
            shift_goto_map_term.insert(Lexed::Question(None), 17usize);
            shift_goto_map_term.insert(Lexed::Star(None), 18usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 25usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 21usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated6, 23usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (30usize, 0usize),
                (31usize, 0usize),
                (32usize, 0usize),
                (33usize, 0usize),
                (34usize, 0usize),
                (35usize, 0usize),
                (36usize, 0usize),
                (37usize, 0usize),
                (38usize, 0usize),
                (39usize, 0usize),
                (40usize, 0usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (43usize, 0usize),
                (44usize, 0usize),
                (45usize, 0usize),
                (46usize, 0usize),
                (47usize, 0usize),
                (48usize, 0usize),
                (49usize, 0usize),
                (58usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 26usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(58usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 58usize);
            }
            let rule_shifted_pairs = vec![(58usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 28usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RuleType, 29usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_3.iter() {
                reduce_map.insert(term.clone(), 2usize);
            }
            let rule_shifted_pairs = vec![(0usize, 1usize), (1usize, 0usize), (2usize, 0usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_3.iter() {
                reduce_map.insert(term.clone(), 1usize);
            }
            let rule_shifted_pairs = vec![(1usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 30usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(0usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 31usize);
            shift_goto_map_term.insert(Lexed::LBracket(None), 34usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(7usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Pattern, 51usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RuleLine, 52usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RuleLines, 53usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSet, 50usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenMapped, 56usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated0, 57usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated1, 60usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(3usize);
            for term in _rustylr_generated_terminals_4.iter() {
                reduce_map.insert(term.clone(), 9usize);
            }
            let rule_shifted_pairs = vec![
                (0usize, 3usize),
                (3usize, 0usize),
                (4usize, 0usize),
                (5usize, 0usize),
                (6usize, 0usize),
                (7usize, 0usize),
                (8usize, 0usize),
                (9usize, 0usize),
                (10usize, 0usize),
                (11usize, 0usize),
                (14usize, 0usize),
                (21usize, 0usize),
                (22usize, 0usize),
                (23usize, 0usize),
                (24usize, 0usize),
                (25usize, 0usize),
                (26usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 32usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(9usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 21usize);
            }
            let rule_shifted_pairs = vec![(11usize, 1usize), (21usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 33usize);
            shift_goto_map_term.insert(Lexed::LBracket(None), 34usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(2usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Pattern, 45usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSet, 50usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (11usize, 2usize),
                (14usize, 0usize),
                (21usize, 0usize),
                (22usize, 0usize),
                (23usize, 0usize),
                (24usize, 0usize),
                (25usize, 0usize),
                (26usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(9usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 21usize);
            }
            let rule_shifted_pairs = vec![(21usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 35usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated2, 36usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_6.iter() {
                reduce_map.insert(term.clone(), 16usize);
            }
            let rule_shifted_pairs = vec![(14usize, 1usize), (15usize, 0usize), (16usize, 0usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_6.iter() {
                reduce_map.insert(term.clone(), 15usize);
            }
            let rule_shifted_pairs = vec![(15usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 37usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSetItem, 40usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated3, 41usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated4, 43usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_7.iter() {
                reduce_map.insert(term.clone(), 20usize);
            }
            let rule_shifted_pairs = vec![
                (12usize, 0usize),
                (13usize, 0usize),
                (14usize, 2usize),
                (17usize, 0usize),
                (18usize, 0usize),
                (19usize, 0usize),
                (20usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 38usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_6.iter() {
                reduce_map.insert(term.clone(), 12usize);
            }
            let rule_shifted_pairs = vec![(12usize, 1usize), (13usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 39usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(13usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_6.iter() {
                reduce_map.insert(term.clone(), 13usize);
            }
            let rule_shifted_pairs = vec![(13usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_6.iter() {
                reduce_map.insert(term.clone(), 17usize);
            }
            let rule_shifted_pairs = vec![(17usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::RBracket(None), 42usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(14usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(9usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 14usize);
            }
            let rule_shifted_pairs = vec![(14usize, 4usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 37usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSetItem, 44usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_7.iter() {
                reduce_map.insert(term.clone(), 19usize);
            }
            let rule_shifted_pairs = vec![
                (12usize, 0usize),
                (13usize, 0usize),
                (18usize, 1usize),
                (19usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_6.iter() {
                reduce_map.insert(term.clone(), 18usize);
            }
            let rule_shifted_pairs = vec![(18usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(4usize);
            shift_goto_map_term.insert(Lexed::Exclamation(None), 46usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 47usize);
            shift_goto_map_term.insert(Lexed::Question(None), 48usize);
            shift_goto_map_term.insert(Lexed::Star(None), 49usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(5usize);
            for term in _rustylr_generated_terminals_8.iter() {
                reduce_map.insert(term.clone(), 11usize);
            }
            let rule_shifted_pairs = vec![
                (11usize, 3usize),
                (22usize, 1usize),
                (23usize, 1usize),
                (24usize, 1usize),
                (25usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(9usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 25usize);
            }
            let rule_shifted_pairs = vec![(25usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(9usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 22usize);
            }
            let rule_shifted_pairs = vec![(22usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(9usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 24usize);
            }
            let rule_shifted_pairs = vec![(24usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(9usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 23usize);
            }
            let rule_shifted_pairs = vec![(23usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(9usize);
            for term in _rustylr_generated_terminals_5.iter() {
                reduce_map.insert(term.clone(), 26usize);
            }
            let rule_shifted_pairs = vec![(26usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(4usize);
            shift_goto_map_term.insert(Lexed::Exclamation(None), 46usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 47usize);
            shift_goto_map_term.insert(Lexed::Question(None), 48usize);
            shift_goto_map_term.insert(Lexed::Star(None), 49usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(5usize);
            for term in _rustylr_generated_terminals_8.iter() {
                reduce_map.insert(term.clone(), 10usize);
            }
            let rule_shifted_pairs = vec![
                (10usize, 1usize),
                (22usize, 1usize),
                (23usize, 1usize),
                (24usize, 1usize),
                (25usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_9.iter() {
                reduce_map.insert(term.clone(), 4usize);
            }
            let rule_shifted_pairs = vec![(4usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 54usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 62usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(0usize, 4usize), (3usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 31usize);
            shift_goto_map_term.insert(Lexed::LBracket(None), 34usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(6usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Pattern, 51usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RuleLine, 55usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSet, 50usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenMapped, 56usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated0, 57usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated1, 60usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(3usize);
            for term in _rustylr_generated_terminals_4.iter() {
                reduce_map.insert(term.clone(), 9usize);
            }
            let rule_shifted_pairs = vec![
                (3usize, 2usize),
                (5usize, 0usize),
                (6usize, 0usize),
                (7usize, 0usize),
                (8usize, 0usize),
                (9usize, 0usize),
                (10usize, 0usize),
                (11usize, 0usize),
                (14usize, 0usize),
                (21usize, 0usize),
                (22usize, 0usize),
                (23usize, 0usize),
                (24usize, 0usize),
                (25usize, 0usize),
                (26usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_9.iter() {
                reduce_map.insert(term.clone(), 3usize);
            }
            let rule_shifted_pairs = vec![(3usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(5usize);
            for term in _rustylr_generated_terminals_8.iter() {
                reduce_map.insert(term.clone(), 6usize);
            }
            let rule_shifted_pairs = vec![(6usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 58usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Action, 59usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_9.iter() {
                reduce_map.insert(term.clone(), 28usize);
            }
            let rule_shifted_pairs = vec![(5usize, 1usize), (27usize, 0usize), (28usize, 0usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_9.iter() {
                reduce_map.insert(term.clone(), 27usize);
            }
            let rule_shifted_pairs = vec![(27usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_9.iter() {
                reduce_map.insert(term.clone(), 5usize);
            }
            let rule_shifted_pairs = vec![(5usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 31usize);
            shift_goto_map_term.insert(Lexed::LBracket(None), 34usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Pattern, 51usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSet, 50usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenMapped, 61usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(3usize);
            for term in _rustylr_generated_terminals_4.iter() {
                reduce_map.insert(term.clone(), 8usize);
            }
            let rule_shifted_pairs = vec![
                (7usize, 1usize),
                (8usize, 1usize),
                (10usize, 0usize),
                (11usize, 0usize),
                (14usize, 0usize),
                (21usize, 0usize),
                (22usize, 0usize),
                (23usize, 0usize),
                (24usize, 0usize),
                (25usize, 0usize),
                (26usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(5usize);
            for term in _rustylr_generated_terminals_8.iter() {
                reduce_map.insert(term.clone(), 7usize);
            }
            let rule_shifted_pairs = vec![(7usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 0usize);
            }
            let rule_shifted_pairs = vec![(0usize, 5usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_10.iter() {
                reduce_map.insert(term.clone(), 54usize);
            }
            let rule_shifted_pairs = vec![(54usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(17usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Exclamation(None), 7usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 8usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 9usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 10usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 11usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 12usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 13usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 14usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 15usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 16usize);
            shift_goto_map_term.insert(Lexed::Question(None), 17usize);
            shift_goto_map_term.insert(Lexed::Star(None), 18usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 65usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 21usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated6, 23usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (30usize, 0usize),
                (31usize, 0usize),
                (32usize, 0usize),
                (33usize, 0usize),
                (34usize, 0usize),
                (35usize, 0usize),
                (36usize, 0usize),
                (37usize, 0usize),
                (38usize, 0usize),
                (39usize, 0usize),
                (40usize, 0usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (43usize, 0usize),
                (44usize, 0usize),
                (45usize, 0usize),
                (46usize, 0usize),
                (47usize, 0usize),
                (48usize, 0usize),
                (49usize, 0usize),
                (59usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 66usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(59usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 59usize);
            }
            let rule_shifted_pairs = vec![(59usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_10.iter() {
                reduce_map.insert(term.clone(), 55usize);
            }
            let rule_shifted_pairs = vec![(55usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 69usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(50usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 70usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(50usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 50usize);
            }
            let rule_shifted_pairs = vec![(50usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 72usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(29usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(17usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Exclamation(None), 7usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 8usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 9usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 10usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 11usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 12usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 13usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 14usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 15usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 16usize);
            shift_goto_map_term.insert(Lexed::Question(None), 17usize);
            shift_goto_map_term.insert(Lexed::Star(None), 18usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 73usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 21usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated6, 23usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (29usize, 2usize),
                (30usize, 0usize),
                (31usize, 0usize),
                (32usize, 0usize),
                (33usize, 0usize),
                (34usize, 0usize),
                (35usize, 0usize),
                (36usize, 0usize),
                (37usize, 0usize),
                (38usize, 0usize),
                (39usize, 0usize),
                (40usize, 0usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (43usize, 0usize),
                (44usize, 0usize),
                (45usize, 0usize),
                (46usize, 0usize),
                (47usize, 0usize),
                (48usize, 0usize),
                (49usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 74usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(29usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 29usize);
            }
            let rule_shifted_pairs = vec![(29usize, 4usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(17usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Exclamation(None), 7usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 8usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 9usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 10usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 11usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 12usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 13usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 14usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 15usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 16usize);
            shift_goto_map_term.insert(Lexed::Question(None), 17usize);
            shift_goto_map_term.insert(Lexed::Star(None), 18usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 76usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 21usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated6, 23usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (30usize, 0usize),
                (31usize, 0usize),
                (32usize, 0usize),
                (33usize, 0usize),
                (34usize, 0usize),
                (35usize, 0usize),
                (36usize, 0usize),
                (37usize, 0usize),
                (38usize, 0usize),
                (39usize, 0usize),
                (40usize, 0usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (43usize, 0usize),
                (44usize, 0usize),
                (45usize, 0usize),
                (46usize, 0usize),
                (47usize, 0usize),
                (48usize, 0usize),
                (49usize, 0usize),
                (52usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 77usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(52usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 52usize);
            }
            let rule_shifted_pairs = vec![(52usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(17usize);
            shift_goto_map_term.insert(Lexed::BraceGroup(None), 2usize);
            shift_goto_map_term.insert(Lexed::BracketGroup(None), 3usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 4usize);
            shift_goto_map_term.insert(Lexed::Colon(None), 5usize);
            shift_goto_map_term.insert(Lexed::Equal(None), 6usize);
            shift_goto_map_term.insert(Lexed::Exclamation(None), 7usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 8usize);
            shift_goto_map_term.insert(Lexed::Literal(None), 9usize);
            shift_goto_map_term.insert(Lexed::Minus(None), 10usize);
            shift_goto_map_term.insert(Lexed::NoneGroup(None), 11usize);
            shift_goto_map_term.insert(Lexed::OtherPunct(None), 12usize);
            shift_goto_map_term.insert(Lexed::ParenGroup(None), 13usize);
            shift_goto_map_term.insert(Lexed::Percent(None), 14usize);
            shift_goto_map_term.insert(Lexed::Pipe(None), 15usize);
            shift_goto_map_term.insert(Lexed::Plus(None), 16usize);
            shift_goto_map_term.insert(Lexed::Question(None), 17usize);
            shift_goto_map_term.insert(Lexed::Star(None), 18usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::RustCode, 79usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated5, 21usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated6, 23usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (30usize, 0usize),
                (31usize, 0usize),
                (32usize, 0usize),
                (33usize, 0usize),
                (34usize, 0usize),
                (35usize, 0usize),
                (36usize, 0usize),
                (37usize, 0usize),
                (38usize, 0usize),
                (39usize, 0usize),
                (40usize, 0usize),
                (41usize, 0usize),
                (42usize, 0usize),
                (43usize, 0usize),
                (44usize, 0usize),
                (45usize, 0usize),
                (46usize, 0usize),
                (47usize, 0usize),
                (48usize, 0usize),
                (49usize, 0usize),
                (53usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 80usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(53usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 53usize);
            }
            let rule_shifted_pairs = vec![(53usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 67usize);
            }
            let rule_shifted_pairs = vec![(67usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 75usize);
            }
            let rule_shifted_pairs = vec![(75usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(11usize);
            shift_goto_map_term.insert(Lexed::Eof, 84usize);
            shift_goto_map_term.insert(Lexed::EofDef(None), 1usize);
            shift_goto_map_term.insert(Lexed::ErrorType(None), 24usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 27usize);
            shift_goto_map_term.insert(Lexed::Left(None), 63usize);
            shift_goto_map_term.insert(Lexed::ModulePrefix(None), 64usize);
            shift_goto_map_term.insert(Lexed::Right(None), 67usize);
            shift_goto_map_term.insert(Lexed::Start(None), 68usize);
            shift_goto_map_term.insert(Lexed::Token(None), 71usize);
            shift_goto_map_term.insert(Lexed::TokenType(None), 75usize);
            shift_goto_map_term.insert(Lexed::UserData(None), 78usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(10usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::EofDef, 85usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ErrorDef, 86usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ModulePrefixDef, 87usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ReduceDef, 88usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::ReduceType, 89usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::Rule, 98usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::StartDef, 99usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenDef, 100usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TokenTypeDef, 101usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::UserDataDef, 102usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![
                (0usize, 0usize),
                (29usize, 0usize),
                (50usize, 0usize),
                (51usize, 0usize),
                (52usize, 0usize),
                (53usize, 0usize),
                (54usize, 0usize),
                (55usize, 0usize),
                (56usize, 0usize),
                (57usize, 0usize),
                (58usize, 0usize),
                (59usize, 0usize),
                (60usize, 1usize),
                (62usize, 1usize),
                (64usize, 1usize),
                (66usize, 1usize),
                (68usize, 1usize),
                (70usize, 1usize),
                (72usize, 1usize),
                (74usize, 1usize),
                (76usize, 1usize),
                (78usize, 1usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(78usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 66usize);
            }
            let rule_shifted_pairs = vec![(66usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 74usize);
            }
            let rule_shifted_pairs = vec![(74usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 76usize);
            }
            let rule_shifted_pairs = vec![(76usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 72usize);
            }
            let rule_shifted_pairs = vec![(72usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(2usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 90usize);
            shift_goto_map_term.insert(Lexed::LBracket(None), 92usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSet, 96usize);
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(14usize, 0usize), (56usize, 1usize), (57usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 91usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(56usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 56usize);
            }
            let rule_shifted_pairs = vec![(56usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Caret(None), 35usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(1usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated2, 93usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(2usize);
            for term in _rustylr_generated_terminals_6.iter() {
                reduce_map.insert(term.clone(), 16usize);
            }
            let rule_shifted_pairs = vec![(14usize, 1usize), (15usize, 0usize), (16usize, 0usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Ident(None), 37usize);
            let mut shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            shift_goto_map_nonterm.reserve(3usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::TerminalSetItem, 40usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated3, 94usize);
            shift_goto_map_nonterm.insert(GrammarNonTerminals::_RustyLRGenerated4, 43usize);
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_7.iter() {
                reduce_map.insert(term.clone(), 20usize);
            }
            let rule_shifted_pairs = vec![
                (12usize, 0usize),
                (13usize, 0usize),
                (14usize, 2usize),
                (17usize, 0usize),
                (18usize, 0usize),
                (19usize, 0usize),
                (20usize, 0usize),
            ];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::RBracket(None), 95usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(14usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(1usize);
            for term in _rustylr_generated_terminals_2.iter() {
                reduce_map.insert(term.clone(), 14usize);
            }
            let rule_shifted_pairs = vec![(14usize, 4usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let mut shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            shift_goto_map_term.reserve(1usize);
            shift_goto_map_term.insert(Lexed::Semicolon(None), 97usize);
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let reduce_map = ::rusty_lr_core::HashMap::default();
            let rule_shifted_pairs = vec![(57usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 57usize);
            }
            let rule_shifted_pairs = vec![(57usize, 3usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 60usize);
            }
            let rule_shifted_pairs = vec![(60usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 64usize);
            }
            let rule_shifted_pairs = vec![(64usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 62usize);
            }
            let rule_shifted_pairs = vec![(62usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 68usize);
            }
            let rule_shifted_pairs = vec![(68usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 70usize);
            }
            let rule_shifted_pairs = vec![(70usize, 2usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 77usize);
            }
            let rule_shifted_pairs = vec![(77usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 73usize);
            }
            let rule_shifted_pairs = vec![(73usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 61usize);
            }
            let rule_shifted_pairs = vec![(61usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 65usize);
            }
            let rule_shifted_pairs = vec![(65usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 63usize);
            }
            let rule_shifted_pairs = vec![(63usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 69usize);
            }
            let rule_shifted_pairs = vec![(69usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        {
            let shift_goto_map_term = ::rusty_lr_core::HashMap::default();
            let shift_goto_map_nonterm = ::rusty_lr_core::HashMap::default();
            let mut reduce_map = ::rusty_lr_core::HashMap::default();
            reduce_map.reserve(11usize);
            for term in _rustylr_generated_terminals_1.iter() {
                reduce_map.insert(term.clone(), 71usize);
            }
            let rule_shifted_pairs = vec![(71usize, 1usize)];
            let ruleset = ::rusty_lr_core::LookaheadRuleRefSet {
                rules: std::collections::BTreeMap::from_iter(
                    rule_shifted_pairs.into_iter().map(pair_to_rule),
                ),
            };
            let state = GrammarState {
                shift_goto_map_term,
                shift_goto_map_nonterm,
                reduce_map,
                ruleset,
            };
            states.push(state);
        }
        Self { rules, states }
    }
    #[doc = r" give lookahead token to parser, and check if there is any reduce action"]
    fn lookahead(
        &self,
        context: &mut GrammarContext,
        term: &Lexed,
    ) -> Result<(), GrammarParseError> {
        let state = &self.states[*context.state_stack.last().unwrap()];
        if let Some(reduce_rule) = state.reduce(term) {
            let rule = &self.rules[reduce_rule];
            context
                .state_stack
                .truncate(context.state_stack.len() - rule.rule.len());
            context
                .reduce(self.rules[reduce_rule].rule.len(), reduce_rule)
                .map_err(::rusty_lr_core::ParseError::ReduceAction)?;
            self.feed_nonterm(context, &rule.name)?;
            self.lookahead(context, term)?;
        }
        Ok(())
    }
    #[doc = r" feed one terminal to parser, and update state stack"]
    pub fn feed(&self, context: &mut GrammarContext, term: Lexed) -> Result<(), GrammarParseError> {
        self.lookahead(context, &term)?;
        let state = &self.states[*context.state_stack.last().unwrap()];
        if let Some(next_state_id) = state.shift_goto_term(&term) {
            context.state_stack.push(next_state_id);
            context.push(term);
            Ok(())
        } else {
            let error = ::rusty_lr_core::InvalidTerminalError {
                term,
                expected: state.expected().into_iter().cloned().collect(),
            };
            Err(::rusty_lr_core::ParseError::InvalidTerminal(error))
        }
    }
    #[doc = r" feed one non-terminal to parser, and update state stack"]
    fn feed_nonterm(
        &self,
        context: &mut GrammarContext,
        nonterm: &GrammarNonTerminals,
    ) -> Result<(), GrammarParseError> {
        let state = &self.states[*context.state_stack.last().unwrap()];
        if let Some(next_state_id) = state.shift_goto_nonterm(nonterm) {
            context.state_stack.push(next_state_id);
            Ok(())
        } else {
            unreachable!("Invalid NonTerminal: {}", nonterm);
        }
    }
    pub fn begin(&self) -> GrammarContext {
        GrammarContext::new()
    }
}
impl ::rusty_lr_core::GetParser<Lexed, GrammarNonTerminals> for GrammarParser {
    fn get_rules(&self) -> &[GrammarRule] {
        &self.rules
    }
    fn get_states(&self) -> &[GrammarState] {
        &self.states
    }
}
// ==============================Generated Codes End===============================
