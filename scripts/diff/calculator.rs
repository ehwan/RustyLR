
// This file was generated by rustylr 1.24.0
// This generated code is targeting rusty_lr version 3.31.0.
// There might be a build error if the version is not matched.
//
// ================================User Codes Begin================================
#[derive(Debug, Clone, Copy)]
pub enum Token {
    Num(i32),
    Plus,
    Star,
    LParen,
    RParen,
}
fn filter(term: &Token) -> &Token {
    term
}

// =================================User Codes End=================================
/*
====================================Grammar=====================================

# of terminal classes: 6
# of states: 13

0: A -> A plus A
1: A -> M
2: M -> M star M
3: M -> P
4: P -> num
5: P -> lparen E rparen
6: E -> A
7: Augmented -> E eof

*/
// =============================Generated Codes Begin==============================
/// type alias for `Context`
#[allow(non_camel_case_types, dead_code)]
pub type EContext = ::rusty_lr::parser::deterministic::Context<EDataStack, u8>;
/// type alias for CFG production rule
#[allow(non_camel_case_types, dead_code)]
pub type ERule = ::rusty_lr::rule::ProductionRule<&'static str, ENonTerminals>;
/// type alias for DFA state
#[allow(non_camel_case_types, dead_code)]
pub type EState = ::rusty_lr::parser::state::SparseState<u8, ENonTerminals, usize, u8>;
/// type alias for `ParseError`
#[allow(non_camel_case_types, dead_code)]
pub type EParseError = ::rusty_lr::parser::deterministic::ParseError<EDataStack>;
/// An enum that represents non-terminal symbols
#[allow(non_camel_case_types, dead_code)]
#[derive(
    Clone,
    Copy,
    std::hash::Hash,
    std::cmp::PartialEq,
    std::cmp::Eq,
    std::cmp::PartialOrd,
    std::cmp::Ord
)]
pub enum ENonTerminals {
    A,
    M,
    P,
    E,
    Augmented,
}
impl std::fmt::Display for ENonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::nonterminal::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl std::fmt::Debug for ENonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::nonterminal::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl ::rusty_lr::nonterminal::NonTerminal for ENonTerminals {
    fn as_str(&self) -> &'static str {
        match self {
            ENonTerminals::A => "A",
            ENonTerminals::M => "M",
            ENonTerminals::P => "P",
            ENonTerminals::E => "E",
            ENonTerminals::Augmented => "Augmented",
        }
    }
    fn is_trace(&self) -> bool {
        match self {
            ENonTerminals::A => false,
            ENonTerminals::M => false,
            ENonTerminals::P => false,
            ENonTerminals::E => false,
            ENonTerminals::Augmented => false,
        }
    }
    fn nonterm_type(&self) -> Option<::rusty_lr::nonterminal::NonTerminalType> {
        match self {
            ENonTerminals::A => None,
            ENonTerminals::M => None,
            ENonTerminals::P => None,
            ENonTerminals::E => None,
            ENonTerminals::Augmented => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Augmented)
            }
        }
    }
    fn to_usize(&self) -> usize {
        *self as usize
    }
}
/// tag for token that represents which stack a token is using
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum ETags {
    __terminals,
    __stack2,
    Empty,
}
/// enum for each non-terminal and terminal symbol, that actually hold data
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
pub struct EDataStack {
    pub __tags: Vec<ETags>,
    __terminals: Vec<Token>,
    __stack2: Vec<i32>,
}
impl Default for EDataStack {
    fn default() -> Self {
        Self {
            __tags: Vec::new(),
            __terminals: Vec::new(),
            __stack2: Vec::new(),
        }
    }
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut,
    dead_code
)]
impl EDataStack {
    fn custom_reduce_action_0(
        mut M: i32,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<i32, String> {
        Ok({ M * 1 })
    }
    ///A -> A plus A
    #[inline]
    fn reduce_A_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, String> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ETags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ETags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut a2 = __data_stack.__stack2.pop().unwrap();
        let mut A = __data_stack.__stack2.pop().unwrap();
        let mut plus = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            println!("{:?} {:?} {:?}", A, plus, a2);
            *data += 1;
            A + a2
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///A -> M
    #[inline(always)]
    fn reduce_A_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __location_stack.truncate(__location_stack.len() - 1usize);
        true
    }
    ///M -> M star M
    #[inline]
    fn reduce_M_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, String> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ETags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ETags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut __rustylr_data_2 = __data_stack.__stack2.pop().unwrap();
        let mut __rustylr_data_0 = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __rustylr_data_0 = Self::custom_reduce_action_0(
            __rustylr_data_0,
            data,
            __rustylr_location0,
        )?;
        let mut M_optim = __rustylr_data_0;
        let __rustylr_data_2 = Self::custom_reduce_action_0(
            __rustylr_data_2,
            data,
            __rustylr_location0,
        )?;
        let mut m2 = __rustylr_data_2;
        let __res = { M_optim * m2 };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///P -> num
    #[inline]
    fn reduce_P_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, String> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ETags::__stack2);
        let mut num = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            if let Token::Num(n) = num {
                n
            } else {
                return Err(format!("{:?}", num));
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///P -> lparen E rparen
    #[inline(always)]
    fn reduce_P_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ETags::__stack2);
        true
    }
    ///E -> A
    #[inline(always)]
    fn reduce_E_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __location_stack.truncate(__location_stack.len() - 1usize);
        true
    }
}
#[allow(
    unused_braces,
    unused_parens,
    non_snake_case,
    non_camel_case_types,
    unused_variables
)]
impl ::rusty_lr::parser::data_stack::DataStack for EDataStack {
    type Term = Token;
    type NonTerm = ENonTerminals;
    type ReduceActionError = String;
    type UserData = i32;
    type StartType = i32;
    type Location = ::rusty_lr::DefaultLocation;
    fn pop_start(&mut self) -> Option<Self::StartType> {
        let tag = self.__tags.pop();
        debug_assert!(tag == Some(ETags::__stack2));
        self.__stack2.pop()
    }
    fn pop(&mut self) {
        match self.__tags.pop().unwrap() {
            ETags::__terminals => {
                self.__terminals.pop();
            }
            ETags::__stack2 => {
                self.__stack2.pop();
            }
            _ => {}
        }
    }
    fn push_terminal(&mut self, term: Self::Term) {
        self.__tags.push(ETags::__terminals);
        self.__terminals.push(term);
    }
    fn push_empty(&mut self) {
        self.__tags.push(ETags::Empty);
    }
    fn clear(&mut self) {
        self.__tags.clear();
        self.__terminals.clear();
        self.__stack2.clear();
    }
    fn reserve(&mut self, additional: usize) {
        self.__tags.reserve(additional);
    }
    fn split_off(&mut self, at: usize) -> Self {
        let __other_tag_stack = self.__tags.split_off(at);
        let mut __counts: [u8; 2usize + 1] = [0; 2usize + 1];
        for &tag in &__other_tag_stack {
            __counts[tag as usize] += 1;
        }
        let __other___terminals = self
            .__terminals
            .split_off(self.__terminals.len() - (__counts[0usize] as usize));
        let __other___stack2 = self
            .__stack2
            .split_off(self.__stack2.len() - (__counts[1usize] as usize));
        Self {
            __tags: __other_tag_stack,
            __terminals: __other___terminals,
            __stack2: __other___stack2,
        }
    }
    fn append(&mut self, other: &mut Self) {
        self.__tags.append(&mut other.__tags);
        self.__terminals.append(&mut other.__terminals);
        self.__stack2.append(&mut other.__stack2);
    }
    fn reduce_action(
        data_stack: &mut Self,
        location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        rule_index: usize,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Self::Term>,
        user_data: &mut Self::UserData,
        location0: &mut Self::Location,
    ) -> Result<bool, Self::ReduceActionError> {
        match rule_index {
            0usize => {
                Self::reduce_A_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            1usize => Ok(Self::reduce_A_1(data_stack, location_stack)),
            2usize => {
                Self::reduce_M_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            3usize => {
                unreachable!("{rule_index}: this production rule was optimized out")
            }
            4usize => {
                Self::reduce_P_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            5usize => Ok(Self::reduce_P_1(data_stack, location_stack)),
            6usize => Ok(Self::reduce_E_0(data_stack, location_stack)),
            7usize => {
                unreachable!("{rule_index}: this production rule was optimized out")
            }
            _ => {
                unreachable!("Invalid Rule: {}", rule_index);
            }
        }
    }
}
/// A struct that holds the entire parser table and production rules.
#[allow(unused_braces, unused_parens, unused_variables, non_snake_case, unused_mut)]
pub struct EParser {
    /// production rules
    pub rules: Vec<ERule>,
    /// states
    pub states: Vec<EState>,
    /// terminal classes
    pub classes: Vec<Vec<&'static str>>,
}
impl ::rusty_lr::parser::Parser for EParser {
    type Term = Token;
    type NonTerm = ENonTerminals;
    type State = EState;
    type TerminalClassElement = &'static str;
    const ERROR_USED: bool = false;
    fn class_precedence(
        &self,
        class: ::rusty_lr::TerminalSymbol<usize>,
    ) -> ::rusty_lr::parser::Precedence {
        match class {
            ::rusty_lr::TerminalSymbol::Term(class) => {
                #[allow(unreachable_patterns)]
                match class {
                    1 => ::rusty_lr::parser::Precedence::new(0),
                    2 => ::rusty_lr::parser::Precedence::new(1),
                    _ => ::rusty_lr::parser::Precedence::none(),
                }
            }
            ::rusty_lr::TerminalSymbol::Error => ::rusty_lr::parser::Precedence::none(),
            ::rusty_lr::TerminalSymbol::Eof => {
                unreachable!("eof token cannot be used in precedence levels")
            }
        }
    }
    fn precedence_types(&self, level: u8) -> Option<::rusty_lr::rule::ReduceType> {
        #[allow(unreachable_patterns)]
        match level {
            0..=1 => Some(::rusty_lr::rule::ReduceType::Left),
            _ => None,
        }
    }
    fn get_rules(&self) -> &[ERule] {
        &self.rules
    }
    fn get_states(&self) -> &[EState] {
        &self.states
    }
    fn get_terminals(
        &self,
        i: usize,
    ) -> Option<impl IntoIterator<Item = Self::TerminalClassElement> + '_> {
        self.classes.get(i).map(|class| class.iter().copied())
    }
    fn to_terminal_class(&self, terminal: &Self::Term) -> usize {
        #[allow(unreachable_patterns)]
        match filter(terminal) {
            Token::Num(_) => 0,
            Token::Plus => 1,
            Token::Star => 2,
            Token::LParen => 3,
            Token::RParen => 4,
            _ => 5,
        }
    }
}
/// A struct that holds the whole parser table.
#[allow(unused_braces, unused_parens, unused_variables, non_snake_case, unused_mut)]
impl EParser {
    /// Calculates the states and parser tables from the grammar.
    #[allow(clippy::clone_on_copy)]
    pub fn new() -> Self {
        let rules: Vec<
            ::rusty_lr::rule::ProductionRule<::rusty_lr::TerminalSymbol<u8>, _>,
        > = vec![
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::A, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::A),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(1)),
            ::rusty_lr::Token::NonTerm(ENonTerminals::A),], precedence :
            Some(::rusty_lr::rule::Precedence::Fixed(0usize)), },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::A, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::M),], precedence : None, },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::M, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::M),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(2)),
            ::rusty_lr::Token::NonTerm(ENonTerminals::M),], precedence :
            Some(::rusty_lr::rule::Precedence::Fixed(1usize)), },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::M, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::P),], precedence : None, },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::P, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ENonTerminals::P, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(3)),
            ::rusty_lr::Token::NonTerm(ENonTerminals::E),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(4)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name : ENonTerminals::E, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::A),], precedence : None, },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::Augmented, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::E),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Eof),], precedence :
            None, },
        ];
        let terminal_class_names = vec![
            "num", "plus", "star", "lparen", "rparen", "<Others>",
        ];
        let rules = rules
            .into_iter()
            .map(move |rule| {
                rule.map(
                    |term| match term {
                        ::rusty_lr::TerminalSymbol::Term(term) => {
                            terminal_class_names[term as usize]
                        }
                        ::rusty_lr::TerminalSymbol::Error => "error",
                        ::rusty_lr::TerminalSymbol::Eof => "eof",
                    },
                    |nonterm| nonterm,
                )
            })
            .collect();
        let __rustylr_tset0: Vec<u8> = vec![1, 2, 4];
        let __rustylr_tset2: Vec<u8> = vec![1, 4];
        let __rustylr_tset1: Vec<u8> = vec![4];
        let states: Vec<::rusty_lr::parser::state::IntermediateState<u8, _, u8, u8>> = vec![
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![(ENonTerminals::A,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (ENonTerminals::M,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (ENonTerminals::P,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (ENonTerminals::E,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [0, 1, 2, 3, 4, 5, 6, 7,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter())
            .map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![4]; __reduce_map.extend(__rustylr_tset0.iter().map(| term
            | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : Some(vec![4]), ruleset : { let rules : &
            'static [u8] = & [4,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (3, ::rusty_lr::parser::state::ShiftTarget::new(2, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ENonTerminals::A, ::rusty_lr::parser::state::ShiftTarget::new(3,
            true)), (ENonTerminals::M, ::rusty_lr::parser::state::ShiftTarget::new(6,
            true)), (ENonTerminals::P, ::rusty_lr::parser::state::ShiftTarget::new(6,
            true)), (ENonTerminals::E, ::rusty_lr::parser::state::ShiftTarget::new(9,
            true)),], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [0, 1, 2, 3, 4, 5, 5, 6,]; let shifted : & 'static [u8] = & [0, 0,
            0, 0, 0, 0, 1, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(1,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules = vec![6];
            __reduce_map.extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![6]), ruleset : { let rules : & 'static [u8] = & [0,
            6,]; let shifted : & 'static [u8] = & [1, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![(ENonTerminals::A,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (ENonTerminals::M,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (ENonTerminals::P,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [0, 0, 1, 2, 3, 4, 5,]; let shifted : &
            'static [u8] = & [0, 2, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter())
            .map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![0]; __reduce_map.extend(__rustylr_tset2.iter().map(| term
            | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : Some(vec![0]), ruleset : { let rules : &
            'static [u8] = & [0,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(2, ::rusty_lr::parser::state::ShiftTarget::new(7,
            true)),], error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![1]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![1]), ruleset : { let rules : & 'static [u8] = & [1, 2,]; let
            shifted : & 'static [u8] = & [1, 1,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![(ENonTerminals::M,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (ENonTerminals::P,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [2, 2, 3, 4, 5,]; let shifted : & 'static [u8]
            = & [0, 2, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![2]; __reduce_map.extend(__rustylr_tset0.iter().map(| term
            | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : Some(vec![2]), ruleset : { let rules : &
            'static [u8] = & [2,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(4,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [5,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![5]; __reduce_map
            .extend(__rustylr_tset0.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![5]), ruleset : { let rules : & 'static [u8] = & [5,]; let shifted :
            & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : Some(12), shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [7,]; let shifted : & 'static [u8]
            = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [7,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } },
        ];
        let states: Vec<EState> = states.into_iter().map(|state| state.into()).collect();
        Self {
            rules,
            states,
            classes: vec![
                vec!["num",], vec!["plus",], vec!["star",], vec!["lparen",],
                vec!["rparen",],
            ],
        }
    }
}

// ==============================Generated Codes End===============================
        