
// This file was generated by rustylr 1.27.0
// This generated code is targeting rusty_lr version 3.34.0.
// There might be a build error if the version is not matched.
//
// ================================User Codes Begin================================

// =================================User Codes End=================================
/*
====================================Grammar=====================================

# of terminal classes: 9
# of states: 25

0: Digit -> '0'
1: Digit -> ['1', '2', ..., '6'-'9']
2: Number -> ' '* Digit+ ' '*
3: P -> Number
4: P -> ' '* '(' E ')' ' '*
5: E -> E Op E
6: E -> ' '* '-' E
7: E -> P
8: Op -> '+'
9: Op -> '*'
10: ' '+ -> ' '
11: ' '+ -> ' '+ ' '
12: ' '* -> ' '+
13: ' '* -> 
14: Digit+ -> Digit
15: Digit+ -> Digit+ Digit
16: Augmented -> E eof

*/
// =============================Generated Codes Begin==============================
/// type alias for `Context`
#[allow(non_camel_case_types, dead_code)]
pub type EContext = ::rusty_lr::parser::deterministic::Context<EDataStack, u8>;
/// type alias for CFG production rule
#[allow(non_camel_case_types, dead_code)]
pub type ERule = ::rusty_lr::rule::ProductionRule<ETerminalClasses, ENonTerminals>;
/// type alias for DFA state
#[allow(non_camel_case_types, dead_code)]
pub type EState = ::rusty_lr::parser::state::SparseState<
    ETerminalClasses,
    ENonTerminals,
    u8,
    u8,
>;
/// type alias for `ParseError`
#[allow(non_camel_case_types, dead_code)]
pub type EParseError = ::rusty_lr::parser::deterministic::ParseError<
    char,
    ::rusty_lr::DefaultLocation,
    ::rusty_lr::DefaultReduceActionError,
>;
/// A enum that represents terminal classes
#[allow(non_camel_case_types, dead_code)]
#[derive(
    Clone,
    Copy,
    std::hash::Hash,
    std::cmp::PartialEq,
    std::cmp::Eq,
    std::cmp::PartialOrd,
    std::cmp::Ord
)]
pub enum ETerminalClasses {
    TermClass0,
    TermClass1,
    TermClass2,
    TermClass3,
    TermClass4,
    TermClass5,
    TermClass6,
    TermClass7,
    TermClass8,
    error,
    eof,
}
impl ::rusty_lr::parser::terminalclass::TerminalClass for ETerminalClasses {
    type Term = char;
    const ERROR: Self = Self::error;
    const EOF: Self = Self::eof;
    fn as_str(&self) -> &'static str {
        match self {
            ETerminalClasses::TermClass0 => "' '",
            ETerminalClasses::TermClass1 => "<Others>",
            ETerminalClasses::TermClass2 => "'('",
            ETerminalClasses::TermClass3 => "')'",
            ETerminalClasses::TermClass4 => "'-'",
            ETerminalClasses::TermClass5 => "'0'",
            ETerminalClasses::TermClass6 => "['1', '2', ..., '6'-'9']",
            ETerminalClasses::TermClass7 => "'*'",
            ETerminalClasses::TermClass8 => "'+'",
            ETerminalClasses::error => "error",
            ETerminalClasses::eof => "eof",
        }
    }
    fn to_usize(&self) -> usize {
        *self as usize
    }
    fn precedence(&self) -> ::rusty_lr::parser::Precedence {
        match self {
            ETerminalClasses::TermClass8 => ::rusty_lr::parser::Precedence::new(0),
            ETerminalClasses::TermClass7 => ::rusty_lr::parser::Precedence::new(1),
            ETerminalClasses::eof => {
                unreachable!("eof token cannot be used in precedence levels")
            }
            _ => ::rusty_lr::parser::Precedence::none(),
        }
    }
    fn from_term(terminal: &Self::Term) -> Self {
        #[allow(unreachable_patterns)]
        match terminal {
            ' ' => ETerminalClasses::TermClass0,
            '(' => ETerminalClasses::TermClass2,
            ')' => ETerminalClasses::TermClass3,
            '-' => ETerminalClasses::TermClass4,
            '0' => ETerminalClasses::TermClass5,
            '1'..='9' => ETerminalClasses::TermClass6,
            '*' => ETerminalClasses::TermClass7,
            '+' => ETerminalClasses::TermClass8,
            _ => ETerminalClasses::TermClass1,
        }
    }
}
impl std::fmt::Display for ETerminalClasses {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::parser::terminalclass::TerminalClass;
        write!(f, "{}", self.as_str())
    }
}
impl std::fmt::Debug for ETerminalClasses {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::parser::terminalclass::TerminalClass;
        write!(f, "{}", self.as_str())
    }
}
/// An enum that represents non-terminal symbols
#[allow(non_camel_case_types, dead_code)]
#[derive(
    Clone,
    Copy,
    std::hash::Hash,
    std::cmp::PartialEq,
    std::cmp::Eq,
    std::cmp::PartialOrd,
    std::cmp::Ord
)]
pub enum ENonTerminals {
    Digit,
    Number,
    P,
    E,
    Op,
    __Terminal32Plus6,
    __Terminal32Star7,
    _DigitPlus9,
    Augmented,
}
impl std::fmt::Display for ENonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::parser::nonterminal::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl std::fmt::Debug for ENonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::parser::nonterminal::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl ::rusty_lr::parser::nonterminal::NonTerminal for ENonTerminals {
    fn as_str(&self) -> &'static str {
        match self {
            ENonTerminals::Digit => "Digit",
            ENonTerminals::Number => "Number",
            ENonTerminals::P => "P",
            ENonTerminals::E => "E",
            ENonTerminals::Op => "Op",
            ENonTerminals::__Terminal32Plus6 => "' '+",
            ENonTerminals::__Terminal32Star7 => "' '*",
            ENonTerminals::_DigitPlus9 => "Digit+",
            ENonTerminals::Augmented => "Augmented",
        }
    }
    fn is_trace(&self) -> bool {
        match self {
            ENonTerminals::Digit => false,
            ENonTerminals::Number => false,
            ENonTerminals::P => false,
            ENonTerminals::E => false,
            ENonTerminals::Op => false,
            ENonTerminals::__Terminal32Plus6 => false,
            ENonTerminals::__Terminal32Star7 => false,
            ENonTerminals::_DigitPlus9 => false,
            ENonTerminals::Augmented => false,
        }
    }
    fn nonterm_type(&self) -> Option<::rusty_lr::parser::nonterminal::NonTerminalType> {
        match self {
            ENonTerminals::Digit => None,
            ENonTerminals::Number => None,
            ENonTerminals::P => None,
            ENonTerminals::E => None,
            ENonTerminals::Op => None,
            ENonTerminals::__Terminal32Plus6 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::PlusLeft)
            }
            ENonTerminals::__Terminal32Star7 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::Star)
            }
            ENonTerminals::_DigitPlus9 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::PlusLeft)
            }
            ENonTerminals::Augmented => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::Augmented)
            }
        }
    }
    fn to_usize(&self) -> usize {
        *self as usize
    }
}
/// tag for token that represents which stack a token is using
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum ETags {
    __terminals,
    __stack1,
    __stack2,
    __stack3,
    Empty,
}
/// enum for each non-terminal and terminal symbol, that actually hold data
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
pub struct EDataStack {
    pub __tags: Vec<ETags>,
    __terminals: Vec<char>,
    __stack1: Vec<i32>,
    __stack2: Vec<f32>,
    __stack3: Vec<Vec<char>>,
}
impl Default for EDataStack {
    fn default() -> Self {
        Self {
            __tags: Vec::new(),
            __terminals: Vec::new(),
            __stack1: Vec::new(),
            __stack2: Vec::new(),
            __stack3: Vec::new(),
        }
    }
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut,
    dead_code
)]
impl EDataStack {
    ///Digit -> '0'
    #[inline]
    fn reduce_Digit_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::Empty)
            );
        }
        if __push_data {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
            __data_stack.__tags.push(ETags::__terminals);
        } else {}
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { '0' };
        if __push_data {
            __data_stack.__terminals.push(__res);
        }
        Ok(())
    }
    ///Number -> ' '* Digit+ ' '*
    #[inline]
    fn reduce_Number_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ETags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ETags::Empty)
            );
        }
        if __push_data {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
            __data_stack.__tags.push(ETags::__stack1);
        } else {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        }
        let mut Digit = __data_stack.__stack3.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { Digit.into_iter().collect::<String>().parse().unwrap() };
        if __push_data {
            __data_stack.__stack1.push(__res);
        }
        Ok(())
    }
    ///P -> Number
    #[inline]
    fn reduce_P_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::__stack1)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        if __push_data {
            __data_stack.__tags.push(ETags::__stack2);
        } else {
            __data_stack.__tags.push(ETags::Empty);
        }
        let mut Number = __data_stack.__stack1.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Number as f32 };
        if __push_data {
            __data_stack.__stack2.push(__res);
        }
        Ok(())
    }
    ///P -> ' '* '(' E ')' ' '*
    #[inline]
    fn reduce_P_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ETags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ETags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ETags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                ETags::Empty)
            );
        }
        if __push_data {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
            __data_stack.__tags.push(ETags::__stack2);
        } else {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        }
        let mut E = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __res = E;
        if __push_data {
            __data_stack.__stack2.push(__res);
        }
        Ok(())
    }
    ///E -> E Op E
    #[inline]
    fn reduce_E_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ETags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ETags::__stack2)
            );
        }
        if __push_data {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        } else {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
            __data_stack.__tags.push(ETags::Empty);
        }
        let mut e2 = __data_stack.__stack2.pop().unwrap();
        let mut E = __data_stack.__stack2.pop().unwrap();
        let mut Op = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            *data += 1;
            println!("{:?} {:?} {:?}", E, Op, e2);
            match Op {
                '+' => E + e2,
                '*' => E * e2,
                _ => panic!("Unknown operator: {:?}", Op),
            }
        };
        if __push_data {
            __data_stack.__stack2.push(__res);
        }
        Ok(())
    }
    ///E -> ' '* '-' E
    #[inline]
    fn reduce_E_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ETags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ETags::Empty)
            );
        }
        if __push_data {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
            __data_stack.__tags.push(ETags::__stack2);
        } else {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        }
        let mut E = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { -E };
        if __push_data {
            __data_stack.__stack2.push(__res);
        }
        Ok(())
    }
    ///' '+ -> ' '+ ' '
    #[inline]
    fn reduce___Terminal32Plus6_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ETags::Empty)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        Ok(())
    }
    ///' '* -> ' '+
    #[inline]
    fn reduce___Terminal32Star7_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::Empty)
            );
        }
        __location_stack.truncate(__location_stack.len() - 1usize);
        Ok(())
    }
    ///' '* ->
    #[inline]
    fn reduce___Terminal32Star7_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ETags::Empty);
        Ok(())
    }
    ///Digit+ -> Digit
    #[inline]
    fn reduce__DigitPlus9_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        if __push_data {
            __data_stack.__tags.push(ETags::__stack3);
        } else {
            __data_stack.__tags.push(ETags::Empty);
        }
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        if __push_data {
            __data_stack.__stack3.push(__res);
        }
        Ok(())
    }
    ///Digit+ -> Digit+ Digit
    #[inline]
    fn reduce__DigitPlus9_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        __push_data: bool,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<char>,
        data: &mut i32,
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<(), ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ETags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ETags::__stack3)
            );
        }
        if __push_data {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        } else {
            __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
            __data_stack.__tags.push(ETags::Empty);
        }
        let mut Ap = __data_stack.__stack3.pop().unwrap();
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        if __push_data {
            __data_stack.__stack3.push(__res);
        }
        Ok(())
    }
}
#[allow(
    unused_braces,
    unused_parens,
    non_snake_case,
    non_camel_case_types,
    unused_variables
)]
impl ::rusty_lr::parser::data_stack::DataStack for EDataStack {
    type Term = char;
    type NonTerm = ENonTerminals;
    type ReduceActionError = ::rusty_lr::DefaultReduceActionError;
    type UserData = i32;
    type StartType = f32;
    type Location = ::rusty_lr::DefaultLocation;
    fn pop_start(&mut self) -> Option<Self::StartType> {
        let tag = self.__tags.pop();
        debug_assert!(tag == Some(ETags::__stack2));
        self.__stack2.pop()
    }
    fn pop(&mut self) {
        match self.__tags.pop().unwrap() {
            ETags::__terminals => {
                self.__terminals.pop();
            }
            ETags::__stack1 => {
                self.__stack1.pop();
            }
            ETags::__stack2 => {
                self.__stack2.pop();
            }
            ETags::__stack3 => {
                self.__stack3.pop();
            }
            _ => {}
        }
    }
    fn push_terminal(&mut self, term: Self::Term) {
        self.__tags.push(ETags::__terminals);
        self.__terminals.push(term);
    }
    fn push_empty(&mut self) {
        self.__tags.push(ETags::Empty);
    }
    fn clear(&mut self) {
        self.__tags.clear();
        self.__terminals.clear();
        self.__stack1.clear();
        self.__stack2.clear();
        self.__stack3.clear();
    }
    fn reserve(&mut self, additional: usize) {
        self.__tags.reserve(additional);
    }
    fn split_off(&mut self, at: usize) -> Self {
        let mut __counts: [u8; 4usize + 1] = [0; 4usize + 1];
        let __other_tag_stack = self.__tags.split_off(at);
        for &tag in &__other_tag_stack {
            __counts[tag as usize] += 1;
        }
        let __other___terminals = self
            .__terminals
            .split_off(self.__terminals.len() - (__counts[0usize] as usize));
        let __other___stack1 = self
            .__stack1
            .split_off(self.__stack1.len() - (__counts[1usize] as usize));
        let __other___stack2 = self
            .__stack2
            .split_off(self.__stack2.len() - (__counts[2usize] as usize));
        let __other___stack3 = self
            .__stack3
            .split_off(self.__stack3.len() - (__counts[3usize] as usize));
        Self {
            __terminals: __other___terminals,
            __stack1: __other___stack1,
            __stack2: __other___stack2,
            __stack3: __other___stack3,
            __tags: __other_tag_stack,
        }
    }
    fn append(&mut self, other: &mut Self) {
        self.__tags.append(&mut other.__tags);
        self.__terminals.append(&mut other.__terminals);
        self.__stack1.append(&mut other.__stack1);
        self.__stack2.append(&mut other.__stack2);
        self.__stack3.append(&mut other.__stack3);
    }
    fn reduce_action(
        data_stack: &mut Self,
        location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        push_data: bool,
        rule_index: usize,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Self::Term>,
        user_data: &mut Self::UserData,
        location0: &mut Self::Location,
    ) -> Result<(), Self::ReduceActionError> {
        match rule_index {
            0usize => {
                Self::reduce_Digit_0(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            2usize => {
                Self::reduce_Number_0(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            3usize => {
                Self::reduce_P_0(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            4usize => {
                Self::reduce_P_1(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            5usize => {
                Self::reduce_E_0(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            6usize => {
                Self::reduce_E_1(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            11usize => {
                Self::reduce___Terminal32Plus6_1(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            12usize => {
                Self::reduce___Terminal32Star7_0(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            13usize => {
                Self::reduce___Terminal32Star7_1(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            14usize => {
                Self::reduce__DigitPlus9_0(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            15usize => {
                Self::reduce__DigitPlus9_1(
                    data_stack,
                    location_stack,
                    push_data,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            _ => {
                unreachable!("Invalid Rule: {}", rule_index);
            }
        }
    }
}
/// A struct that holds the entire parser table and production rules.
#[allow(unused_braces, unused_parens, unused_variables, non_snake_case, unused_mut)]
pub struct EParser {
    /// production rules
    pub rules: Vec<ERule>,
    /// states
    pub states: Vec<EState>,
}
impl ::rusty_lr::parser::Parser for EParser {
    type Term = char;
    type TermClass = ETerminalClasses;
    type NonTerm = ENonTerminals;
    type State = EState;
    const ERROR_USED: bool = false;
    fn precedence_types(&self, level: u8) -> Option<::rusty_lr::rule::ReduceType> {
        #[allow(unreachable_patterns)]
        match level {
            0..=1 => Some(::rusty_lr::rule::ReduceType::Left),
            _ => None,
        }
    }
    fn get_rules(&self) -> &[ERule] {
        &self.rules
    }
    fn get_states(&self) -> &[EState] {
        &self.states
    }
}
/// A struct that holds the whole parser table.
#[allow(unused_braces, unused_parens, unused_variables, non_snake_case, unused_mut)]
impl EParser {
    /// Calculates the states and parser tables from the grammar.
    #[allow(clippy::clone_on_copy)]
    pub fn new() -> Self {
        let rules: Vec<
            ::rusty_lr::rule::ProductionRule<ETerminalClasses, ENonTerminals>,
        > = vec![
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::Digit, rule :
            vec![::rusty_lr::Token::Term(ETerminalClasses::TermClass5),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name : ENonTerminals::Digit, rule
            : vec![::rusty_lr::Token::Term(ETerminalClasses::TermClass6),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name : ENonTerminals::Number,
            rule : vec![::rusty_lr::Token::NonTerm(ENonTerminals::__Terminal32Star7),
            ::rusty_lr::Token::NonTerm(ENonTerminals::_DigitPlus9),
            ::rusty_lr::Token::NonTerm(ENonTerminals::__Terminal32Star7),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name : ENonTerminals::P, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::Number),], precedence : None,
            }, ::rusty_lr::rule::ProductionRule { name : ENonTerminals::P, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::__Terminal32Star7),
            ::rusty_lr::Token::Term(ETerminalClasses::TermClass2),
            ::rusty_lr::Token::NonTerm(ENonTerminals::E),
            ::rusty_lr::Token::Term(ETerminalClasses::TermClass3),
            ::rusty_lr::Token::NonTerm(ENonTerminals::__Terminal32Star7),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name : ENonTerminals::E, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::E),
            ::rusty_lr::Token::NonTerm(ENonTerminals::Op),
            ::rusty_lr::Token::NonTerm(ENonTerminals::E),], precedence :
            Some(::rusty_lr::rule::Precedence::Dynamic(1usize)), },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::E, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::__Terminal32Star7),
            ::rusty_lr::Token::Term(ETerminalClasses::TermClass4),
            ::rusty_lr::Token::NonTerm(ENonTerminals::E),], precedence :
            Some(::rusty_lr::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::E, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::P),], precedence : None, },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::Op, rule :
            vec![::rusty_lr::Token::Term(ETerminalClasses::TermClass8),], precedence :
            Some(::rusty_lr::rule::Precedence::Fixed(0usize)), },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::Op, rule :
            vec![::rusty_lr::Token::Term(ETerminalClasses::TermClass7),], precedence :
            Some(::rusty_lr::rule::Precedence::Fixed(1usize)), },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::__Terminal32Plus6,
            rule : vec![::rusty_lr::Token::Term(ETerminalClasses::TermClass0),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ENonTerminals::__Terminal32Plus6, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::__Terminal32Plus6),
            ::rusty_lr::Token::Term(ETerminalClasses::TermClass0),], precedence : None,
            }, ::rusty_lr::rule::ProductionRule { name :
            ENonTerminals::__Terminal32Star7, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::__Terminal32Plus6),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ENonTerminals::__Terminal32Star7, rule : vec![], precedence : None, },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::_DigitPlus9, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::Digit),], precedence : None,
            }, ::rusty_lr::rule::ProductionRule { name : ENonTerminals::_DigitPlus9, rule
            : vec![::rusty_lr::Token::NonTerm(ENonTerminals::_DigitPlus9),
            ::rusty_lr::Token::NonTerm(ENonTerminals::Digit),], precedence : None, },
            ::rusty_lr::rule::ProductionRule { name : ENonTerminals::Augmented, rule :
            vec![::rusty_lr::Token::NonTerm(ENonTerminals::E),
            ::rusty_lr::Token::Term(ETerminalClasses::eof),], precedence : None, },
        ];
        static __RUSTYLR_TSET0: [ETerminalClasses; 4usize] = [
            ETerminalClasses::TermClass2,
            ETerminalClasses::TermClass4,
            ETerminalClasses::TermClass5,
            ETerminalClasses::TermClass6,
        ];
        static __RUSTYLR_TSET3: [ETerminalClasses; 3usize] = [
            ETerminalClasses::TermClass3,
            ETerminalClasses::TermClass7,
            ETerminalClasses::TermClass8,
        ];
        static __RUSTYLR_TSET2: [ETerminalClasses; 4usize] = [
            ETerminalClasses::TermClass3,
            ETerminalClasses::TermClass7,
            ETerminalClasses::TermClass8,
            ETerminalClasses::eof,
        ];
        static __RUSTYLR_TSET1: [ETerminalClasses; 3usize] = [
            ETerminalClasses::TermClass7,
            ETerminalClasses::TermClass8,
            ETerminalClasses::eof,
        ];
        let states: Vec<
            ::rusty_lr::parser::state::IntermediateState<
                ETerminalClasses,
                ENonTerminals,
                u8,
                u8,
            >,
        > = vec![
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(ETerminalClasses::TermClass0,
            ::rusty_lr::parser::state::ShiftTarget::new(6, false)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Number,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (ENonTerminals::P,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (ENonTerminals::E,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),
            (ENonTerminals::__Terminal32Plus6,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (ENonTerminals::__Terminal32Star7,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map({ let mut __reduce_map =
            std::collections::BTreeMap::new(); { static __REDUCE_RULES : [u8; 1usize] =
            [13]; __reduce_map.extend(__RUSTYLR_TSET0.iter().map(| term | (* term,
            __REDUCE_RULES.to_vec()))); } __reduce_map.into_iter().collect() }), ruleset
            : { static __RULES : [u8; 11usize] = [2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 16,];
            static __SHIFTED : [u8; 11usize] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Value(vec![3]), ruleset : { static
            __RULES : [u8; 1usize] = [3,]; static __SHIFTED : [u8; 1usize] = [1,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(ETerminalClasses::TermClass7,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),
            (ETerminalClasses::TermClass8, ::rusty_lr::parser::state::ShiftTarget::new(4,
            true)), (ETerminalClasses::eof,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Op,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map(Default::default()), ruleset : {
            static __RULES : [u8; 4usize] = [5, 8, 9, 16,]; static __SHIFTED : [u8;
            4usize] = [1, 0, 0, 1,]; __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() }, can_accept_error :
            ::rusty_lr::TriState::False, }, ::rusty_lr::parser::state::IntermediateState
            { shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map(Default::default()), ruleset : {
            static __RULES : [u8; 1usize] = [16,]; static __SHIFTED : [u8; 1usize] =
            [2,]; __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(ETerminalClasses::TermClass0,
            ::rusty_lr::parser::state::ShiftTarget::new(6, false)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Number,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (ENonTerminals::P,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (ENonTerminals::E,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (ENonTerminals::__Terminal32Plus6,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (ENonTerminals::__Terminal32Star7,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map({ let mut __reduce_map =
            std::collections::BTreeMap::new(); { static __REDUCE_RULES : [u8; 1usize] =
            [13]; __reduce_map.extend(__RUSTYLR_TSET0.iter().map(| term | (* term,
            __REDUCE_RULES.to_vec()))); } __reduce_map.into_iter().collect() }), ruleset
            : { static __RULES : [u8; 11usize] = [2, 3, 4, 5, 5, 6, 7, 10, 11, 12, 13,];
            static __SHIFTED : [u8; 11usize] = [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(ETerminalClasses::TermClass7,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),
            (ETerminalClasses::TermClass8, ::rusty_lr::parser::state::ShiftTarget::new(4,
            true)),], shift_goto_map_nonterm : vec![(ENonTerminals::Op,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map({ let mut __reduce_map =
            std::collections::BTreeMap::new(); { static __REDUCE_RULES : [u8; 1usize] =
            [5]; __reduce_map.extend(__RUSTYLR_TSET1.iter().map(| term | (* term,
            __REDUCE_RULES.to_vec()))); } __reduce_map.into_iter().collect() }), ruleset
            : { static __RULES : [u8; 4usize] = [5, 5, 8, 9,]; static __SHIFTED : [u8;
            4usize] = [1, 3, 0, 0,]; __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() }, can_accept_error :
            ::rusty_lr::TriState::False, }, ::rusty_lr::parser::state::IntermediateState
            { shift_goto_map_term : vec![(ETerminalClasses::TermClass0,
            ::rusty_lr::parser::state::ShiftTarget::new(7, false)),],
            shift_goto_map_nonterm : vec![], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Value(vec![12]), ruleset : { static
            __RULES : [u8; 2usize] = [11, 12,]; static __SHIFTED : [u8; 2usize] = [1,
            1,]; __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Value(vec![11]), ruleset : { static
            __RULES : [u8; 1usize] = [11,]; static __SHIFTED : [u8; 1usize] = [2,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(ETerminalClasses::TermClass2,
            ::rusty_lr::parser::state::ShiftTarget::new(9, false)),
            (ETerminalClasses::TermClass4,
            ::rusty_lr::parser::state::ShiftTarget::new(23, false)),
            (ETerminalClasses::TermClass5,
            ::rusty_lr::parser::state::ShiftTarget::new(18, false)),
            (ETerminalClasses::TermClass6,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Digit,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (ENonTerminals::_DigitPlus9, ::rusty_lr::parser::state::ShiftTarget::new(20,
            true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map(Default::default()), ruleset : {
            static __RULES : [u8; 7usize] = [0, 1, 2, 4, 6, 14, 15,]; static __SHIFTED :
            [u8; 7usize] = [0, 0, 1, 1, 1, 0, 0,]; __RULES.iter().zip(__SHIFTED.iter())
            .map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() }, can_accept_error :
            ::rusty_lr::TriState::False, }, ::rusty_lr::parser::state::IntermediateState
            { shift_goto_map_term : vec![(ETerminalClasses::TermClass0,
            ::rusty_lr::parser::state::ShiftTarget::new(6, false)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Number,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (ENonTerminals::P,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (ENonTerminals::E,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)),
            (ENonTerminals::__Terminal32Plus6,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (ENonTerminals::__Terminal32Star7,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map({ let mut __reduce_map =
            std::collections::BTreeMap::new(); { static __REDUCE_RULES : [u8; 1usize] =
            [13]; __reduce_map.extend(__RUSTYLR_TSET0.iter().map(| term | (* term,
            __REDUCE_RULES.to_vec()))); } __reduce_map.into_iter().collect() }), ruleset
            : { static __RULES : [u8; 11usize] = [2, 3, 4, 4, 5, 6, 7, 10, 11, 12, 13,];
            static __SHIFTED : [u8; 11usize] = [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(ETerminalClasses::TermClass3,
            ::rusty_lr::parser::state::ShiftTarget::new(11, false)),
            (ETerminalClasses::TermClass7,
            ::rusty_lr::parser::state::ShiftTarget::new(13, true)),
            (ETerminalClasses::TermClass8,
            ::rusty_lr::parser::state::ShiftTarget::new(13, true)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Op,
            ::rusty_lr::parser::state::ShiftTarget::new(13, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map(Default::default()), ruleset : {
            static __RULES : [u8; 4usize] = [4, 5, 8, 9,]; static __SHIFTED : [u8;
            4usize] = [3, 1, 0, 0,]; __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() }, can_accept_error :
            ::rusty_lr::TriState::False, }, ::rusty_lr::parser::state::IntermediateState
            { shift_goto_map_term : vec![(ETerminalClasses::TermClass0,
            ::rusty_lr::parser::state::ShiftTarget::new(6, false)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::__Terminal32Plus6,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (ENonTerminals::__Terminal32Star7,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map({ let mut __reduce_map =
            std::collections::BTreeMap::new(); { static __REDUCE_RULES : [u8; 1usize] =
            [13]; __reduce_map.extend(__RUSTYLR_TSET2.iter().map(| term | (* term,
            __REDUCE_RULES.to_vec()))); } __reduce_map.into_iter().collect() }), ruleset
            : { static __RULES : [u8; 5usize] = [4, 10, 11, 12, 13,]; static __SHIFTED :
            [u8; 5usize] = [4, 0, 0, 0, 0,]; __RULES.iter().zip(__SHIFTED.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() }, can_accept_error :
            ::rusty_lr::TriState::False, }, ::rusty_lr::parser::state::IntermediateState
            { shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Value(vec![4]), ruleset : { static
            __RULES : [u8; 1usize] = [4,]; static __SHIFTED : [u8; 1usize] = [5,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(ETerminalClasses::TermClass0,
            ::rusty_lr::parser::state::ShiftTarget::new(6, false)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Number,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (ENonTerminals::P,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (ENonTerminals::E,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)),
            (ENonTerminals::__Terminal32Plus6,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (ENonTerminals::__Terminal32Star7,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map({ let mut __reduce_map =
            std::collections::BTreeMap::new(); { static __REDUCE_RULES : [u8; 1usize] =
            [13]; __reduce_map.extend(__RUSTYLR_TSET0.iter().map(| term | (* term,
            __REDUCE_RULES.to_vec()))); } __reduce_map.into_iter().collect() }), ruleset
            : { static __RULES : [u8; 11usize] = [2, 3, 4, 5, 5, 6, 7, 10, 11, 12, 13,];
            static __SHIFTED : [u8; 11usize] = [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(ETerminalClasses::TermClass7,
            ::rusty_lr::parser::state::ShiftTarget::new(13, true)),
            (ETerminalClasses::TermClass8,
            ::rusty_lr::parser::state::ShiftTarget::new(13, true)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Op,
            ::rusty_lr::parser::state::ShiftTarget::new(13, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map({ let mut __reduce_map =
            std::collections::BTreeMap::new(); { static __REDUCE_RULES : [u8; 1usize] =
            [5]; __reduce_map.extend(__RUSTYLR_TSET3.iter().map(| term | (* term,
            __REDUCE_RULES.to_vec()))); } __reduce_map.into_iter().collect() }), ruleset
            : { static __RULES : [u8; 4usize] = [5, 5, 8, 9,]; static __SHIFTED : [u8;
            4usize] = [1, 3, 0, 0,]; __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() }, can_accept_error :
            ::rusty_lr::TriState::False, }, ::rusty_lr::parser::state::IntermediateState
            { shift_goto_map_term : vec![(ETerminalClasses::TermClass2,
            ::rusty_lr::parser::state::ShiftTarget::new(9, false)),
            (ETerminalClasses::TermClass4,
            ::rusty_lr::parser::state::ShiftTarget::new(16, false)),
            (ETerminalClasses::TermClass5,
            ::rusty_lr::parser::state::ShiftTarget::new(18, false)),
            (ETerminalClasses::TermClass6,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Digit,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (ENonTerminals::_DigitPlus9, ::rusty_lr::parser::state::ShiftTarget::new(20,
            true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map(Default::default()), ruleset : {
            static __RULES : [u8; 7usize] = [0, 1, 2, 4, 6, 14, 15,]; static __SHIFTED :
            [u8; 7usize] = [0, 0, 1, 1, 1, 0, 0,]; __RULES.iter().zip(__SHIFTED.iter())
            .map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() }, can_accept_error :
            ::rusty_lr::TriState::False, }, ::rusty_lr::parser::state::IntermediateState
            { shift_goto_map_term : vec![(ETerminalClasses::TermClass0,
            ::rusty_lr::parser::state::ShiftTarget::new(6, false)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Number,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (ENonTerminals::P,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)), (ENonTerminals::E,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (ENonTerminals::__Terminal32Plus6,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (ENonTerminals::__Terminal32Star7,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map({ let mut __reduce_map =
            std::collections::BTreeMap::new(); { static __REDUCE_RULES : [u8; 1usize] =
            [13]; __reduce_map.extend(__RUSTYLR_TSET0.iter().map(| term | (* term,
            __REDUCE_RULES.to_vec()))); } __reduce_map.into_iter().collect() }), ruleset
            : { static __RULES : [u8; 11usize] = [2, 3, 4, 5, 6, 6, 7, 10, 11, 12, 13,];
            static __SHIFTED : [u8; 11usize] = [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![(ENonTerminals::Op,
            ::rusty_lr::parser::state::ShiftTarget::new(13, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Value(vec![6]), ruleset : { static
            __RULES : [u8; 2usize] = [5, 6,]; static __SHIFTED : [u8; 2usize] = [1, 3,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Value(vec![0]), ruleset : { static
            __RULES : [u8; 1usize] = [0,]; static __SHIFTED : [u8; 1usize] = [1,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Value(vec![14]), ruleset : { static
            __RULES : [u8; 1usize] = [14,]; static __SHIFTED : [u8; 1usize] = [1,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(ETerminalClasses::TermClass0,
            ::rusty_lr::parser::state::ShiftTarget::new(6, false)),
            (ETerminalClasses::TermClass5,
            ::rusty_lr::parser::state::ShiftTarget::new(18, false)),
            (ETerminalClasses::TermClass6,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Digit,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (ENonTerminals::__Terminal32Plus6,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (ENonTerminals::__Terminal32Star7,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map({ let mut __reduce_map =
            std::collections::BTreeMap::new(); { static __REDUCE_RULES : [u8; 1usize] =
            [13]; __reduce_map.extend(__RUSTYLR_TSET2.iter().map(| term | (* term,
            __REDUCE_RULES.to_vec()))); } __reduce_map.into_iter().collect() }), ruleset
            : { static __RULES : [u8; 8usize] = [0, 1, 2, 10, 11, 12, 13, 15,]; static
            __SHIFTED : [u8; 8usize] = [0, 0, 2, 0, 0, 0, 0, 1,]; __RULES.iter()
            .zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Value(vec![15]), ruleset : { static
            __RULES : [u8; 1usize] = [15,]; static __SHIFTED : [u8; 1usize] = [2,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Value(vec![2]), ruleset : { static
            __RULES : [u8; 1usize] = [2,]; static __SHIFTED : [u8; 1usize] = [3,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(ETerminalClasses::TermClass0,
            ::rusty_lr::parser::state::ShiftTarget::new(6, false)),],
            shift_goto_map_nonterm : vec![(ENonTerminals::Number,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (ENonTerminals::P,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)), (ENonTerminals::E,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (ENonTerminals::__Terminal32Plus6,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (ENonTerminals::__Terminal32Star7,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Map({ let mut __reduce_map =
            std::collections::BTreeMap::new(); { static __REDUCE_RULES : [u8; 1usize] =
            [13]; __reduce_map.extend(__RUSTYLR_TSET0.iter().map(| term | (* term,
            __REDUCE_RULES.to_vec()))); } __reduce_map.into_iter().collect() }), ruleset
            : { static __RULES : [u8; 11usize] = [2, 3, 4, 5, 6, 6, 7, 10, 11, 12, 13,];
            static __SHIFTED : [u8; 11usize] = [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![(ENonTerminals::Op,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),], reduce_map :
            ::rusty_lr::parser::state::ReduceMap::Value(vec![6]), ruleset : { static
            __RULES : [u8; 2usize] = [5, 6,]; static __SHIFTED : [u8; 2usize] = [1, 3,];
            __RULES.iter().zip(__SHIFTED.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() }, can_accept_error : ::rusty_lr::TriState::False, },
        ];
        let states: Vec<EState> = states.into_iter().map(|state| state.into()).collect();
        Self { rules, states }
    }
}

// ==============================Generated Codes End===============================
        