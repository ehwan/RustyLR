//! # RustyLR
//! yacc-like LR(1) and LALR(1) Deterministic Finite Automata (DFA) generator from Context Free Grammar (CFGs).
//!
//! RustyLR provides both [executable](#executable-rustylr) and [procedural macros](#proc-macro-syntax) to generate LR(1) and LALR(1) parser.
//!
//! `features=["fxhash"]` to replace `std::collections::HashMap` with [`FxHashMap`](https://github.com/rust-lang/rustc-hash)
//!
//! ## Features
//!  - pure Rust implementation
//!  - readable error messages, both for grammar building and parsing
//!  - compile-time DFA construction from CFGs
//!  - customizable reduce action
//!  - resolving conflicts of ambiguous grammar
//!  - tracing parser action with callback
//!  - regex patterns partially supported
//!  - executable for generating parser tables from CFGs
//!
//! ### Simple definition of CFG
//! ```rust
//! lr1! {
//!     // userdata type
//!     %userdata i32;
//!     // token type
//!     %tokentype char;
//!     // start symbol
//!     %start E;
//!     // eof symbol
//!     %eof '\0';
//!
//!     // token definition
//!     %token zero '0';
//!     %token one '1';
//!     %token two '2';
//!     %token three '3';
//!     %token four '4';
//!     %token five '5';
//!     %token six '6';
//!     %token seven '7';
//!     %token eight '8';
//!     %token nine '9';
//!     %token plus '+';
//!     %token star '*';
//!     %token lparen '(';
//!     %token rparen ')';
//!     %token space ' ';
//!
//!     // conflict resolving
//!     %left plus;
//!     %left star;
//!
//!     // context-free grammars
//!     WS0: space*;
//!
//!     Digit(char): [zero-nine];
//!
//!     Number(i32): WS0 Digit+ WS0 { Digit.into_iter().collect::<String>().parse().unwrap() };
//!
//!     A(f32): A plus a2=A {
//!         *data += 1; // access userdata by `data`
//!         println!( "{:?} {:?} {:?}", A, plus, a2 );
//!         A + a2 // this will be the new value of A
//!     }
//!         | M
//!         ;
//!
//!     M(f32): M star m2=M { M * m2 }
//!         | P
//!         ;
//!
//!     P(f32): Number { Number as f32 }
//!         | WS0 lparen E rparen WS0 { E }
//!         ;
//!
//!     E(f32) : A ;
//! }
//! ```
//! ## proc-macro syntax
//!
//! Below procedural macros are provided:
//!  - `lr1!`, `lalr1!`
//!
//! These macros will define three structs: `Parser`, `Context`, and `enum NonTerminals`, prefixed by `<StartSymbol>`.
//! In most cases, what you want is the `Parser` struct, which contains the DFA states and `feed()` functions.
//! Please refer to the [Start Parsing](#start-parsing) section below for actual usage of the `Parser` struct.
//!
//! Those macros (those without '_runtime' suffix) will generate `Parser` struct at compile-time.
//! The calculation of building DFA will be done at compile-time, and the generated code will be *TONS* of `insert` of tokens one by one.
//!
//! [Bootstrap](https://github.com/ehwan/RustyLR/blob/main/rusty_lr_parser/src/parser/parser.rs), [Expanded Bootstrap](https://github.com/ehwan/RustyLR/blob/main/rusty_lr_parser/src/parser/parser_expanded.rs) would be a good example to understand the syntax and generated code. It is RustyLR syntax parser written in RustyLR itself.
//!
//! Every line in the macro must follow the syntax [here](https://github.com/ehwan/RustyLR?tab=readme-ov-file#proc-macro-syntax)
//!
//!
//! ## Start Parsing
//! `<StartSymbol>Parser` will be generated by the procedural macros.
//!
//! The parser struct has the following functions:
//!  - `new()` : create new parser
//!  - `begin(&self)` : create new context
//!  - `feed(&self, &mut Context, TermType, &mut UserData) -> Result<(), ParseError>` : feed token to the parser
//!  - `feed_callback(&self, &mut Context, &mut C: Callback, TermType, &mut UserData) -> Result<(), ParseError>` : feed token with callback
//!
//! Note that the parameter `&mut UserData` is omitted if `%userdata` is not defined.
//! Once the input sequence is feeded (including `eof` token), without errors, you can get the value of start symbol by calling `context.accept()`.
//!
//! ```ignore
//! let parser = parser::EParser::new();
//! // create context
//! let mut context = parser.begin();
//! // define userdata
//! let mut userdata: i32 = 0;
//!
//! // start feeding tokens
//! for token in input_sequence {
//!     match parser.feed(&mut context, token, &mut userdata) {
//!         //                          ^^^^^   ^^^^^^^^^^^^ userdata passed here as `&mut i32`
//!         //                           |- feed token
//!         Ok(_) => {}
//!         Err(e) => {
//!             println!("{}", e);
//!             // println!( "{}", e.long_message() ); // for more detailed error message
//!             return;
//!         }
//!     }
//! }
//! // res = value of start symbol
//! let res = context.accept();
//! println!("{}", res);
//! println!("userdata: {}", userdata);
//! ```
//!
//!
//! ## executable `rustylr`
//! ```
//! cargo install rustylr
//! ```
//! An executable version of `lr1!` and `lalr1!` macro.
//! Converts a context-free grammar into a deterministic finite automaton (DFA) tables,
//! and generates a Rust code that can be used as a parser for that grammar.
//!
//! This executable will provide much more detailed, pretty-printed error messages than the procedural macros.
//! If you are writing a huge, complex grammar, it is recommended to use this executable than the procedural macros.
//! `--verbose` option is useful for debugging the grammar. It will print the auto-generated rules and the resolving process of shift/reduce conflicts.

// re-exports

pub use rusty_lr_core::*;
pub use rusty_lr_derive::*;
